<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta lang="ja">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>React基礎①</title>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/reveal.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/theme/black.min.css">
    <style>
        .reveal {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        .reveal h1,
        .reveal h2,
        .reveal h3,
        .reveal h4 {
            color: #667eea;
            text-transform: none;
        }

        .reveal .pale {
            opacity: 0.9;
            font-size: 1em;
        }

        .reveal .slides section {
            text-align: left;
        }

        .reveal .title-slide {
            text-align: center;
        }

        .reveal .code-wrapper code {
            font-size: 1.3em;
        }

        .reveal .code-wrapper .code-medium {
            font-size: 1.19em;
        }

        .reveal .code-wrapper .code-medium-small {
            font-size: 1.1em;
        }

        .reveal .code-wrapper .code-small,
        .code-small {
            font-size: 0.9em;
        }

        .code-small .code-wrapper {
            width: 100%;
        }

        .reveal .comparison .hljs {
            max-height: 350px;
            min-height: unset;
            height: 100%;
        }

        ul>li,
        dl>dd {
            line-height: 2em;
        }

        .lifecycle {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 40px 0;
            padding: 20px;
            border-radius: 10px;
        }

        .lifecycle div {
            background: rgba(255, 255, 255, 0.1);
            flex: 1;
            text-align: center;
            padding: 10px;
            border-radius: 10px;
        }

        .lifecycle .arrow {
            background: none;
            font-size: 100px;
            color: #667eea;
            flex: 0;
        }

        .down-arrow {
            opacity: 0.7;
            display: flex;
            justify-content: center;
            font-size: 50px;
            flex: 0;
        }

        .comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }

        .js-side,
        .ts-side {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 8px;
        }

        .js-side h4 {
            color: #f39c12;
        }

        .ts-side h4 {
            color: #3498db;
        }

        .note {
            background: rgba(52, 152, 219, 0.2);
            border-left: 4px solid #3498db;
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .warning {
            background: rgba(231, 76, 60, 0.2);
            border-left: 4px solid #e74c3c;
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .quiz {
            background: rgba(46, 204, 113, 0.1);
            border-left: 4px solid #2ecc71;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
        }

        .quiz-options {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr 1fr;
            gap: 10px;
        }

        .quiz-option {
            display: block;
            margin: 8px 0;
            padding: 8px 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .quiz-option:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .fragment.correct-answer.visible {
            border-left: 4px solid #2ecc71;
            background: rgba(46, 204, 113, 0.3);
        }

        .reveal pre code {
            padding: 1em;
        }

        .timer {
            position: absolute;
            top: -30px;
            right: 15px;
        }

        .comparison-table {
            font-size: 0.75em;
            border-collapse: collapse;
            width: 100%;
            margin: 1rem 0;
        }

        .comparison-table th,
        .comparison-table td {
            padding: 0.6rem 0.4rem;
            text-align: center;
        }

        .comparison-table thead th {
            font-weight: bold;
        }

        .comparison-table .metric {
            font-weight: bold;
            text-align: left;
        }
    </style>
</head>

<body>
    <div class="reveal">
        <div class="slides">
            <section class="title-slide">
                <h1>React基礎①</h1>
                <h2>Reactとは、JSX、コンポーネント、Propsの使い方</h2>
                <aside class="notes"></aside>
            </section>

            <section>
                <!-- What is React -->
                <section>
                    <h1>Reactとは？</h1>
                    <p class="intro-text"><strong>ユーザインターフェース構築のためのJavaScriptライブラリ</strong></p>

                    <ul>
                        <li>Meta（旧Facebook）が2013年にオープンソース化</li>
                        <li>コンポーネントベースのアーキテクチャ</li>
                        <li>仮想DOMによる効率的な更新</li>
                        <li>宣言的なプログラミングモデル</li>
                    </ul>

                    <div class="note">
                        「何を表示するか」を記述すれば、「どうやって更新するか」はReactが処理する
                    </div>
                </section>

                <!-- Why React was needed -->
                <section>
                    <h2>従来のDOM操作の問題点</h2>

                    <h3>手動DOM操作の課題</h3>
                    <ul>
                        <li>状態とUIの同期を手動で管理する必要</li>
                        <li>DOMの直接操作はバグの温床</li>
                        <li>アプリが大きくなると管理が困難</li>
                        <li>コードが複雑になりがち</li>
                    </ul>
                </section>
                <section>
                    <h2>コード比較</h2>
                    <div class="comparison">
                        <div class="comparison-item">
                            <h4>従来のJavaScript</h4>
                            <pre><code data-lang="javascript" class="code-small">const button = document.getElementById('btn');
const counter = document.getElementById('count');
let count = 0;

button.addEventListener('click', () => {
  count++;
  counter.textContent = count;
  // 他の場所でcountを使用している箇所も
  // 手動で更新する必要がある
});</code></pre>
                        </div>
                        <div class="comparison-item">
                            <h4>React</h4>
                            <pre><code data-lang="tsx" class="code-small">function Counter() {
  const [count, setCount] = useState(0);
  
  return (
    &lt;div&gt;
      &lt;span&gt;{count}&lt;/span&gt;
      &lt;button onClick={() => setCount(count + 1)}&gt;
        +1
      &lt;/button&gt;
    &lt;/div&gt;
  );
}</code></pre>
                        </div>
                    </div>
                </section>

                <!-- React's Approach -->
                <section>
                    <h2>Reactのアプローチ</h2>

                    <h3>宣言的UI</h3>
                    <p>「状態が変わったら全体を再描画」という発想の転換</p>

                    <ul>
                        <li><strong>状態管理の単純化</strong>：状態を変更するだけでUIが自動更新</li>
                        <li><strong>仮想DOM</strong>：メモリ上で差分を計算し、必要な部分だけ更新</li>
                        <li><strong>コンポーネント思考</strong>：UIを再利用可能な部品として構築</li>
                    </ul>

                    <div class="note">
                        従来の「どうやって更新するか」から「何を表示するか」への思考転換
                    </div>
                </section>

                <!-- SPA Introduction -->
                <section>
                    <h2>SPA【Single Page Application】とは？</h2>

                    <h3>従来のWebサイト【Multi Page Application】</h3>
                    <ul>
                        <li>ページ遷移のたびにサーバーから新しいHTMLを取得</li>
                        <li>画面全体がリロードされる</li>
                        <li>ページ遷移が遅い</li>
                    </ul>

                    <h3>SPA</h3>
                    <ul>
                        <li>初回ロード後、JavaScriptでページ遷移を制御</li>
                        <li>必要なデータのみAPIで取得</li>
                        <li>高速なページ遷移が可能</li>
                    </ul>
                </section>
                <section>
                    <h2>SPA【Single Page Application】とは？</h2>
                    <div class="comparison">
                        <div class="pros">
                            <h4>メリット</h4>
                            <ul>
                                <li>高速なページ遷移</li>
                                <li>アプリライクなUX</li>
                                <li>サーバー負荷軽減</li>
                            </ul>
                        </div>
                        <div class="cons">
                            <h4>課題</h4>
                            <ul>
                                <li>初回ロードが重い</li>
                                <li>SEOが困難</li>
                                <li>JavaScriptが必須</li>
                            </ul>
                        </div>
                    </div>
                </section>

                <!-- The SPA Problem -->
                <section>
                    <h2>SPAの根本的な問題</h2>
                    <div class="warning">
                        <p><strong>純粋なSPAは多くの問題を抱えており現在は「呪われた」技術とされることも</strong></p>
                    </div>

                    <h3>主な問題点</h3>
                    <ul>
                        <li><strong>SEO</strong> : 検索エンジンがJavaScriptを実行しないと内容が見えない</li>
                        <li><strong>初回ロード</strong> : すべてのJavaScriptをダウンロードするまで何も表示されない</li>
                        <li><strong>パフォーマンス</strong> : バンドルが大きくなりがち</li>
                        <li><strong>複雑性</strong> : クライアントサイドでの状態管理が複雑</li>
                    </ul>
                </section>

                <!-- Slide 9: SPA Solutions -->
                <section>
                    <h2>現実的な解決策</h2>
                    <ul>
                        <li><strong>SSR【Server Side Rendering】</strong><br>サーバーでHTMLを生成</li>
                        <li><strong>SSG【Static Site Generation】</strong><br>ビルド時に静的HTMLを生成</li>
                        <li><strong>ISR【Incremental Static Regeneration】</strong><br>必要に応じて静的ページを再生成</li>
                    </ul>

                    <div class="note">
                        これらの手法で純粋SPAの問題を解決（Next.js、React Router/Remix等のフレームワーク）
                    </div>
                </section>

                <!-- Ecosystem Overview -->
                <section>
                    <h2>Reactエコシステム（参考）</h2>
                    <h3>フルスタックフレームワーク</h3>
                    <ul>
                        <li><strong>Next.js</strong>：SSR/SSG対応・本格的なWebアプリ開発</li>
                        <li><strong>React Router/Remix</strong>：フルスタック・Web標準重視</li>
                        <li><strong>Astro、Gatsby</strong>：静的サイト生成特化</li>
                    </ul>
                    <br><br>
                    <h3>ネイティブアプリ</h3>
                    <ul>
                        <li><strong>React Native</strong>：iOS・Androidアプリ開発</li>
                        <li><strong>Expo</strong>：React Nativeの開発環境</li>
                    </ul>
                    <div class="note">
                        本コースでは基本的なSPAから始めますが、実際のプロダクションでは上記のフレームワークを使用することが多い
                    </div>
                </section>

                <!-- React vs Others -->
                <section>
                    <h2>主要フレームワーク比較</h2>
                    <table class="comparison-table">
                        <thead>
                            <tr>
                                <th></th>
                                <th>React</th>
                                <th>Vue</th>
                                <th>Angular</th>
                                <th>Svelte</th>
                                <th>SolidJS</th>
                                <th>Preact</th>
                                <th>Lit</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="metric">学習コスト</td>
                                <td>中</td>
                                <td>中</td>
                                <td>高</td>
                                <td>中</td>
                                <td>中</td>
                                <td>低</td>
                                <td>中</td>
                            </tr>
                            <tr>
                                <td class="metric">エコシステム</td>
                                <td>最大</td>
                                <td>大</td>
                                <td>大</td>
                                <td>小</td>
                                <td>小</td>
                                <td>中</td>
                                <td>小</td>
                            </tr>
                            <tr>
                                <td class="metric">TypeScript</td>
                                <td>オプション</td>
                                <td>オプション</td>
                                <td>標準</td>
                                <td>標準</td>
                                <td>標準</td>
                                <td>オプション</td>
                                <td>標準</td>
                            </tr>
                            <tr>
                                <td class="metric">バンドルサイズ</td>
                                <td>42KB</td>
                                <td>36KB</td>
                                <td>130KB</td>
                                <td>10KB</td>
                                <td>7KB</td>
                                <td>3KB</td>
                                <td>5KB</td>
                            </tr>
                            <tr>
                                <td class="metric">パフォーマンス</td>
                                <td>良</td>
                                <td>良</td>
                                <td>良</td>
                                <td>優秀</td>
                                <td>優秀</td>
                                <td>良</td>
                                <td>良</td>
                            </tr>
                            <tr>
                                <td class="metric">求人数</td>
                                <td>最多</td>
                                <td>多</td>
                                <td>多</td>
                                <td>少</td>
                                <td>極少</td>
                                <td>少</td>
                                <td>少</td>
                            </tr>
                        </tbody>
                    </table>

                    <div class="note">
                        <strong>結論</strong>：Reactは学習コストとエコシステムのバランスが良く、転職市場でも最も有利
                    </div>
                </section>
            </section>

            <!-- Core Concepts -->
            <section>
                <h2>Reactの核となる概念</h2>
                <dl>
                    <dt><strong>コンポーネント</strong></dt>
                    <dd>UIを独立した再利用可能な部品として作成</dd>

                    <dt><strong>JSX</strong></dt>
                    <dd>JavaScriptの中にHTMLライクな構文を書ける</dd>

                    <dt><strong>State（状態）</strong></dt>
                    <dd>コンポーネントが持つ変更可能なデータ</dd>

                    <dt><strong>Props</strong></dt>
                    <dd>親コンポーネントから子へ渡すデータ</dd>

                    <dt><strong>仮想DOM</strong></dt>
                    <dd>メモリ上でDOM操作を計算し、効率的に更新</dd>
                </dl>
            </section>

            <section>
                <section>
                    <h1>Reactの核となる概念</h1>
                    <p>JSX、コンポーネント</p>
                </section>

                <!-- JSXとは -->
                <section>
                    <h2>JSX = JavaScript + XML</h2>
                    <p>普通のHTMLから始めよう</p>
                    <pre><code data-lang="html">&lt;div class="greeting"&gt;
  &lt;h1&gt;Hello, World!&lt;/h1&gt;
  &lt;p&gt;今日はいい天気ですね&lt;/p&gt;
&lt;/div&gt;</code></pre>
                    <div class="fragment">
                        <p>→ JSXならこれをJS関数の中に書ける</p>
                    </div>
                </section>

                <section>
                    <h2>JSXの実際</h2>
                    <pre><code data-lang="jsx">function Greeting() {
  return (
    &lt;div className="greeting"&gt;
      &lt;h1&gt;Hello, World!&lt;/h1&gt;
      &lt;p&gt;今日はいい天気ですね&lt;/p&gt;
    &lt;/div&gt;
  );
}</code></pre>
                    <div class="note">
                        <code>className</code>に注意！ <code>class</code>はJSの予約語だから
                    </div>
                </section>

                <!-- JSX in depth -->
                <section>
                    <h2>JSXの正体: ただの関数呼び出し</h2>
                    <p>JSXはこれにコンパイルされる：</p>
                    <pre><code data-lang="jsx">function Greeting() {
  return React.createElement(
    "div",
    { className: "greeting" },
    React.createElement("h1", null, "Hello, World!"),
    React.createElement("p", null, "今日はいい天気ですね")
  );
}</code></pre>
                    <div class="note">
                        つまり<strong>JSX = syntactic sugar</strong>
                    </div>
                </section>

                <!-- JavaScript in brackets -->
                <section>
                    <h2>JavaScriptを埋め込む: {}</h2>
                    <pre><code data-lang="jsx">function User({ name, email, isAdmin }) {
  const greeting = isAdmin ? 'Captain' : 'Squad Member';
  
  return (
    &lt;div className="user-card"&gt;
      &lt;h2&gt;{name}&lt;/h2&gt;
      &lt;p&gt;{email}&lt;/p&gt;
      &lt;span&gt;Role: {greeting}&lt;/span&gt;
      &lt;small&gt;登録日: {new Date().getFullYear()}年&lt;/small&gt;
    &lt;/div&gt;
  );
}</code></pre>
                    <div class="note"><code>{}</code>の中は普通のJavaScript式（ERBの<code>&lt;%= %&gt;</code>みたいなもの）</note>
                </section>

                <!-- JSX vs ERB -->
                <section>
                    <h2>配列をレンダリング</h2>
                    <div class="comparison">
                        <div>
                            <p>JSXだとこう:</p>
                            <pre><code data-lang="jsx">function TodoList({ todos }) {
  return (
    &lt;ul&gt;
      {todos.map(todo =&gt; (
        &lt;li key={todo.id}&gt;
          {todo.text}
        &lt;/li&gt;
      ))}
    &lt;/ul&gt;
  );
}</code></pre>
                        </div>
                        <div>
                            <p>ERBだとこう:</p>
                            <pre><code data-lang="erb">&lt;ul&gt;
  &lt;% @todos.each do |todo| %&gt;
    &lt;li&gt;&lt;%= todo.text %&gt;&lt;/li&gt;
  &lt;% end %&gt;
&lt;/ul&gt;</code></pre>
                        </div>
                    </div>
                    <div class="note">
                        <code>key</code>は必須！Reactが効率的に更新するため
                    </div>
                </section>

                <!-- Conditionals -->
                <section>
                    <h2>条件レンダリング: ERBっぽいけどJS</h2>
                    <pre><code data-lang="jsx" class="code-small">function UserProfile({ user, isLoggedIn }) {
  return (
    &lt;div&gt;
      {isLoggedIn ? ( // 三項演算子 - ERBの&lt;% if %&gt;っぽい 
        &lt;h1&gt;Welcome {user.name}!&lt;/h1&gt;
      ) : (
        &lt;h1&gt;Please log in&lt;/h1&gt;
      )}
      {user.isAdmin && ( // && で条件表示 - ERBの&lt;% if %&gt;(else無し)
        &lt;div className="admin-panel"&gt;Admin tools&lt;/div&gt;
      )}
    &lt;/div&gt;
  );
}</code></pre>
                </section>

                <!-- My JSX, my Rules -->
                <section>
                    <h2>JSXのルール（重要）</h2>
                    <ul>
                        <li class="fragment"><strong>必ず1つの要素を返す</strong>
                            <pre><code data-lang="jsx">// ❌ ダメ
return (
  &lt;h1&gt;Title&lt;/h1&gt;
  &lt;p&gt;Content&lt;/p&gt;
);

// ✅ OK - Fragment使用
return (
  &lt;&gt;
    &lt;h1&gt;Title&lt;/h1&gt;
    &lt;p&gt;Content&lt;/p&gt;
  &lt;/&gt;
);</code></pre>
                        </li>
                        <li class="fragment"><strong>すべてのタグを閉じる</strong>: <code>&lt;br /&gt;</code>,
                            <code>&lt;img /&gt;</code>
                        </li>
                        <li class="fragment"><strong>camelCase属性</strong>: <code>onClick</code>, <code>className</code>,
                            <code>htmlFor</code>
                        </li>
                    </ul>
                </section>

                <!-- Components -->
                <section>
                    <h2>コンポーネント = 関数</h2>
                    <pre><code data-lang="jsx">// これがコンポーネント
function Welcome({ name }) {
  return &lt;h1&gt;Hello, {name}!&lt;/h1&gt;;
}

// 使う時
function App() {
  return (
    &lt;div&gt;
      &lt;Welcome name="Mayuri Kurotsuchi" /&gt;
      &lt;Welcome name="Sosuke Aizen" /&gt;
    &lt;/div&gt;
  );
}</code></pre>
                    <div class="note">関数名は<strong>大文字で始める</strong>（HTMLタグと区別するため）</div>
                </section>

                <!-- Props -->
                <section>
                    <h2>Props = 関数の引数</h2>
                    <pre><code data-lang="jsx">// 普通の関数
function greet(name, age) {
  return `こんにちは、${name}さん（${age}歳）`;
}

// Reactコンポーネント
function Greeting({ name, age }) {  // 分割代入
  return &lt;p&gt;こんにちは、{name}さん（{age}歳）&lt;/p&gt;;
}

// 使用
&lt;Greeting name="Kurosaki Ichigo" age={15} /&gt;</code></pre>
                    <p class="note">propsは<strong>読み取り専用</strong></p>
                </section>

                <!-- Components Deep Dive - Add after existing component intro -->
                <section>
                    <h2>コンポーネントの解剖学</h2>
                    <pre><code data-lang="jsx" class="code-medium-small">// 1. 関数宣言（大文字で始める）
function UserCard({ name, email, isAdmin }) {
  // 2. ロジック（普通のJS）
  const roleText = isAdmin ? 'Admin' : 'User';
  
  // 3. JSXを返す（必須）
  return (
    &lt;div&gt;
      &lt;h3&gt;{name}&lt;/h3&gt;
      &lt;p&gt;{email}&lt;/p&gt;
      &lt;span&gt;{roleText}&lt;/span&gt;
    &lt;/div&gt;
  );
}</code></pre>

                    <pre><code data-lang="jsx" class="code-medium-small">// 4. 使用 = HTMLタグみたいに
&lt;UserCard name="コヨーテ　スターク" email="starrk@espada.es" isAdmin={true} /&gt;</code></pre>
                </section>

                <!-- Props Explained Better -->
                <section>
                    <h2>Props詳細: データの流れ</h2>
                    <div class="comparison">
                        <div>
                            <p>Railsのpartial:</p>
                            <pre><code data-lang="erb">&lt;%= render 'user_card', 
    user: @user, 
    show_admin: true %&gt;</code></pre>
                        </div>
                        <div>
                            <p>Reactのcomponent:</p>
                            <pre><code data-lang="jsx">&lt;UserCard 
  name={user.name}
  email={user.email} 
  isAdmin={true} /&gt;</code></pre>
                        </div>
                    </div>
                    <div class="note">props = partial variables みたいなもの</div>
                </section>

                <!-- Props Destructuring Explained -->
                <section>
                    <h2>Props受け取り方法</h2>
                    <pre><code data-lang="jsx">// 方法1: propsオブジェクトそのまま
function Greeting(props) {
  return &lt;h1&gt;Hello, {props.name}!&lt;/h1&gt;;
}

// 方法2: 分割代入（destructuring）- 推奨
function Greeting({ name, age }) {
  return &lt;h1&gt;Hello, {name}! You are {age}&lt;/h1&gt;;
}

// 方法3: 分割代入 + デフォルト値
function Greeting({ name = "Guest", age = 0 }) {
  return &lt;h1&gt;Hello, {name}! You are {age}&lt;/h1&gt;;
}</code></pre>
                    <div class="note">分割代入 = JSの機能、Reactじゃない</div>
                </section>

                <!-- Component Composition -->
                <section>
                    <h2>コンポーネント合成: 積み木みたいに</h2>
                    <pre><code data-lang="jsx">// 小さいコンポーネント
function Avatar({ src, alt }) {
  return &lt;img src={src} alt={alt} className="avatar" /&gt;;
}

function UserName({ name, isOnline }) {
  return (
    &lt;span className={`username ${isOnline ? 'online' : 'offline'}`}&gt;
      {name}
    &lt;/span&gt;
  );
}</code></pre>

                    <pre><code data-lang="jsx">// 合成して大きいコンポーネント
function UserProfile({ user }) {
  return (
    &lt;div className="user-profile"&gt;
      &lt;Avatar src={user.avatar} alt={user.name} /&gt;
      &lt;UserName name={user.name} isOnline={user.isOnline} /&gt;
    &lt;/div&gt;
  );
}</code></pre>
                </section>

                <!-- Children Prop -->
                <section>
                    <h2>children prop: タグの中身</h2>
                    <pre><code data-lang="jsx">// Cardコンポーネント
function Card({ title, children }) {
  return (
    &lt;div className="card"&gt;
      &lt;h2&gt;{title}&lt;/h2&gt;
      &lt;div className="card-content"&gt;
        {children}  {/* ここに中身が入る */}
      &lt;/div&gt;
    &lt;/div&gt;
  );
}</code></pre>

                    <pre><code data-lang="jsx">// 使用方法
&lt;Card title="Profile"&gt;
  &lt;p&gt;This goes into children&lt;/p&gt;
  &lt;button&gt;Edit Profile&lt;/button&gt;
&lt;/Card&gt;</code></pre>
                    <div class="note">children = タグで囲んだ中身すべて</div>
                </section>

                <!-- Component Best Practices -->
                <section>
                    <h2>コンポーネントのベストプラクティス</h2>
                    <ul>
                        <li><strong>1つの責任</strong>: 1コンポーネント = 1つの仕事</li>
                        <li><strong>純粋関数</strong>: 同じprops → 同じ結果</li>
                        <li><strong>再利用可能</strong>: 複数の場所で使える設計</li>
                        <li><strong>分かりやすい名前</strong>: 何をするか名前で分かる</li>
                    </ul>
                </section>

                <!-- Event listeners -->
                <section>
                    <h2>イベントハンドラー</h2>
                    <pre><code data-lang="jsx">function Button() {
  const handleClick = () => {
    alert('クリックされた！');
  };

  return (
    &lt;button onClick={handleClick}&gt;
      クリックして
    &lt;/button&gt;
  );
}</code></pre>
                    <div class="note"><code>onClick</code> = 関数を渡すだけ</div>
                </section>

                <!-- Forms -->
                <section>
                    <h2>フォーム入力</h2>
                    <pre><code data-lang="jsx">function LoginForm() {
  const handleSubmit = (event) => {
    event.preventDefault(); // フォーム送信を停止
    console.log('ログイン処理');
  };

  return (
    &lt;form onSubmit={handleSubmit}&gt;
      &lt;input type="email" placeholder="Email" /&gt;
      &lt;input type="password" placeholder="Password" /&gt;
      &lt;button type="submit"&gt;Login&lt;/button&gt;
    &lt;/form&gt;
  );
}</code></pre>
                    <div class="note">Railsフォームヘルパーの代わりに普通のHTML</div>
                </section>

                <section>
                    <h2>まとめ</h2>
                    <ul>
                        <li class="fragment">HTMLライクな構文をJSに書ける</li>
                        <li class="fragment">{}でJavaScript式を埋め込める</li>
                        <li class="fragment">実際は<code>React.createElement()</code>の糖衣構文</li>
                        <li class="fragment">コンポーネント = JSXを返す関数</li>
                        <li class="fragment">イベントハンドラー = 関数を渡すだけ</li>
                    </ul>
                </section>
            </section>

            <section>
                <section>
                    <h4>理解度チェック①</h4>
                    <div class="quiz">
                        <h3>どちらがエラーになる？</h3>
                        <pre><code data-lang="typescript">let mysteryA: any = "梨花";
let mysteryB: unknown = "梨花";

mysteryA.toUpperCase(); // A
mysteryB.toUpperCase(); // B</code></pre>
                        <div class="quiz-options">
                            <div class="quiz-option">A) mysteryA.toUpperCase()</div>
                            <div class="quiz-option fragment custom correct-answer" data-fragment-index="1">B)
                                mysteryB.toUpperCase()</div>
                            <div class="quiz-option">C) 両方エラー</div>
                            <div class="quiz-option">D) 両方エラーなし</div>
                        </div>
                    </div>
                    <div class="fragment" data-fragment-index="1">
                        <div class="note">
                            <strong>答え:</strong> B) <code>unknown</code>は型ガードが必要。<code>any</code>は何でもOK（危険）
                        </div>
                    </div>
                </section>
            </section>

            <section>
                <!-- Practice -->
                <section>
                    <h1>TypeScript 実践演習</h1>
                    <h3>3つの課題 (各5-10分)</h3>
                    <p>今日学んだ内容を実際に使ってみよう！</p>
                    <div class="note"><a
                            href="https://github.com/cdefined/front-kaizen/tree/master/typescript-lessons/lesson_1/task.md">typescript-lessons/lesson_1/task.md</a>
                    </div>
                </section>

                <!-- Task 1 -->
                <section>
                    <div class="timer"></div>

                    <h2><span class="task-number">課題1</span> Union型とtype guard</h2>

                    <p><strong>関数 <code>processId</code> を作成してください</strong></p>
                    <ul>
                        <li>引数 <code>id</code> は <code>number</code> または <code>string</code> のいずれかです</li>
                        <li><code>number</code> の場合は <code>"ID: 123"</code>、<code>string</code> の場合は
                            <code>"CODE: ABC"</code> の形式で返す
                        </li>
                    </ul>

                    <pre><code data-lang="typescript">// テスト
console.log(processId(123));    // "ID: 123"
console.log(processId("ABC"));  // "CODE: ABC"
                </code></pre>
                    <div class="note"><a
                            href="https://github.com/cdefined/front-kaizen/tree/master/typescript-lessons/lesson_1/task.md">typescript-lessons/lesson_1/task.md</a>
                    </div>
                </section>

                <!-- Task 1 Solution -->
                <section>
                    <h2><span class="task-number">課題1</span> 解答例</h2>
                    <p>型ガード　【type guard】を使うことができます</p>
                    <pre><code data-lang="typescript">function processId(id: number | string): string {
    // typeof演算子を使って型を判定
    if (typeof id === "number") {
        return `ID: ${id}`;
    } else {
        return `CODE: ${id}`;
    }
}</code></pre>
                </section>
            </section>

            <section>
                <!-- Summary -->
                <section>
                    <h1>第3回まとめ</h1>

                    <h2>今日学んだこと</h2>
                    <ul>
                        <li><strong>TypeScript の基本:</strong> tsc コンパイラーと型システム</li>
                    </ul>
                </section>

                <!-- Homework -->
                <section>
                    <h1>宿題・実践課題</h1>

                    <h3>斬魄刀コレクション管理システム</h3>
                    <div class="note"><a
                            href="https://github.com/cdefined/front-kaizen/tree/master/typescript-lessons/lesson_1/homework"
                            target="_blank">typescript-lessons/lesson_1/homework</a></div>
                    <br>
                    <h3>実践での重要ポイント</h3>
                    <ul>
                        <li>型推論を信頼しつつ、関数の戻り値は明示的に書く</li>
                    </ul>
                </section>

                <!-- In next episode -->
                <section>
                    <h1>次回予告</h1>
                    <p><strong>React②:</strong> useState、イベント処理、フォーム</p>
                </section>
            </section>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/reveal.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/plugin/notes/notes.min.js"></script>
    <script src="../../scripts/reveal-timer-plugin.js"></script>
    <script type="module">
        import { codeToHtml } from 'https://esm.sh/shiki@3.0.0';

        const codeBlocks = document.querySelectorAll('pre code[data-lang]');

        for (const block of codeBlocks) {
            const lang = block.dataset.lang;
            const theme = block.dataset.theme || 'night-owl'; // 'material-theme-darker'
            const rawCode = block.textContent.trim();

            const html = await codeToHtml(rawCode, { lang, theme });

            const wrapper = document.createElement('div');
            wrapper.innerHTML = html;
            const shikiHTML = wrapper.firstElementChild;

            const pre = block.closest('pre');
            if (pre && shikiHTML) pre.replaceWith(shikiHTML);
        }
    </script>

    <script>
        Reveal.initialize({
            hash: true,
            slideNumber: true,
            width: 1800,
            height: 900,
            margin: 0.1,
            transition: 'slide',
            transitionSpeed: 'fast',
            backgroundTransition: 'fade',
            plugins: [RevealNotes, RevealTimer],
            highlight: {
                escapeHTML: true
            }
        });
    </script>
</body>

</html>