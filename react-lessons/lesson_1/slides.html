<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta lang="ja">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>React基礎①</title>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/reveal.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/theme/black.min.css">
    <style>
        .reveal {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        .reveal h1,
        .reveal h2,
        .reveal h3,
        .reveal h4 {
            color: #667eea;
            text-transform: none;
        }

        .reveal .pale {
            opacity: 0.9;
            font-size: 1em;
        }

        .reveal .slides section {
            text-align: left;
        }

        .reveal .title-slide {
            text-align: center;
        }

        .reveal .code-wrapper code {
            font-size: 1.3em;
        }

        .reveal .code-wrapper .code-medium {
            font-size: 1.19em;
        }

        .reveal .code-wrapper .code-medium-small {
            font-size: 1.1em;
        }

        .reveal .code-wrapper .code-small,
        .code-small {
            font-size: 0.9em;
        }

        .code-small .code-wrapper {
            width: 100%;
        }

        .reveal .comparison .hljs {
            max-height: 350px;
            min-height: unset;
            height: 100%;
        }

        ul>li,
        dl>dd {
            line-height: 2em;
        }

        .lifecycle {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 40px 0;
            padding: 20px;
            border-radius: 10px;
        }

        .lifecycle div {
            background: rgba(255, 255, 255, 0.1);
            flex: 1;
            text-align: center;
            padding: 10px;
            border-radius: 10px;
        }

        .arrow {
            background: none;
            font-size: 100px;
            color: #667eea;
            flex: 0;
        }

        .down-arrow {
            opacity: 0.7;
            display: flex;
            justify-content: center;
            font-size: 50px;
            flex: 0;
        }

        .comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }

        .triptych {
            display: flex;
            justify-content: space-between;
            align-items: start;
            gap: 20px;
        }

        .triptych-transformation {
            display: flex;
            justify-content: start;
            align-items: center;
            gap: 20px;
        }

        .js-side,
        .ts-side {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 8px;
        }

        .js-side h4 {
            color: #f39c12;
        }

        .ts-side h4 {
            color: #3498db;
        }

        .note {
            background: rgba(52, 152, 219, 0.2);
            border-left: 4px solid #3498db;
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .warning {
            background: rgba(231, 76, 60, 0.2);
            border-left: 4px solid #e74c3c;
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .quiz {
            background: rgba(46, 204, 113, 0.1);
            border-left: 4px solid #2ecc71;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
        }

        .quiz-options {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr 1fr;
            gap: 10px;
        }

        .quiz-option {
            display: block;
            margin: 8px 0;
            padding: 8px 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .quiz-option:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .quiz-options.small {
            font-size: 0.65em;
        }

        .fragment.correct-answer.visible {
            border-left: 4px solid #2ecc71;
            background: rgba(46, 204, 113, 0.3);
        }

        .reveal pre {
            width: 100%;
        }

        .reveal pre code {
            padding: 1em;
        }

        .timer {
            position: absolute;
            top: -30px;
            right: 15px;
        }

        .comparison-table {
            font-size: 0.75em;
            border-collapse: collapse;
            width: 100%;
            margin: 1rem 0;
        }

        .comparison-table th,
        .comparison-table td {
            padding: 0.6rem 0.4rem;
            text-align: center;
        }

        .comparison-table thead th {
            font-weight: bold;
        }

        .comparison-table .metric {
            font-weight: bold;
            text-align: left;
        }
    </style>
</head>

<body>
    <div class="reveal">
        <div class="slides">
            <section class="title-slide">
                <h1>React基礎①</h1>
                <h2>Reactとは、JSX、コンポーネント、Propsの使い方</h2>
                <aside class="notes"></aside>
            </section>

            <!-- React とは -->
            <section>
                <!-- What is React -->
                <section>
                    <h1>Reactとは？</h1>
                    <p class="intro-text"><strong>ユーザインターフェース構築のためのJavaScriptライブラリ</strong></p>

                    <ul>
                        <li>Meta（旧Facebook）が2013年にオープンソース化</li>
                        <li>コンポーネントベースのアーキテクチャ</li>
                        <li>仮想DOMによる効率的な更新</li>
                        <li>宣言的なプログラミングモデル</li>
                    </ul>

                    <div class="note">
                        「何を表示するか」を記述すれば、「どうやって更新するか」はReactが処理する
                    </div>
                    <aside class="notes">
                        React（リアクト）はUI（ユーアイ）を構築（こうちく）するためのライブラリです。コンポーネントベースで、状態管理（じょうたいかんり）が簡単（かんたん）になります。
                    </aside>
                </section>

                <!-- Why React was needed -->
                <section>
                    <h2>従来のDOM操作の問題点</h2>

                    <h3>手動DOM操作の課題</h3>
                    <ul>
                        <li>状態とUIの同期を手動で管理する必要</li>
                        <li>DOMの直接操作はバグの温床</li>
                        <li>アプリが大きくなると管理が困難</li>
                        <li>コードが複雑になりがち</li>
                    </ul>
                    <aside class="notes">
                        昔(むかし)のやり方(やりかた)は大変(たいへん)でした。コードがたくさん必要(ひつよう)です
                    </aside>
                </section>

                <!-- DOM -->
                <section>
                    <h2>DOM【Document Object Model】とは？</h2>
                    <p>ブラウザがHTMLを解釈して作る、JavaScriptで操作可能なオブジェクト</p>
                    <div class="comparison">
                        <img src="./images/dom.svg" height="620" alt="DOM" />
                        <div class="example">
                            <h4>JavaScript（Reactなし）</h4>
                            <pre><code data-lang="js">// 要素の取得と内容変更
document.getElementById('count').textContent = '1';

// CSSクラスの追加
document.querySelector('div').classList.add('highlighted');

// 新しい要素の作成と追加
const newButton = document.createElement('button');
newButton.textContent = 'クリック';
document.body.appendChild(newButton);

// イベントリスナーの追加
newButton.addEventListener('click', handleClick);</code></pre>
                        </div>
                    </div>
                    <div class="note">
                        問題：アプリが大きくなると手動更新が地獄になる
                    </div>
                    <aside class="notes">
                        でも、そもそもDOMって何でしょうか？<br>
                        Reactを理解するために、まずDOMについて知っておきましょう。<br>
                        domはhtmlをjavascriptで変更(へんこう)できるオブジェクトです。でも複雑(ふくざつ)になりがちです
                    </aside>
                </section>

                <!-- DOM vs React Comparison -->
                <section>
                    <h2>コード比較：DOM操作 vs React</h2>
                    <div class="comparison">
                        <div class="comparison-item">
                            <h4>従来のDOM操作</h4>
                            <pre><code data-lang="javascript">const button = document.getElementById('btn');
const counter = document.getElementById('count');
let count = 0;

button.addEventListener('click', () => {
  count++;
  counter.textContent = count;
  
  // 他の要素も手動で更新
  updateHeader(count);
  updateFooter(count);
});</code></pre>
                        </div>
                        <div class="comparison-item">
                            <h4>React</h4>
                            <pre><code data-lang="jsx">&lt;div&gt;
  &lt;h1&gt;カウンター&lt;/h1&gt;
  &lt;span&gt;{count}&lt;/span&gt;
  &lt;button onClick={handleClick}&gt;
    +1
  &lt;/button&gt;
&lt;/div&gt;</code></pre>
                        </div>
                    </div>

                    <div class="note">
                        Reactなら「何を表示するか」だけ書けばOK
                    </div>
                    <aside class="notes">
                        これがReactの力です。<br>
                        Reactなら、状態(じょうたい)を変更(へんこう)するだけで、UIが自動的(じどうてき)に更新(こうしん)されます。<br>
                        つまり、手動(しゅどう)でDOMを操作(そうさ)する必要(ひつよう)がなくなります。<br><br>

                        react の方(ほう)が短(みじか)くて分(わ)かりやすいです。状態(じょうたい)が変(か)わると自動(じどう)で更新(こうしん)されます
                </section>

                <!-- React's Approach -->
                <section>
                    <h2>Reactのアプローチ</h2>

                    <h3>宣言的UI</h3>
                    <p>「状態が変わったら全体を再描画」という発想の転換</p>

                    <ul>
                        <li><strong>状態管理の単純化</strong>：状態を変更するだけでUIが自動更新</li>
                        <li><strong>仮想DOM</strong>：メモリ上で差分を計算し、必要な部分だけ更新</li>
                        <li><strong>コンポーネント思考</strong>：UIを再利用可能な部品として構築</li>
                    </ul>

                    <div class="note">
                        従来の「どうやって更新するか」から「何を表示するか」への思考転換
                    </div>
                    <aside class="notes">
                        Reactは宣言的(せんげんてき)なUIを提供(ていきょう)します。<br>
                        状態(じょうたい)が変(か)わると、Reactが自動的(じどうてき)にUIを更新(こうしん)します。<br>
                        「どうやって」じゃなくて「何(なに)を」表示(ひょうじ)するかだけ考(かんが)えます
                </section>

                <!-- Virtual DOM Introduction -->
                <section>
                    <h2>仮想DOM【Virtual DOM】とは？</h2>
                    <p class="intro-text"><strong>メモリ上にDOMの軽量コピーを保持する仕組み</strong></p>

                    <ul>
                        <li>実際のDOMより高速に操作可能</li>
                        <li>変更前後を比較して差分を検出</li>
                        <li>最小限の実DOM更新のみ実行</li>
                    </ul>

                    <div class="note">
                        「全体を再描画」と言いつつ、実際は必要な部分だけ更新
                    </div>
                    <aside class="notes">
                        でも「全体（ぜんたい）を再描画（さいびょうが）」って遅（おそ）そうですよね？<br>
                        実際（じっさい）はどうやって高速化（こうそくか）しているのでしょうか？<br>
                        答えは「仮想（かそう）DOM」という仕組みにあります。<br>
                        仮想（かそう）DOMは、実際（じっさい）のDOMの軽量（けいりょう）コピーをメモリ上（じょう）に保持（ほじ）します。
                    </aside>
                </section>

                <!-- Virtual DOM Process -->
                <section>
                    <h2>仮想DOMの動作プロセス</h2>

                    <div class="fragment comparison">
                        <img src="./images/virtual-dom.svg" height="700" alt="Virtual DOM Process" />

                        <div class="process-steps">
                            <div class="fragment">
                                <h4>1. 状態変更</h4>
                                <p>状態またはpropsの変更</p>
                            </div>

                            <div class="fragment">
                                <h4>2. 新しい仮想DOMツリー作成</h4>
                                <p>新しい状態に基づいてメモリ上に仮想DOMを構築</p>
                            </div>

                            <div class="fragment">
                                <h4>3. 差分検出【Diffing】</h4>
                                <p>前回の仮想DOMと今回の仮想DOMを比較</p>
                            </div>

                            <div class="fragment">
                                <h4>4. 最小限更新【Reconciliation】</h4>
                                <p>変更された部分のみ実DOMに反映</p>
                            </div>
                        </div>
                    </div>
                    <aside class="notes">
                        仮想（かそう）DOMは、メモリ上（じょう）で変更（へんこう）を計算（けいさん）し、必要（ひつよう）な部分（ぶぶん）だけを更新（こうしん）します。
                    </aside>
                </section>

                <!-- Why Virtual DOM is Fast -->
                <section>
                    <h2>なぜ仮想DOMは高速なのか？</h2>

                    <div class="comparison">
                        <div class="comparison-item">
                            <h4>実DOM操作</h4>
                            <ul>
                                <li>ブラウザのレンダリングエンジンが重い</li>
                                <li>レイアウト計算が発生</li>
                                <li>再描画処理が必要</li>
                                <li>1つの変更でも全体に影響</li>
                            </ul>
                        </div>

                        <div class="comparison-item">
                            <h4>仮想DOM</h4>
                            <ul>
                                <li>JavaScriptオブジェクトなので軽量</li>
                                <li>メモリ上での比較計算</li>
                                <li>バッチ処理で最適化</li>
                                <li>変更部分のみ実DOM更新</li>
                            </ul>
                        </div>
                    </div>
                    <aside class="notes">
                        仮想DOMの仕組みは分かりましたが、なぜこれが速いのでしょうか？<br>
                        javascript オブジェクトは軽(かる)いです。必要(ひつよう)な部分(ぶぶん)だけ更新(こうしん)します
                    </aside>
                </section>

                <!-- Virtual DOM Example -->
                <section>
                    <h2>仮想DOM　具体例</h2>

                    <div class="example">
                        <h4>JSX</h4>
                        <pre><code data-lang="jsx">&lt;div&gt;
  &lt;h1&gt;カウント: {count}&lt;/h1&gt;
  &lt;button&gt;+1&lt;/button&gt;
&lt;/div&gt;</code></pre>

                        <h4>仮想DOM（概念）</h4>
                        <pre><code data-lang="javascript">{
  type: 'div',
  children: [
    {
      type: 'h1',
      children: `カウント: ${count}`
    },
    {
      type: 'button',
      children: '+1'
    }
  ]
}</code></pre>
                    </div>

                    <div class="note">
                        countが0→1に変わった時、h1のテキスト部分のみ実DOM更新
                    </div>
                    <aside class="notes">
                        たとえば、カウントが0から1に変（か）わった時（とき）、仮想（かそう）DOMはh1のテキストだけを更新（こうしん）します。<br>
                        そのため、実際（じっさい）のDOM操作（そうさ）が少（すく）なくなり、パフォーマンスが上（あ）がります。
                    </aside>
                </section>

                <section>
                    <h2>なぜReactを学ぶのか？</h2>
                    <ul>
                        <li>手動DOM操作の複雑さを解決</li>
                        <li>状態とUIの同期を自動化</li>
                        <li>再利用可能なコンポーネント設計</li>
                        <li>現代的なWeb開発の標準</li>
                    </ul>
                    <aside class="notes">
                        React（リアクト）は、Web（ウェブ）をかんたんに作るための人気（にんき）ツールです。<br>
                        現代（げんだい）のWeb開発（かいはつ）で必要（ひつよう）なスキルです。
                </section>
            </section>

            <!-- Section 1: JSX Basics -->
            <section>
                <section>
                    <h1>JSX = JavaScript + HTML風の文法</h1>
                    <p>普通のHTMLから始めよう</p>
                    <aside class="notes">
                        ReactではJSXという特別な文法を使います<br>
                        jsxはhtmlみたいな文法(ぶんぽう)をjavascriptで使(つか)えます
                    </aside>
                </section>

                <section>
                    <h2>HTMLをそのまま書ける</h2>
                    <pre><code data-lang="html">&lt;div class="greeting"&gt;
  &lt;h1&gt;Hello, World!&lt;/h1&gt;
  &lt;p&gt;今日はいい天気ですね&lt;/p&gt;
&lt;/div&gt;</code></pre>
                    <div class="fragment">
                        <p>→ JSXならこれをJS関数の中に書ける</p>
                    </div>
                    <aside class="notes">
                        普通(ふつう)のhtmlがほとんどそのまま使(つか)えます
                </section>

                <section>
                    <h2>JSXの実際</h2>
                    <pre><code data-lang="jsx">function Greeting() {
  return (
    &lt;div className="greeting"&gt;
      &lt;h1&gt;Hello, World!&lt;/h1&gt;
      &lt;p&gt;今日はいい天気ですね&lt;/p&gt;
    &lt;/div&gt;
  );
}</code></pre>
                    <div class="note">
                        <code>className</code>に注意！ <code>class</code>はJSの予約語だから
                    </div>
                    <aside class="notes">
                        関数(かんすう)の中(なか)でhtmlを書(か)けます。でもclassNameに注意(ちゅうい)してください
                    </aside>
                </section>

                <section>
                    <h2>JSXの正体</h2>
                    <p>JSXはこれにコンパイルされる：</p>
                    <pre><code data-lang="jsx">// JSX
&lt;div className="greeting"&gt;Hello!&lt;/div&gt;

// ↓ コンパイル後
React.createElement(
  "div",
  { className: "greeting" },
  "Hello!"
);</code></pre>
                    <div class="note">つまり<strong>JSX = syntactic sugar</strong></div>
                    <aside class="notes">
                        jsxは実際(じっさい)にはreact.createelementに変換(へんかん)されます
                    </aside>
                </section>

                <section>
                    <h2>JSXのルール</h2>

                    <div class="triptych">
                        <div class="fragment">
                            <h4>1. 必ず1つの要素を返す</h4>
                            <pre><code data-lang="jsx">// ❌ ダメ
return (
  &lt;h1&gt;Title&lt;/h1&gt;
  &lt;p&gt;Content&lt;/p&gt;
);

// ✅ OK - Fragment使用
return (
  &lt;&gt;
    &lt;h1&gt;Title&lt;/h1&gt;
    &lt;p&gt;Content&lt;/p&gt;
  &lt;/&gt;
);</code></pre>
                        </div>
                        <div class="fragment">
                            <h4>2. すべてのタグを閉じる</h4>
                            <pre><code data-lang="jsx">// ❌ HTML風だとダメ
&lt;br&gt;
&lt;img src="photo.jpg"&gt;
&lt;input type="text"&gt;

// ✅ 必ず閉じる
&lt;br /&gt;
&lt;img src="photo.jpg" /&gt;
&lt;input type="text" /&gt;</code></pre>
                        </div>
                        <div class="fragment">
                            <h4>3. camelCase属性</h4>
                            <pre><code data-lang="jsx">// ❌ HTML属性名
&lt;div class="container" onclick="handleClick()"&gt;
&lt;label for="email"&gt;

// ✅ camelCase
&lt;div className="container" onClick={handleClick}&gt;
&lt;label htmlFor="email"&gt;</code></pre>
                            <div class="note">
                                <code>class</code> → <code>className</code><br>
                                <code>for</code> → <code>htmlFor</code><br>
                                <code>onclick</code> → <code>onClick</code>
                            </div>
                        </div>
                    </div>

                    <aside class="notes">
                        jsxには大切(たいせつ)なルールがあります。<br>
                        必(かなら)ず一(ひと)つの要素(ようそ)を返(かえ)してください<br>
                        htmlと違(ちが)って、すべてのタグを閉(と)じる必要(ひつよう)があります<br>
                        属性名(ぞくせいめい)はcamelcaseで書(か)きます。classNameやonClickなど
                    </aside>
                </section>

                <section>
                    <h4>理解度チェック①【JSXルール】</h4>
                    <div class="quiz">
                        <h3>どれが正しいJSX？</h3>
                        <div class="comparison">
                            <pre><code data-lang="jsx">{ /* A */ }
return (
    &lt;div&gt;
        &lt;h1&gt;Title&lt;/h1&gt;
        &lt;p&gt;Text&lt;/p&gt;
    &lt;/div&gt;
);

{ /* B */ }
return (
    &lt;h1&gt;Title&lt;/h1&gt;
    &lt;p&gt;Text&lt;/p&gt;
);</code></pre>
                            <pre><code data-lang="jsx">{ /* C */ }
return (
    &lt;&gt;
        &lt;h1&gt;Title&lt;/h1&gt;
        &lt;p&gt;Text&lt;/p&gt;
    &lt;/&gt;
);</code></pre>
                        </div>
                        <div class="quiz-options small">
                            <div class="quiz-option">A)
                                <code>&lt;div&gt;&lt;h1&gt;Title&lt;/h1&gt;&lt;p&gt;Text&lt;/p&gt;&lt;/div&gt;</code>
                            </div>
                            <div class="quiz-option">B)
                                <code>&lt;h1&gt;Title&lt;/h1&gt;&lt;p&gt;Text&lt;/p&gt;</code>
                            </div>
                            <div class="quiz-option">C)
                                <code>&lt;&gt;&lt;h1&gt;Title&lt;/h1&gt;&lt;p&gt;Text&lt;/p&gt;&lt;/&gt;</code>
                            </div>
                            <div class="quiz-option fragment custom correct-answer" data-fragment-index="1">D) AとC両方
                            </div>
                        </div>
                    </div>
                    <div class="fragment" data-fragment-index="1">
                        <div class="note">
                            <strong>答え:</strong> D) 単一の親要素またはFragment必須
                        </div>
                    </div>
                    <aside class="notes">
                        どれが正しいjsxでしょうか？<br>
                        AとCは正しいです。Bはダメです。<br>
                        jsxでは必ず一つの親要素が必要(ひつよう)です。<br>
                        それがないと、jsxはエラーになります
                </section>
            </section>

            <!-- Section 2: JavaScript in JSX -->
            <section>
                <section>
                    <h1>JSXにJavaScriptを埋め込む</h1>
                    <p>{}で動的コンテンツ</p>
                    <aside class="notes">
                        jsxの中(なか)でjavascriptを使(つか)うには{}(なみかっこ)を使(つか)います
                    </aside>
                </section>

                <section>
                    <h2>変数を表示: {}</h2>
                    <pre><code data-lang="jsx">function User({ name, email }) {
  const greeting = 'こんにちは';
  
  return (
    &lt;div&gt;
      &lt;h2&gt;{greeting}, {name}さん&lt;/h2&gt;
      &lt;p&gt;{email}&lt;/p&gt;
      &lt;p&gt;今年は{new Date().getFullYear()}年です。&lt;/p&gt;
    &lt;/div&gt;
  );
}</code></pre>
                    <div class="note"><code>{}</code>の中は普通のJavaScript式</div>
                    <aside class="notes">
                        変数(へんすう)や式(しき)を{}（なみかっこ）で囲(かこ)むと表示(ひょうじ)できます
                    </aside>
                </section>

                <section>
                    <h2>条件レンダリング: && 演算子</h2>
                    <pre><code data-lang="jsx">function UserProfile({ user }) {
  return (
    &lt;div&gt;
      &lt;h1&gt;Welcome {user.name}!&lt;/h1&gt;
      {user.isAdmin && (
        &lt;div className="admin-panel"&gt;  {/* trueの時だけ表示 */}
          Admin tools
        &lt;/div&gt;
      )}
      {user.notifications.length > 0 && &lt;span&gt;You have {user.notifications.length} messages&lt;/span&gt;}
    &lt;/div&gt;
  );
}</code></pre>
                    <div class="note">
                        <code>condition && JSX</code><br>
                        falseの時は何も表示しない（elseが不要な時）
                    </div>
                    <aside class="notes">
                        条件(じょうけん)がtrueの時(とき)だけ表示(ひょうじ)したい場合(ばあい)は&&が便利(べんり)です
                    </aside>
                </section>

                <section>
                    <h2>条件レンダリング: 三項演算子</h2>
                    <pre><code data-lang="jsx">function UserProfile({ user, isLoggedIn }) {
  return (
    &lt;div&gt;
      {isLoggedIn ? (
        &lt;h1&gt;Welcome {user.name}!&lt;/h1&gt;  {/* trueの場合 */}
      ) : (
        &lt;h1&gt;Please log in&lt;/h1&gt;         {/* falseの場合 */}
      )}
    &lt;/div&gt;
  );
}</code></pre>
                    <div class="note">
                        <code>condition ? trueの時 : falseの時</code><br>
                        必ず両方の場合を書く必要がある
                    </div>
                    <aside class="notes">
                        条件(じょうけん)によって違(ちが)うものを表示(ひょうじ)したい時(とき)は 三項演算子(さんこうえんざんし)を使(つか)います
                    </aside>
                </section>

                <section>
                    <h2>ERBとの比較</h2>
                    <div class="comparison">
                        <div>
                            <p>JSX:</p>
                            <pre><code data-lang="jsx">{user.loggedIn ? (
  &lt;h1&gt;Welcome {user.name}!&lt;/h1&gt;
) : (
  &lt;h1&gt;Please log in&lt;/h1&gt;
)}

{user.isAdmin && (
  &lt;div className="admin-panel"&gt;
    Admin tools
  &lt;/div&gt;
)}</code></pre>
                        </div>
                        <div>
                            <p>ERB:</p>
                            <pre><code data-lang="erb">&lt;% if user.logged_in? %&gt;
  &lt;h1&gt;Welcome &lt;%= user.name %&gt;!&lt;/h1&gt;
&lt;% else %&gt;
  &lt;h1&gt;Please log in&lt;/h1&gt;
&lt;% end %&gt;

&lt;% if user.admin? %&gt;
  &lt;div class="admin-panel"&gt;
    Admin tools
  &lt;/div&gt;
&lt;% end %&gt;</code></pre>
                        </div>
                    </div>
                    <div class="note">JSXは式だからreturnの中に直接書ける</div>
                    <aside class="notes">
                        JSXとERBをくらべてみましょう
                    </aside>
                </section>

                <section>
                    <h2>配列をレンダリング</h2>
                    <pre><code data-lang="jsx">function TodoList({ todos }) {
  return (
    &lt;ul&gt;
      {todos.map(todo =&gt; (
        &lt;li key={todo.id}&gt;
          {todo.text}
        &lt;/li&gt;
      ))}
    &lt;/ul&gt;
  );
}</code></pre>
                    <div class="triptych-transformation">
                        <div>
                            <h4>JSX</h4>
                            <pre><code data-lang="jsx">&lt;TodoList todos={[
        { id: 1, text: "起きます" },
        { id: 2, text: "コーヒーを飲みます" },
    ]} /&gt;</code></pre>
                        </div>
                        <div class="arrow">→</div>
                        <div>
                            <h4>出力されるHTML</h4>
                            <pre>
                            <code data-lang="html">&lt;ul&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;li&gt;起きます&lt;/li&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;li&gt;コーヒーを飲みます&lt;/li&gt;
&lt;/ul&gt;</code>
                        </pre>
                        </div>
                    </div>
                    <div class="note">
                        <code>key</code>は必須！Reactが効率的に更新するため
                    </div>
                    <aside class="notes">
                        配列(はいれつ)の内容(ないよう)を表示(ひょうじ)するにはmapを使(つか)います。keyが必要(ひつよう)です
                    </aside>
                </section>
                <section>
                    <h2>key属性の重要性</h2>
                    <p>リストをレンダリングする時の必須属性</p>

                    <div class="comparison">
                        <div class="comparison-item">
                            <h4>❌ keyなし</h4>
                            <pre><code data-lang="jsx">{/* keyがないとリストの順序が変わった時に状態がズレる */}
{todos.map(todo =&gt; (
  &lt;li&gt;{todo.text}&lt;/li&gt;  
))}</code></pre>
                        </div>
                        <div class="comparison-item">
                            <h4>✅ keyあり</h4>
                            <pre><code data-lang="jsx">{todos.map(todo =&gt; (
  &lt;li key={todo.id}&gt;{todo.text}&lt;/li&gt;
))}</code></pre>
                        </div>
                    </div>

                    <div class="note">
                        <strong>良いkey:</strong> item.id, user.uuid など一意で不変<br>
                        <strong>悪いkey:</strong> index, Math.random() など
                    </div>
                    <aside class="notes">
                        リストにはkey属性(ぞくせい)が必要(ひつよう)です。一意(いちい)で変(か)わらない値(あたい)を使(つか)ってください
                    </aside>
                </section>

                <section>
                    <h4>理解度チェック②【条件レンダリング】</h4>
                    <div class="quiz">
                        <h3>何が表示される？</h3>
                        <pre><code data-lang="jsx">function AdminPanel() {
    const user = { name: "Ichigo", isAdmin: false };

    return &lt;&gt;{user.isAdmin && &lt;div&gt;Admin Panel&lt;/div&gt;}&lt;/&gt;;
}
</code></pre>
                        <div class="quiz-options">
                            <div class="quiz-option">A) <code>&lt;div&gt;Admin Panel&lt;/div&gt;</code></div>
                            <div class="quiz-option fragment custom correct-answer" data-fragment-index="1">B) 何も表示されない
                            </div>
                            <div class="quiz-option">C) <code>false</code></div>
                            <div class="quiz-option">D) エラー</div>
                        </div>
                    </div>
                    <div class="fragment" data-fragment-index="1">
                        <div class="note">
                            <strong>答え:</strong> B) &&の左側がfalseなので右側は評価されない
                        </div>
                    </div>
                    <aside class="notes">
                        条件(じょうけん)レンダリングの理解度(りかいど)をチェックします。<br>
                        user.isAdminがfalseなので、&&の右側は評価(ひょうか)されません。<br>
                        つまり、何も表示(ひょうじ)されないのです
                    </aside>
                </section>
            </section>

            <!-- Section 3: Components Basics -->
            <section>
                <section>
                    <h1>コンポーネント = 関数</h1>
                    <p>再利用できるUI部品</p>
                    <aside class="notes">
                        コンポーネントはReactの基本(きほん)です。<br>
                        UIを部品(ぶひん)として分割(ぶんかつ)して、再利用(さいりよう)します
                </section>

                <section>
                    <h2>なぜコンポーネント？</h2>

                    <ul>
                        <li><strong>再利用性</strong>：一度作れば何度でも使える</li>
                        <li><strong>保守性</strong>：修正は1箇所だけでOK</li>
                        <li><strong>可読性</strong>：コードが整理される</li>
                        <li><strong>テスト</strong>：部品ごとに検証可能</li>
                    </ul>

                    <pre><code data-lang="jsx">// 100回書く代わりに
&lt;UserCard user={user1} /&gt;
&lt;UserCard user={user2} /&gt;
&lt;UserCard user={user3} /&gt;</code></pre>

                    <div class="note">
                        レゴブロックみたいにUIを組み立てる
                    </div>
                    <aside class="notes">
                        コンポーネントは再利用(さいりよう)できて、修正(しゅうせい)も簡単(かんたん)になります
                    </aside>
                </section>

                <section>
                    <h2>最初のコンポーネント</h2>
                    <pre><code data-lang="jsx">// これがコンポーネント
function Welcome() {
  return &lt;h1&gt;Hello, World!&lt;/h1&gt;;
}

// 使う時
function App() {
  return (
    &lt;div&gt;
      &lt;Welcome /&gt;
      &lt;Welcome /&gt;
    &lt;/div&gt;
  );
}</code></pre>
                    <div class="note">関数名は<strong>大文字で始める</strong>（HTMLタグと区別するため）</div>
                    <aside class="notes">
                        コンポーネントは大文字(おおもじ)で始(はじ)める関数(かんすう)です。何回(なんかい)でも使(つか)えます
                    </aside>
                </section>

                <section>
                    <h2>コンポーネントの解剖学</h2>
                    <pre><code data-lang="jsx">// 1. 関数宣言（大文字で始める）
function UserCard() {
  // 2. ロジック（普通のJS）
  const userName = 'Kurosaki Ichigo';
  
  // 3. JSXを返す（必須）
  return (
    &lt;div className="user-card"&gt;
      &lt;h3&gt;{userName}&lt;/h3&gt;
    &lt;/div&gt;
  );
}</code></pre>
                    <aside class="notes">
                        コンポーネントは、3つの部分（ぶぶん）でできています：<br>関数宣言（かんすうせんげん）、ロジック、JSX を返（かえ）すところです。
                    </aside>
                </section>

                <section>
                    <h2>コンポーネント合成</h2>
                    <div class="triptych-transformation">
                        <pre><code data-lang="jsx">// 小さいコンポーネント
function Header() { return &lt;h1&gt;ジョジョファンサイト&lt;/h1&gt;; }

function Navigation() {
  return (
    &lt;nav&gt;
      &lt;a href="#home"&gt;ホーム&lt;/a&gt;
      &lt;a href="#stands"&gt;スタンド&lt;/a&gt;
    &lt;/nav&gt;
  );
}

function Footer() { return &lt;p&gt;© 2025 ジョジョファンサイト&lt;/p&gt;; }</code></pre>
                        <div class="arrow">→</div>
                        <pre><code data-lang="jsx">// 合成して大きいコンポーネント  
function App() {
  return (
    &lt;div&gt;
      &lt;Header /&gt;
      &lt;Navigation /&gt;
      &lt;main&gt;メインコンテンツ&lt;/main&gt;
      &lt;Footer /&gt;
    &lt;/div&gt;
  );
}</code></pre>
                    </div>
                    <aside class="notes">
                        小（ちい）さいコンポーネントを組（く）み合わせて、大（おお）きなものを作（つく）ります。<br>
                        これをコンポーネント合成（ごうせい）といいます。
                    </aside>
                </section>
            </section>

            <!-- Section 4: Props -->
            <section>
                <section>
                    <h1>Props = 関数の引数</h1>
                    <p>コンポーネントにデータを渡す</p>
                    <aside class="notes">
                        コンポーネントの作り方が分かりました。<br>
                        でも、データを渡（わた）すには どう すれば いいでしょうか？<br>
                        そこで「Props」の出番（でばん）です。
                    </aside>
                </section>

                <section>
                    <h2>Props基本</h2>
                    <pre><code data-lang="jsx">// 普通の関数
function greet(name, age) {
  return `こんにちは、${name}さん（${age}歳）`;
}

// Reactコンポーネント
function Greeting({ name, age }) {
  return &lt;p&gt;こんにちは、{name}さん（{age}歳）&lt;/p&gt;;
}

// 使用
&lt;Greeting name="Kurosaki Ichigo" age={15} /&gt;</code></pre>
                    <p class="note">propsは<strong>読み取り専用</strong></p>
                    <aside class="notes">
                        Propsはコンポーネントにデータを渡すためのものです。<br>
                        関数(かんすう)の引数(ひきすう)と同(おな)じように使(つか)います<br>
                        ただし、propsは読み取り専用（よみとりせんよう）で、変更（へんこう）できません。
                    </aside>
                </section>

                <section>
                    <h2>Props受け取り方法</h2>
                    <div class="fragment">
                        <p>方法1: <code>props</code>オブジェクト</p>
                        <pre><code data-lang="jsx">
function Greeting(props) {
  return &lt;h1&gt;Hello, {props.name}!&lt;/h1&gt;;
}</code></pre>
                    </div>
                    <div class="fragment">
                        <p>方法2: 分割代入【destructuring】</p>
                        <pre><code data-lang="jsx">
function Greeting({ name, age }) {
  return &lt;h1&gt;Hello, {name}! You are {age}&lt;/h1&gt;;
}
</code></pre>
                    </div>
                    <div class="fragment">
                        <p>方法3: デフォルト値</p>
                        <pre><code data-lang="jsx">
function Greeting({ name = "Guest", age = 0 }) {
  return &lt;h1&gt;Hello, {name}! You are {age}&lt;/h1&gt;;
}</code></pre>
                    </div>
                    <div class="note fragment">
                        分割代入はオブジェクトのプロパティを直接変数に展開する
                    </div>
                    <aside class="notes">
                        Propsの受け取り方（うけとりかた）は3つあります。<br>
                        - propsオブジェクトをそのまま使う<br>
                        - 分割代入[ぶんかつだいにゅう]を使う<br>
                        - デフォルト値[ち]を設定（せってい）する
                    </aside>
                </section>

                <section>
                    <h2>children prop</h2>
                    <pre><code data-lang="jsx">// Cardコンポーネント
function Card({ title, children }) {
  return (
    &lt;div className="card"&gt;
      &lt;h2&gt;{title}&lt;/h2&gt;
      &lt;div className="card-content"&gt;
        {children}
      &lt;/div&gt;
    &lt;/div&gt;
  );
}</code></pre>

                    <pre><code data-lang="jsx">// 使用方法
&lt;Card title="Profile"&gt;
  &lt;p&gt;This goes into children&lt;/p&gt;
  &lt;button&gt;Edit Profile&lt;/button&gt;
&lt;/Card&gt;</code></pre>
                    <div class="note">children = タグで囲んだ中身すべて</div>
                    <aside class="notes">
                        childrenは特別(とくべつ)なpropです。タグの中身(なかみ)がすべて入(はい)ります
                    </aside>
                </section>

                <section>
                    <h2>イベントハンドラー</h2>
                    <pre><code data-lang="jsx">function Button({ onClick, children }) {
  return (
    &lt;button onClick={onClick}&gt;
      {children}
    &lt;/button&gt;
  );
}</code></pre>

                    <pre><code data-lang="jsx">// 使用
function App() {
  const handleClick = () => alert('クリック！');
  
  return (
    &lt;Button onClick={handleClick}&gt;
      クリックして
    &lt;/Button&gt;
  );
}</code></pre>
                    <aside class="notes">
                        関数(かんすう)もpropsで渡(わた)せます。クリックイベントなどに使(つか)います
                    </aside>
                </section>
                <section>
                    <h2>Props vs Rails partials</h2>
                    <div class="comparison">
                        <div>
                            <p>Reactのcomponent:</p>
                            <pre><code data-lang="jsx">&lt;UserCard 
  name={user.name}
  email={user.email} 
  isAdmin={true} /&gt;</code></pre>
                        </div>
                        <div>
                            <p>Railsのpartial:</p>
                            <pre><code data-lang="erb">&lt;%= render 'user_card', 
    user: @user, 
    show_admin: true %&gt;</code></pre>
                        </div>
                    </div>
                    <div class="note">props = partial variables みたいなもの</div>
                    <aside class="notes">
                        ReactのpropsはRailsのpartial変数(へんすう)に似(に)ています
                </section>
                <section>
                    <h4>理解度チェック③【Props】</h4>
                    <div class="quiz">
                        <h3>childrenには何が入る?</h3>
                        <pre><code data-lang="jsx">function Card({ title, children }) {
    return (
        &lt;div&gt;
            &lt;h2&gt;{title}&lt;/h2&gt;
            {children}
        &lt;/div&gt;
    );
}</code></pre>
                        <pre><code data-lang="jsx">
&lt;Card title="Profile"&gt;
    &lt;p&gt;Content here&lt;/p&gt;
&lt;/Card&gt;
</code></pre>
                        <div class="quiz-options small">
                            <div class="quiz-option">A) <code>Content here</code></div>
                            <div class="quiz-option">B)
                                <code>&lt;div&gt;&lt;h2&gt;{title}&lt;/h2&gt;Content here&lt;/div&gt;</code>
                            </div>
                            <div class="quiz-option fragment custom correct-answer" data-fragment-index="1">C)
                                <code>&lt;p&gt;Content here&lt;/p&gt;</code>
                            </div>
                            <div class="quiz-option">D) <code>&lt;h2&gt;Profile&lt;/h2&gt;Content here</code></div>
                        </div>
                    </div>
                    <div class="fragment" data-fragment-index="1">
                        <div class="note">
                            <strong>答え:</strong> C) <code>children</code>はコンポーネントの開始・終了タグの間の要素
                        </div>
                    </div>
                </section>
                <aside class="notes">
                    childrenプロパティの中身(なかみ)を確認(かくにん)しましょう
                </aside>
            </section>

            <!-- Debugging Tips -->
            <section>
                <section>
                    <h1>おまけ: デバッグのコツ</h1>
                    <p>バグと戦うための武器</p>
                    <aside class="notes">
                        Reactのバグへの対処(たいしょ)を覚(おぼ)えましょう
                    </aside>
                </section>

                <section>
                    <h2>よくあるミス</h2>
                    <div class="comparison">
                        <div class="mistake-item">
                            <p>コンポーネント名が小文字</p>
                            <pre><code data-lang="jsx">function welcome() {  // 小文字ダメ
  return &lt;h1&gt;Hello&lt;/h1&gt;;
}

&lt;welcome /&gt;  // HTMLタグと判断される</code></pre>
                        </div>

                        <div class="mistake-item">
                            <p><code>key</code>属性忘れ</p>
                            <pre><code data-lang="jsx">{users.map(user =&gt; 
  &lt;div&gt;{user.name}&lt;/div&gt;  // keyがない
)}</code></pre>
                        </div>

                        <div class="mistake-item">
                            <p><code>class</code>属性</p>
                            <pre><code data-lang="jsx">&lt;div class="container"&gt;  // classNameが正しい</code></pre>
                        </div>

                        <div class="mistake-item">
                            <p><code>return</code>忘れ</p>
                            <pre><code data-lang="jsx">function Header() {
  &lt;h1&gt;Title&lt;/h1&gt;;  // returnがない
}</code></pre>
                        </div>
                    </div>
                    <aside class="notes">
                        よく間違(まちが)えるポイントです。エラーメッセージを読(よ)みましょう
                    </aside>
                </section>

                <section>
                    <h2>武器1: React Developer Tools</h2>
                    <div class="tool-intro">
                        <p><strong>ブラウザ拡張機能</strong> Reactの状態を可視化</p>
                        <ul>
                            <li>Chrome/Firefox/Edge対応</li>
                            <li>コンポーネントツリー表示</li>
                            <li>Props/State監視</li>
                            <li>パフォーマンス分析</li>
                        </ul>
                    </div>
                    <div class="note">
                        開発者ツールにReactタブが追加される
                    </div>
                    <aside class="notes">
                        ブラウザの拡張機能(かくちょうきのう)です。propsやstateが見(み)れます
                    </aside>
                </section>

                <section>
                    <h2>武器2: console.log in JSX</h2>
                    <pre><code data-lang="jsx">function TodoItem({ todo }) {
  console.log('TodoItem rendered:', todo);  // 基本のログ
  
  return (
    &lt;li&gt;
      {console.log('Rendering todo text:', todo.text) || null}
      {todo.text}
    &lt;/li&gt;
  );
}</code></pre>

                    <div class="note">
                        JSX内でconsole.logする場合は<code>|| null</code>で戻り値を無効化
                    </div>
                    <aside class="notes">
                        JSXの中(なか)でconsole.logを使(つか)うと、レンダリング時(じ)に値(あたい)が表示(ひょうじ)されます
                    </aside>
                </section>

                <section>
                    <h2>デバッグフロー</h2>
                    <ol>
                        <li><strong>エラーメッセージを読む</strong></li>
                        <li><strong>console.logで値を確認</strong></li>
                        <li><strong>React DevToolsでprops確認</strong></li>
                        <li><strong>最小限のコードで再現</strong></li>
                    </ol>
                </section>
            </section>

            <!-- Practice -->
            <section>
                <section>
                    <h1>React 実践演習</h1>
                    <h3>1つの課題 (15-20分)</h3>

                    <p>今日学んだ内容を実際に使ってみよう！</p>
                    <div class="note"><a
                            href="https://github.com/cdefined/front-kaizen/blob/master/react-lessons/lesson_1/task.md">react-lessons/lesson_1/task.md</a>
                    </div>
                </section>
                <section>
                    <h3>セットアップ手順</h3>
                    <ol>
                        <li>masterブランチに切り替え、更新を取得する
                            <pre><code data-lang="bash">git switch master
git pull origin main</code></pre>
                        </li>
                        <li>パッケージをインストールする
                            <pre><code data-lang="bash">cd react-lessons/
npm install</code></pre>
                        </li>
                        <li>開発サーバーを起動する
                            <pre><code data-lang="bash">npm run dev</code></pre>
                        </li>
                        <li>ブラウザで「<a href="http://localhost:5173/">http://localhost:5173/</a>」を開く</li>
                    </ol>
                    <div class="note"><a
                            href="https://github.com/cdefined/front-kaizen/blob/master/react-lessons/lesson_1/task.md">react-lessons/lesson_1/task.md</a>
                    </div>
                </section>

                <!-- Task 1 -->
                <section>
                    <div class="timer"></div>

                    <h2><span class="task-number">課題1</span> Props付きのコンポーネント</h2>

                    <p><strong><code>&lt;ZanpakutoCard&gt;</code> コンポーネントを作成してください</strong></p>
                    <ul>
                        <li><code>zanpakuto</code> オブジェクトを <strong>Props</strong> として受け取る</li>
                        <li>以下のプロパティをすべて表示すること:
                            <ul>
                                <li><code>name</code>, <code>owner</code>, <code>type</code>, <code>bankai</code>,
                                    <code>shikaiAbility</code>, <code>powerLevel</code>, <code>isReleased</code>
                                </li>
                            </ul>
                        </li>
                        <li><code>bankai</code> は存在する場合のみ表示</li>
                    </ul>

                    <pre><code data-lang="typescript">export interface Zanpakuto {
  name: string;
  owner: string;
  type: "melee" | "kido" | "elemental" | "illusion";
  bankai?: string;
  shikaiAbility: string;
  powerLevel: number;
  isReleased: boolean;
}
    </code></pre>

                    <div class="note"><a
                            href="https://github.com/cdefined/front-kaizen/blob/master/react-lessons/lesson_1/task.md">react-lessons/lesson_1/task.md</a>
                    </div>
                </section>
                <section>
                    <h2><span class="task-number">課題1</span> 解答例</h2>
                    <p><code>props</code> を受け取って全てのプロパティを表示する</p>
                    <pre><code data-lang="tsx">function ZanpakutoCard({ zanpakuto }: { zanpakuto: Zanpakuto }) {
  const { name, owner, type, bankai, shikaiAbility, powerLevel, isReleased } = zanpakuto;  // 分割代入でプロパティを展開
  
  return (
    &lt;div&gt;
      &lt;h2&gt;{name}（{owner}の斬魄刀）&lt;/h2&gt; {/* JSXでは{}内にJavaScript式を書ける */}
      &lt;p&gt;タイプ: {type}&lt;/p&gt;
      {bankai && &lt;p&gt;卍解: {bankai}&lt;/p&gt;} {/* 条件付きレンダリングの&&演算子：左側がtruthyの場合、右側を実行 */}
      &lt;p&gt;始解能力: {shikaiAbility}&lt;/p&gt;
      &lt;p&gt;霊圧レベル: {powerLevel}&lt;/p&gt;
      &lt;p&gt;解放済み: {isReleased ? "はい" : "いいえ"}&lt;/p&gt; {/* 三項演算子 - 条件 ? 真の場合 : 偽の場合 */}
    &lt;/div&gt;
  );
}</code></pre>
                </section>
            </section>

            <section>
                <!-- Summary -->
                <section>
                    <h1>第1回まとめ</h1>

                    <h2>今日学んだこと</h2>
                    <ul>
                        <li><strong>Reactとは</strong> UIライブラリ、仮想DOM、宣言的プログラミング</li>
                        <li><strong>JSX</strong> JavaScript + XML、{}で動的コンテンツ</li>
                        <li><strong>コンポーネント</strong> 再利用可能なUI部品（関数）</li>
                        <li><strong>Props</strong> コンポーネント間のデータ受け渡し</li>
                        <li><strong>条件レンダリング</strong> 三項演算子、&&演算子</li>
                    </ul>
                </section>

                <!-- In next episode -->
                <section>
                    <h1>次回予告</h1>
                    <p><strong>React②:</strong> useState、イベント処理、フォーム</p>
                </section>
            </section>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/reveal.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/plugin/notes/notes.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/plugin/markdown/markdown.min.js"></script>
    <script src="../../scripts/reveal-timer-plugin.js"></script>
    <script type="module">
        import { codeToHtml } from 'https://esm.sh/shiki@3.0.0';

        const codeBlocks = document.querySelectorAll('pre code[data-lang]');

        for (const block of codeBlocks) {
            const lang = block.dataset.lang;
            const theme = block.dataset.theme || 'night-owl'; // 'material-theme-darker'
            const rawCode = block.textContent.trim();

            const html = await codeToHtml(rawCode, { lang, theme });

            const wrapper = document.createElement('div');
            wrapper.innerHTML = html;
            const shikiHTML = wrapper.firstElementChild;

            const pre = block.closest('pre');
            if (pre && shikiHTML) pre.replaceWith(shikiHTML);
        }
    </script>

    <script>
        Reveal.initialize({
            hash: true,
            slideNumber: true,
            width: 1800,
            height: 900,
            margin: 0.1,
            transition: 'slide',
            transitionSpeed: 'fast',
            backgroundTransition: 'fade',
            plugins: [RevealNotes, RevealTimer, RevealMarkdown],
            highlight: {
                escapeHTML: true
            }
        });
    </script>
</body>

</html>