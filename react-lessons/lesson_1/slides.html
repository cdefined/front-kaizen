<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta lang="ja">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>React基礎①</title>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/reveal.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/theme/black.min.css">
    <style>
        .reveal {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        .reveal h1,
        .reveal h2,
        .reveal h3,
        .reveal h4 {
            color: #667eea;
            text-transform: none;
        }

        .reveal .pale {
            opacity: 0.9;
            font-size: 1em;
        }

        .reveal .slides section {
            text-align: left;
        }

        .reveal .title-slide {
            text-align: center;
        }

        .reveal .code-wrapper code {
            font-size: 1.3em;
        }

        .reveal .code-wrapper .code-medium {
            font-size: 1.19em;
        }

        .reveal .code-wrapper .code-medium-small {
            font-size: 1.1em;
        }

        .reveal .code-wrapper .code-small,
        .code-small {
            font-size: 0.9em;
        }

        .code-small .code-wrapper {
            width: 100%;
        }

        .reveal .comparison .hljs {
            max-height: 350px;
            min-height: unset;
            height: 100%;
        }

        ul>li,
        dl>dd {
            line-height: 2em;
        }

        .lifecycle {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 40px 0;
            padding: 20px;
            border-radius: 10px;
        }

        .lifecycle div {
            background: rgba(255, 255, 255, 0.1);
            flex: 1;
            text-align: center;
            padding: 10px;
            border-radius: 10px;
        }

        .lifecycle .arrow {
            background: none;
            font-size: 100px;
            color: #667eea;
            flex: 0;
        }

        .down-arrow {
            opacity: 0.7;
            display: flex;
            justify-content: center;
            font-size: 50px;
            flex: 0;
        }

        .comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }

        .js-side,
        .ts-side {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 8px;
        }

        .js-side h4 {
            color: #f39c12;
        }

        .ts-side h4 {
            color: #3498db;
        }

        .note {
            background: rgba(52, 152, 219, 0.2);
            border-left: 4px solid #3498db;
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .warning {
            background: rgba(231, 76, 60, 0.2);
            border-left: 4px solid #e74c3c;
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .quiz {
            background: rgba(46, 204, 113, 0.1);
            border-left: 4px solid #2ecc71;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
        }

        .quiz-options {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr 1fr;
            gap: 10px;
        }

        .quiz-option {
            display: block;
            margin: 8px 0;
            padding: 8px 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .quiz-option:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .fragment.correct-answer.visible {
            border-left: 4px solid #2ecc71;
            background: rgba(46, 204, 113, 0.3);
        }

        .reveal pre code {
            padding: 1em;
        }

        .timer {
            position: absolute;
            top: -30px;
            right: 15px;
        }

        .comparison-table {
            font-size: 0.75em;
            border-collapse: collapse;
            width: 100%;
            margin: 1rem 0;
        }

        .comparison-table th,
        .comparison-table td {
            padding: 0.6rem 0.4rem;
            text-align: center;
        }

        .comparison-table thead th {
            font-weight: bold;
        }

        .comparison-table .metric {
            font-weight: bold;
            text-align: left;
        }
    </style>
</head>

<body>
    <div class="reveal">
        <div class="slides">
            <section class="title-slide">
                <h1>React基礎①</h1>
                <h2>Reactとは、JSX、コンポーネント、Propsの使い方</h2>
                <aside class="notes"></aside>
            </section>

            <section>
                <!-- What is React -->
                <section>
                    <h1>Reactとは？</h1>
                    <p class="intro-text"><strong>ユーザインターフェース構築のためのJavaScriptライブラリ</strong></p>

                    <ul>
                        <li>Meta（旧Facebook）が2013年にオープンソース化</li>
                        <li>コンポーネントベースのアーキテクチャ</li>
                        <li>仮想DOMによる効率的な更新</li>
                        <li>宣言的なプログラミングモデル</li>
                    </ul>

                    <div class="note">
                        「何を表示するか」を記述すれば、「どうやって更新するか」はReactが処理する
                    </div>
                </section>

                <!-- Why React was needed -->
                <section>
                    <h2>従来のDOM操作の問題点</h2>

                    <h3>手動DOM操作の課題</h3>
                    <ul>
                        <li>状態とUIの同期を手動で管理する必要</li>
                        <li>DOMの直接操作はバグの温床</li>
                        <li>アプリが大きくなると管理が困難</li>
                        <li>コードが複雑になりがち</li>
                    </ul>
                </section>
                <section>
                    <h2>コード比較</h2>
                    <div class="comparison">
                        <div class="comparison-item">
                            <h4>従来のJavaScript</h4>
                            <pre><code data-lang="javascript" class="code-small">const button = document.getElementById('btn');
const counter = document.getElementById('count');
let count = 0;

button.addEventListener('click', () => {
  count++;
  counter.textContent = count;
  // 他の場所でcountを使用している箇所も
  // 手動で更新する必要がある
});</code></pre>
                        </div>
                        <div class="comparison-item">
                            <h4>React</h4>
                            <pre><code data-lang="tsx" class="code-small">function Counter() {
  const [count, setCount] = useState(0);
  
  return (
    &lt;div&gt;
      &lt;span&gt;{count}&lt;/span&gt;
      &lt;button onClick={() => setCount(count + 1)}&gt;
        +1
      &lt;/button&gt;
    &lt;/div&gt;
  );
}</code></pre>
                        </div>
                    </div>
                </section>

                <!-- React's Approach -->
                <section>
                    <h2>Reactのアプローチ</h2>

                    <h3>宣言的UI</h3>
                    <p>「状態が変わったら全体を再描画」という発想の転換</p>

                    <ul>
                        <li><strong>状態管理の単純化</strong>：状態を変更するだけでUIが自動更新</li>
                        <li><strong>仮想DOM</strong>：メモリ上で差分を計算し、必要な部分だけ更新</li>
                        <li><strong>コンポーネント思考</strong>：UIを再利用可能な部品として構築</li>
                    </ul>

                    <div class="note">
                        従来の「どうやって更新するか」から「何を表示するか」への思考転換
                    </div>
                </section>

                <!-- SPA Introduction -->
                <section>
                    <h2>SPA【Single Page Application】とは？</h2>

                    <h3>従来のWebサイト【Multi Page Application】</h3>
                    <ul>
                        <li>ページ遷移のたびにサーバーから新しいHTMLを取得</li>
                        <li>画面全体がリロードされる</li>
                        <li>ページ遷移が遅い</li>
                    </ul>

                    <h3>SPA</h3>
                    <ul>
                        <li>初回ロード後、JavaScriptでページ遷移を制御</li>
                        <li>必要なデータのみAPIで取得</li>
                        <li>高速なページ遷移が可能</li>
                    </ul>
                </section>
                <section>
                    <h2>SPA【Single Page Application】とは？</h2>
                    <div class="comparison">
                        <div class="pros">
                            <h4>メリット</h4>
                            <ul>
                                <li>高速なページ遷移</li>
                                <li>アプリライクなUX</li>
                                <li>サーバー負荷軽減</li>
                            </ul>
                        </div>
                        <div class="cons">
                            <h4>課題</h4>
                            <ul>
                                <li>初回ロードが重い</li>
                                <li>SEOが困難</li>
                                <li>JavaScriptが必須</li>
                            </ul>
                        </div>
                    </div>
                </section>

                <!-- The SPA Problem -->
                <section>
                    <h2>SPAの根本的な問題</h2>
                    <div class="warning">
                        <p><strong>純粋なSPAは多くの問題を抱えており現在は「呪われた」技術とされることも</strong></p>
                    </div>

                    <h3>主な問題点</h3>
                    <ul>
                        <li><strong>SEO</strong> : 検索エンジンがJavaScriptを実行しないと内容が見えない</li>
                        <li><strong>初回ロード</strong> : すべてのJavaScriptをダウンロードするまで何も表示されない</li>
                        <li><strong>パフォーマンス</strong> : バンドルが大きくなりがち</li>
                        <li><strong>複雑性</strong> : クライアントサイドでの状態管理が複雑</li>
                    </ul>
                </section>

                <!-- Slide 9: SPA Solutions -->
                <section>
                    <h2>現実的な解決策</h2>
                    <ul>
                        <li><strong>SSR【Server Side Rendering】</strong><br>サーバーでHTMLを生成</li>
                        <li><strong>SSG【Static Site Generation】</strong><br>ビルド時に静的HTMLを生成</li>
                        <li><strong>ISR【Incremental Static Regeneration】</strong><br>必要に応じて静的ページを再生成</li>
                    </ul>

                    <div class="note">
                        これらの手法で純粋SPAの問題を解決（Next.js、React Router/Remix等のフレームワーク）
                    </div>
                </section>

                <!-- Ecosystem Overview -->
                <section>
                    <h2>Reactエコシステム（参考）</h2>
                    <h3>フルスタックフレームワーク</h3>
                    <ul>
                        <li><strong>Next.js</strong>：SSR/SSG対応・本格的なWebアプリ開発</li>
                        <li><strong>React Router/Remix</strong>：フルスタック・Web標準重視</li>
                        <li><strong>Astro、Gatsby</strong>：静的サイト生成特化</li>
                    </ul>
                    <br><br>
                    <h3>ネイティブアプリ</h3>
                    <ul>
                        <li><strong>React Native</strong>：iOS・Androidアプリ開発</li>
                        <li><strong>Expo</strong>：React Nativeの開発環境</li>
                    </ul>
                    <div class="note">
                        本コースでは基本的なSPAから始めますが、実際のプロダクションでは上記のフレームワークを使用することが多い
                    </div>
                </section>

                <!-- React vs Others -->
                <section>
                    <h2>主要フレームワーク比較</h2>
                    <table class="comparison-table">
                        <thead>
                            <tr>
                                <th></th>
                                <th>React</th>
                                <th>Vue</th>
                                <th>Angular</th>
                                <th>Svelte</th>
                                <th>SolidJS</th>
                                <th>Preact</th>
                                <th>Lit</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="metric">学習コスト</td>
                                <td>中</td>
                                <td>中</td>
                                <td>高</td>
                                <td>中</td>
                                <td>中</td>
                                <td>低</td>
                                <td>中</td>
                            </tr>
                            <tr>
                                <td class="metric">エコシステム</td>
                                <td>最大</td>
                                <td>大</td>
                                <td>大</td>
                                <td>小</td>
                                <td>小</td>
                                <td>中</td>
                                <td>小</td>
                            </tr>
                            <tr>
                                <td class="metric">TypeScript</td>
                                <td>オプション</td>
                                <td>オプション</td>
                                <td>標準</td>
                                <td>標準</td>
                                <td>標準</td>
                                <td>オプション</td>
                                <td>標準</td>
                            </tr>
                            <tr>
                                <td class="metric">バンドルサイズ</td>
                                <td>42KB</td>
                                <td>36KB</td>
                                <td>130KB</td>
                                <td>10KB</td>
                                <td>7KB</td>
                                <td>3KB</td>
                                <td>5KB</td>
                            </tr>
                            <tr>
                                <td class="metric">パフォーマンス</td>
                                <td>良</td>
                                <td>良</td>
                                <td>良</td>
                                <td>優秀</td>
                                <td>優秀</td>
                                <td>良</td>
                                <td>良</td>
                            </tr>
                            <tr>
                                <td class="metric">求人数</td>
                                <td>最多</td>
                                <td>多</td>
                                <td>多</td>
                                <td>少</td>
                                <td>極少</td>
                                <td>少</td>
                                <td>少</td>
                            </tr>
                        </tbody>
                    </table>

                    <div class="note">
                        <strong>結論</strong>：Reactは学習コストとエコシステムのバランスが良く、転職市場でも最も有利
                    </div>
                </section>
            </section>

            <!-- Core Concepts -->
            <section>
                <h2>Reactの核となる概念</h2>
                <dl>
                    <dt><strong>コンポーネント</strong></dt>
                    <dd>UIを独立した再利用可能な部品として作成</dd>

                    <dt><strong>JSX</strong></dt>
                    <dd>JavaScriptの中にHTMLライクな構文を書ける</dd>

                    <dt><strong>State（状態）</strong></dt>
                    <dd>コンポーネントが持つ変更可能なデータ</dd>

                    <dt><strong>Props</strong></dt>
                    <dd>親コンポーネントから子へ渡すデータ</dd>

                    <dt><strong>仮想DOM</strong></dt>
                    <dd>メモリ上でDOM操作を計算し、効率的に更新</dd>
                </dl>
            </section>
            <!-- Section 1: JSX Basics -->
            <section>
                <section>
                    <h1>JSX = JavaScript + XML</h1>
                    <p>普通のHTMLから始めよう</p>
                </section>

                <section>
                    <h2>HTMLをそのまま書ける</h2>
                    <pre><code data-lang="html">&lt;div class="greeting"&gt;
  &lt;h1&gt;Hello, World!&lt;/h1&gt;
  &lt;p&gt;今日はいい天気ですね&lt;/p&gt;
&lt;/div&gt;</code></pre>
                    <div class="fragment">
                        <p>→ JSXならこれをJS関数の中に書ける</p>
                    </div>
                </section>

                <section>
                    <h2>JSXの実際</h2>
                    <pre><code data-lang="jsx">function Greeting() {
  return (
    &lt;div className="greeting"&gt;
      &lt;h1&gt;Hello, World!&lt;/h1&gt;
      &lt;p&gt;今日はいい天気ですね&lt;/p&gt;
    &lt;/div&gt;
  );
}</code></pre>
                    <div class="note">
                        <code>className</code>に注意！ <code>class</code>はJSの予約語だから
                    </div>
                </section>

                <section>
                    <h2>JSXの正体</h2>
                    <p>JSXはこれにコンパイルされる：</p>
                    <pre><code data-lang="jsx">// JSX
&lt;div className="greeting"&gt;Hello!&lt;/div&gt;

// ↓ コンパイル後
React.createElement(
  "div",
  { className: "greeting" },
  "Hello!"
);</code></pre>
                    <div class="note">つまり<strong>JSX = syntactic sugar</strong></div>
                </section>

                <section>
                    <h2>JSXのルール</h2>
                    <div class="fragment">
                        <h3>1. 必ず1つの要素を返す</h3>
                        <pre><code data-lang="jsx">// ❌ ダメ
return (
  &lt;h1&gt;Title&lt;/h1&gt;
  &lt;p&gt;Content&lt;/p&gt;
);

// ✅ OK - Fragment使用
return (
  &lt;&gt;
    &lt;h1&gt;Title&lt;/h1&gt;
    &lt;p&gt;Content&lt;/p&gt;
  &lt;/&gt;
);</code></pre>
                    </div>
                </section>

                <section>
                    <h2>JSXのルール</h2>
                    <div>
                        <h3>2. すべてのタグを閉じる</h3>
                        <pre><code data-lang="jsx">// ❌ HTML風だとダメ
&lt;br&gt;
&lt;img src="photo.jpg"&gt;
&lt;input type="text"&gt;

// ✅ 必ず閉じる
&lt;br /&gt;
&lt;img src="photo.jpg" /&gt;
&lt;input type="text" /&gt;</code></pre>
                    </div>
                </section>

                <section>
                    <h2>JSXのルール</h2>
                    <div>
                        <h3>3. camelCase属性</h3>
                        <pre><code data-lang="jsx">// ❌ HTML属性名
&lt;div class="container" onclick="handleClick()"&gt;
&lt;label for="email"&gt;

// ✅ camelCase
&lt;div className="container" onClick={handleClick}&gt;
&lt;label htmlFor="email"&gt;</code></pre>
                        <div class="note">
                            <code>class</code> → <code>className</code><br>
                            <code>for</code> → <code>htmlFor</code><br>
                            <code>onclick</code> → <code>onClick</code>
                        </div>
                    </div>
                </section>
            </section>

            <!-- Section 2: JavaScript in JSX -->
            <section>
                <section>
                    <h1>JSXにJavaScriptを埋め込む</h1>
                    <p>{}で動的コンテンツ</p>
                </section>

                <section>
                    <h2>変数を表示: {}</h2>
                    <pre><code data-lang="jsx">function User({ name, email }) {
  const greeting = 'こんにちは';
  
  return (
    &lt;div&gt;
      &lt;h2&gt;{greeting}, {name}さん&lt;/h2&gt;
      &lt;p&gt;{email}&lt;/p&gt;
      &lt;p&gt;今年は{new Date().getFullYear()}年です。&lt;/p&gt;
    &lt;/div&gt;
  );
}</code></pre>
                    <div class="note"><code>{}</code>の中は普通のJavaScript式</div>
                </section>

                <section>
                    <h2>条件レンダリング: 三項演算子</h2>
                    <pre><code data-lang="jsx">function UserProfile({ user, isLoggedIn }) {
  return (
    &lt;div&gt;
      {isLoggedIn ? (
        &lt;h1&gt;Welcome {user.name}!&lt;/h1&gt;  {/* trueの場合 */}
      ) : (
        &lt;h1&gt;Please log in&lt;/h1&gt;          {/* falseの場合 */}
      )}
    &lt;/div&gt;
  );
}</code></pre>
                    <div class="note">
                        <code>condition ? trueの時 : falseの時</code><br>
                        必ず両方の場合を書く必要がある
                    </div>
                </section>

                <section>
                    <h2>条件レンダリング: && 演算子</h2>
                    <pre><code data-lang="jsx">function UserProfile({ user }) {
  return (
    &lt;div&gt;
      &lt;h1&gt;Welcome {user.name}!&lt;/h1&gt;
      {user.isAdmin && (
        &lt;div className="admin-panel"&gt;  {/* trueの時だけ表示 */}
          Admin tools
        &lt;/div&gt;
      )}
      {user.notifications.length > 0 && &lt;span&gt;You have {user.notifications.length} messages&lt;/span&gt;}
    &lt;/div&gt;
  );
}</code></pre>
                    <div class="note">
                        <code>condition && JSX</code><br>
                        falseの時は何も表示しない（elseが不要な時）
                    </div>
                </section>

                <section>
                    <h2>ERBとの比較</h2>
                    <div class="comparison">
                        <div>
                            <p>JSX:</p>
                            <pre><code data-lang="jsx">{user.loggedIn ? (
  &lt;h1&gt;Welcome {user.name}!&lt;/h1&gt;
) : (
  &lt;h1&gt;Please log in&lt;/h1&gt;
)}

{user.isAdmin && (
  &lt;div className="admin-panel"&gt;
    Admin tools
  &lt;/div&gt;
)}</code></pre>
                        </div>
                        <div>
                            <p>ERB:</p>
                            <pre><code data-lang="erb">&lt;% if user.logged_in? %&gt;
  &lt;h1&gt;Welcome &lt;%= user.name %&gt;!&lt;/h1&gt;
&lt;% else %&gt;
  &lt;h1&gt;Please log in&lt;/h1&gt;
&lt;% end %&gt;

&lt;% if user.admin? %&gt;
  &lt;div class="admin-panel"&gt;
    Admin tools
  &lt;/div&gt;
&lt;% end %&gt;</code></pre>
                        </div>
                    </div>
                    <div class="note">JSXは式だからreturnの中に直接書ける</div>
                </section>

                <section>
                    <h2>配列をレンダリング</h2>
                    <pre><code data-lang="jsx">function TodoList({ todos }) {
  return (
    &lt;ul&gt;
      {todos.map(todo =&gt; (
        &lt;li key={todo.id}&gt;
          {todo.text}
        &lt;/li&gt;
      ))}
    &lt;/ul&gt;
  );
}</code></pre>
                    <div class="note">
                        <code>key</code>は必須！Reactが効率的に更新するため
                    </div>
                </section>
            </section>

            <!-- Section 3: Components Basics -->
            <section>
                <section>
                    <h1>コンポーネント = 関数</h1>
                    <p>再利用できるUI部品</p>
                </section>

                <section>
                    <h2>最初のコンポーネント</h2>
                    <pre><code data-lang="jsx">// これがコンポーネント
function Welcome() {
  return &lt;h1&gt;Hello, World!&lt;/h1&gt;;
}

// 使う時
function App() {
  return (
    &lt;div&gt;
      &lt;Welcome /&gt;
      &lt;Welcome /&gt;
    &lt;/div&gt;
  );
}</code></pre>
                    <div class="note">関数名は<strong>大文字で始める</strong>（HTMLタグと区別するため）</div>
                </section>

                <section>
                    <h2>コンポーネントの解剖学</h2>
                    <pre><code data-lang="jsx">// 1. 関数宣言（大文字で始める）
function UserCard() {
  // 2. ロジック（普通のJS）
  const userName = 'Ichigo Kurosaki';
  
  // 3. JSXを返す（必須）
  return (
    &lt;div className="user-card"&gt;
      &lt;h3&gt;{userName}&lt;/h3&gt;
    &lt;/div&gt;
  );
}</code></pre>
                </section>

                <section>
                    <h2>コンポーネント合成</h2>
                    <pre><code data-lang="jsx">// 小さいコンポーネント
function Avatar({ src, alt }) {
  return &lt;img src={src} alt={alt} className="avatar" /&gt;;
}

function UserName({ name }) {
  return &lt;span className="username"&gt;{name}&lt;/span&gt;;
}</code></pre>

                    <pre><code data-lang="jsx">// 合成して大きいコンポーネント
function UserProfile({ user }) {
  return (
    &lt;div className="user-profile"&gt;
      &lt;Avatar src={user.avatar} alt={user.name} /&gt;
      &lt;UserName name={user.name} /&gt;
    &lt;/div&gt;
  );
}</code></pre>
                </section>
            </section>

            <!-- Section 4: Props -->
            <section>
                <section>
                    <h1>Props = 関数の引数</h1>
                    <p>コンポーネントにデータを渡す</p>
                </section>

                <section>
                    <h2>Props基本</h2>
                    <pre><code data-lang="jsx">// 普通の関数
function greet(name, age) {
  return `こんにちは、${name}さん（${age}歳）`;
}

// Reactコンポーネント
function Greeting({ name, age }) {
  return &lt;p&gt;こんにちは、{name}さん（{age}歳）&lt;/p&gt;;
}

// 使用
&lt;Greeting name="Kurosaki Ichigo" age={15} /&gt;</code></pre>
                    <p class="note">propsは<strong>読み取り専用</strong></p>
                </section>

                <section>
                    <h2>Props受け取り方法</h2>
                    <pre><code data-lang="jsx">// 方法1: propsオブジェクトそのまま
function Greeting(props) {
  return &lt;h1&gt;Hello, {props.name}!&lt;/h1&gt;;
}

// 方法2: 分割代入（destructuring）- 推奨
function Greeting({ name, age }) {
  return &lt;h1&gt;Hello, {name}! You are {age}&lt;/h1&gt;;
}

// 方法3: デフォルト値
function Greeting({ name = "Guest", age = 0 }) {
  return &lt;h1&gt;Hello, {name}! You are {age}&lt;/h1&gt;;
}</code></pre>
                </section>

                <section>
                    <h2>children prop</h2>
                    <pre><code data-lang="jsx">// Cardコンポーネント
function Card({ title, children }) {
  return (
    &lt;div className="card"&gt;
      &lt;h2&gt;{title}&lt;/h2&gt;
      &lt;div className="card-content"&gt;
        {children}
      &lt;/div&gt;
    &lt;/div&gt;
  );
}</code></pre>

                    <pre><code data-lang="jsx">// 使用方法
&lt;Card title="Profile"&gt;
  &lt;p&gt;This goes into children&lt;/p&gt;
  &lt;button&gt;Edit Profile&lt;/button&gt;
&lt;/Card&gt;</code></pre>
                    <div class="note">children = タグで囲んだ中身すべて</div>
                </section>

                <section>
                    <h2>イベントハンドラー</h2>
                    <pre><code data-lang="jsx">function Button({ onClick, children }) {
  return (
    &lt;button onClick={onClick}&gt;
      {children}
    &lt;/button&gt;
  );
}</code></pre>

                    <pre><code data-lang="jsx">// 使用
function App() {
  const handleClick = () => alert('クリック！');
  
  return (
    &lt;Button onClick={handleClick}&gt;
      クリックして
    &lt;/Button&gt;
  );
}</code></pre>
                </section>

                <section>
                    <h2>Props vs Rails partials</h2>
                    <div class="comparison">
                        <div>
                            <p>Reactのcomponent:</p>
                            <pre><code data-lang="jsx">&lt;UserCard 
  name={user.name}
  email={user.email} 
  isAdmin={true} /&gt;</code></pre>
                        </div>
                        <div>
                            <p>Railsのpartial:</p>
                            <pre><code data-lang="erb">&lt;%= render 'user_card', 
    user: @user, 
    show_admin: true %&gt;</code></pre>
                        </div>
                    </div>
                    <div class="note">props = partial variables みたいなもの</div>
                </section>
            </section>

            <section>
                <section>
                    <h4>理解度チェック①</h4>
                    <div class="quiz">
                        <h3>どちらがエラーになる？</h3>
                        <pre><code data-lang="typescript">let mysteryA: any = "梨花";
let mysteryB: unknown = "梨花";

mysteryA.toUpperCase(); // A
mysteryB.toUpperCase(); // B</code></pre>
                        <div class="quiz-options">
                            <div class="quiz-option">A) mysteryA.toUpperCase()</div>
                            <div class="quiz-option fragment custom correct-answer" data-fragment-index="1">B)
                                mysteryB.toUpperCase()</div>
                            <div class="quiz-option">C) 両方エラー</div>
                            <div class="quiz-option">D) 両方エラーなし</div>
                        </div>
                    </div>
                    <div class="fragment" data-fragment-index="1">
                        <div class="note">
                            <strong>答え:</strong> B) <code>unknown</code>は型ガードが必要。<code>any</code>は何でもOK（危険）
                        </div>
                    </div>
                </section>
            </section>

            <section>
                <!-- Practice -->
                <section>
                    <h1>React 実践演習</h1>
                    <h3>1つの課題 (15-20分)</h3>

                    <p>今日学んだ内容を実際に使ってみよう！</p>
                    <div class="note"><a
                            href="https://github.com/cdefined/front-kaizen/tree/master/react-lessons/lesson_1/task.md">react-lessons/lesson_1/task.md</a>
                    </div>
                </section>
                <section>
                    <h3>セットアップ手順</h3>
                    <ol>
                        <li>masterブランチに切り替え、更新を取得する
                            <pre><code>git switch master
git pull origin main</code></pre>
                        </li>
                        <li>パッケージをインストールする
                            <pre><code>cd react-lessons/
npm install</code></pre>
                        </li>
                        <li>開発サーバーを起動する
                            <pre><code>npm run dev</code></pre>
                        </li>
                        <li>ブラウザで「<a href="http://localhost:5173/">http://localhost:5173/</a>」を開く</li>
                    </ol>
                    <div class="note"><a
                            href="https://github.com/cdefined/front-kaizen/tree/master/react-lessons/lesson_1/task.md">react-lessons/lesson_1/task.md</a>
                    </div>
                </section>

                <!-- Task 1 -->
                <section>
                    <div class="timer"></div>

                    <h2><span class="task-number">課題1</span> Props付きのコンポーネント</h2>

                    <p><strong><code>&lt;ZanpakutoCard&gt;</code> コンポーネントを作成してください</strong></p>
                    <ul>
                        <li><code>zanpakuto</code> オブジェクトを <strong>Props</strong> として受け取る</li>
                        <li>以下のプロパティをすべて表示すること:
                            <ul>
                                <li><code>name</code>, <code>owner</code>, <code>type</code>, <code>bankai</code>,
                                    <code>shikaiAbility</code>, <code>powerLevel</code>, <code>isReleased</code>
                                </li>
                            </ul>
                        </li>
                        <li><code>bankai</code> は存在する場合のみ表示</li>
                    </ul>

                    <pre><code data-lang="typescript">export interface Zanpakuto {
  name: string;
  owner: string;
  type: "melee" | "kido" | "elemental" | "illusion";
  bankai?: string;
  shikaiAbility: string;
  powerLevel: number;
  isReleased: boolean;
}
    </code></pre>

                    <div class="note"><a href="task.md">react-lessons/lesson_1/task.md</a></div>
                </section>
                <section>
                    <h2><span class="task-number">課題1</span> 解答例</h2>
                    <p><code>props</code> を受け取って全てのプロパティを表示する</p>
                    <pre><code data-lang="tsx">function ZanpakutoCard({ zanpakuto }: { zanpakuto: Zanpakuto }) {
  const { name, owner, type, bankai, shikaiAbility, powerLevel, isReleased } = zanpakuto;  // 分割代入でプロパティを展開
  
  return (
    &lt;div&gt;
      &lt;h2&gt;{name}（{owner}の斬魄刀）&lt;/h2&gt; {/* JSXでは{}内にJavaScript式を書ける */}
      &lt;p&gt;タイプ: {type}&lt;/p&gt;
      {bankai && &lt;p&gt;卍解: {bankai}&lt;/p&gt;} {/* 条件付きレンダリングの&&演算子：左側がtruthyの場合、右側を実行 */}
      &lt;p&gt;始解能力: {shikaiAbility}&lt;/p&gt;
      &lt;p&gt;霊圧レベル: {powerLevel}&lt;/p&gt;
      &lt;p&gt;解放済み: {isReleased ? "はい" : "いいえ"}&lt;/p&gt; {/* 三項演算子 - 条件 ? 真の場合 : 偽の場合 */}
    &lt;/div&gt;
  );
}</code></pre>
                </section>
            </section>

            <section>
                <!-- Summary -->
                <section>
                    <h1>第1回まとめ</h1>

                    <h2>今日学んだこと</h2>
                    <ul>
                        <li><strong>TypeScript の基本:</strong> tsc コンパイラーと型システム</li>
                    </ul>
                </section>

                <!-- In next episode -->
                <section>
                    <h1>次回予告</h1>
                    <p><strong>React②:</strong> useState、イベント処理、フォーム</p>
                </section>
            </section>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/reveal.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/plugin/notes/notes.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/plugin/markdown/markdown.min.js"></script>
    <script src="../../scripts/reveal-timer-plugin.js"></script>
    <script type="module">
        import { codeToHtml } from 'https://esm.sh/shiki@3.0.0';

        const codeBlocks = document.querySelectorAll('pre code[data-lang]');

        for (const block of codeBlocks) {
            const lang = block.dataset.lang;
            const theme = block.dataset.theme || 'night-owl'; // 'material-theme-darker'
            const rawCode = block.textContent.trim();

            const html = await codeToHtml(rawCode, { lang, theme });

            const wrapper = document.createElement('div');
            wrapper.innerHTML = html;
            const shikiHTML = wrapper.firstElementChild;

            const pre = block.closest('pre');
            if (pre && shikiHTML) pre.replaceWith(shikiHTML);
        }
    </script>

    <script>
        Reveal.initialize({
            hash: true,
            slideNumber: true,
            width: 1800,
            height: 900,
            margin: 0.1,
            transition: 'slide',
            transitionSpeed: 'fast',
            backgroundTransition: 'fade',
            plugins: [RevealNotes, RevealTimer, RevealMarkdown],
            highlight: {
                escapeHTML: true
            }
        });
    </script>
</body>

</html>