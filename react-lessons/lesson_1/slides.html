<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta lang="ja">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>React基礎①</title>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/reveal.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/theme/black.min.css">
    <style>
        .reveal {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        .reveal h1,
        .reveal h2,
        .reveal h3,
        .reveal h4 {
            color: #667eea;
            text-transform: none;
        }

        .reveal .pale {
            opacity: 0.9;
            font-size: 1em;
        }

        .reveal .slides section {
            text-align: left;
        }

        .reveal .title-slide {
            text-align: center;
        }

        .reveal .code-wrapper code {
            font-size: 1.3em;
        }

        .reveal .code-wrapper .code-medium {
            font-size: 1.19em;
        }

        .reveal .code-wrapper .code-medium-small {
            font-size: 1.1em;
        }

        .reveal .code-wrapper .code-small,
        .code-small {
            font-size: 0.9em;
        }

        .code-small .code-wrapper {
            width: 100%;
        }

        .reveal .comparison .hljs {
            max-height: 350px;
            min-height: unset;
            height: 100%;
        }

        ul>li,
        dl>dd {
            line-height: 2em;
        }

        .lifecycle {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 40px 0;
            padding: 20px;
            border-radius: 10px;
        }

        .lifecycle div {
            background: rgba(255, 255, 255, 0.1);
            flex: 1;
            text-align: center;
            padding: 10px;
            border-radius: 10px;
        }

        .lifecycle .arrow {
            background: none;
            font-size: 100px;
            color: #667eea;
            flex: 0;
        }

        .down-arrow {
            opacity: 0.7;
            display: flex;
            justify-content: center;
            font-size: 50px;
            flex: 0;
        }

        .comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }

        .js-side,
        .ts-side {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 8px;
        }

        .js-side h4 {
            color: #f39c12;
        }

        .ts-side h4 {
            color: #3498db;
        }

        .note {
            background: rgba(52, 152, 219, 0.2);
            border-left: 4px solid #3498db;
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .warning {
            background: rgba(231, 76, 60, 0.2);
            border-left: 4px solid #e74c3c;
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .quiz {
            background: rgba(46, 204, 113, 0.1);
            border-left: 4px solid #2ecc71;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
        }

        .quiz-options {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr 1fr;
            gap: 10px;
        }

        .quiz-option {
            display: block;
            margin: 8px 0;
            padding: 8px 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .quiz-option:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .quiz-options.small {
            font-size: 0.65em;
        }

        .fragment.correct-answer.visible {
            border-left: 4px solid #2ecc71;
            background: rgba(46, 204, 113, 0.3);
        }

        .reveal pre {
            width: 100%;
        }

        .reveal pre code {
            padding: 1em;
        }

        .timer {
            position: absolute;
            top: -30px;
            right: 15px;
        }

        .comparison-table {
            font-size: 0.75em;
            border-collapse: collapse;
            width: 100%;
            margin: 1rem 0;
        }

        .comparison-table th,
        .comparison-table td {
            padding: 0.6rem 0.4rem;
            text-align: center;
        }

        .comparison-table thead th {
            font-weight: bold;
        }

        .comparison-table .metric {
            font-weight: bold;
            text-align: left;
        }
    </style>
</head>

<body>
    <div class="reveal">
        <div class="slides">
            <section class="title-slide">
                <h1>React基礎①</h1>
                <h2>Reactとは、JSX、コンポーネント、Propsの使い方</h2>
                <aside class="notes"></aside>
            </section>

            <section>
                <!-- What is React -->
                <section>
                    <h1>Reactとは？</h1>
                    <p class="intro-text"><strong>ユーザインターフェース構築のためのJavaScriptライブラリ</strong></p>

                    <ul>
                        <li>Meta（旧Facebook）が2013年にオープンソース化</li>
                        <li>コンポーネントベースのアーキテクチャ</li>
                        <li>仮想DOMによる効率的な更新</li>
                        <li>宣言的なプログラミングモデル</li>
                    </ul>

                    <div class="note">
                        「何を表示するか」を記述すれば、「どうやって更新するか」はReactが処理する
                    </div>
                </section>

                <!-- Why React was needed -->
                <section>
                    <h2>従来のDOM操作の問題点</h2>

                    <h3>手動DOM操作の課題</h3>
                    <ul>
                        <li>状態とUIの同期を手動で管理する必要</li>
                        <li>DOMの直接操作はバグの温床</li>
                        <li>アプリが大きくなると管理が困難</li>
                        <li>コードが複雑になりがち</li>
                    </ul>
                </section>

                <!-- DOM -->
                <section>
                    <h2>DOM【Document Object Model】とは？</h2>
                    <p>ブラウザがHTMLを解釈して作る、JavaScriptで操作可能なオブジェクト</p>
                    <div class="comparison">
                        <img src="./images/dom.svg" height="620" alt="DOM" />
                        <div class="example">
                            <h4>JavaScript（Reactなし）</h4>
                            <pre><code data-lang="js">// 要素の取得と内容変更
document.getElementById('count').textContent = '1';

// CSSクラスの追加
document.querySelector('div').classList.add('highlighted');

// 新しい要素の作成と追加
const newButton = document.createElement('button');
newButton.textContent = 'クリック';
document.body.appendChild(newButton);

// イベントリスナーの追加
newButton.addEventListener('click', handleClick);</code></pre>
                        </div>
                    </div>
                    <div class="note">
                        問題：アプリが大きくなると手動更新が地獄になる
                    </div>
                </section>

                <!-- DOM vs React Comparison -->
                <section>
                    <h2>コード比較：DOM操作 vs React</h2>
                    <div class="comparison">
                        <div class="comparison-item">
                            <h4>従来のDOM操作</h4>
                            <pre><code data-lang="javascript">const button = document.getElementById('btn');
const counter = document.getElementById('count');
let count = 0;

button.addEventListener('click', () => {
  count++;
  counter.textContent = count;
  
  // 他の要素も手動で更新
  updateHeader(count);
  updateFooter(count);
});</code></pre>
                        </div>
                        <div class="comparison-item">
                            <h4>React</h4>
                            <pre><code data-lang="jsx">&lt;div&gt;
  &lt;h1&gt;カウンター&lt;/h1&gt;
  &lt;span&gt;{count}&lt;/span&gt;
  &lt;button onClick={handleClick}&gt;
    +1
  &lt;/button&gt;
&lt;/div&gt;</code></pre>
                        </div>
                    </div>

                    <div class="note">
                        Reactなら「何を表示するか」だけ書けばOK
                    </div>
                </section>

                <!-- React's Approach -->
                <section>
                    <h2>Reactのアプローチ</h2>

                    <h3>宣言的UI</h3>
                    <p>「状態が変わったら全体を再描画」という発想の転換</p>

                    <ul>
                        <li><strong>状態管理の単純化</strong>：状態を変更するだけでUIが自動更新</li>
                        <li><strong>仮想DOM</strong>：メモリ上で差分を計算し、必要な部分だけ更新</li>
                        <li><strong>コンポーネント思考</strong>：UIを再利用可能な部品として構築</li>
                    </ul>

                    <div class="note">
                        従来の「どうやって更新するか」から「何を表示するか」への思考転換
                    </div>
                </section>

                <!-- Virtual DOM Introduction -->
                <section>
                    <h2>仮想DOM【Virtual DOM】とは？</h2>
                    <p class="intro-text"><strong>メモリ上にDOMの軽量コピーを保持する仕組み</strong></p>

                    <ul>
                        <li>実際のDOMより高速に操作可能</li>
                        <li>変更前後を比較して差分を検出</li>
                        <li>最小限の実DOM更新のみ実行</li>
                    </ul>

                    <div class="note">
                        「全体を再描画」と言いつつ、実際は必要な部分だけ更新
                    </div>
                </section>

                <!-- Virtual DOM Process -->
                <section>
                    <h2>仮想DOMの動作プロセス</h2>

                    <div class="fragment comparison">
                        <img src="./images/virtual-dom.svg" height="700" alt="Virtual DOM Process" />

                        <div class="process-steps">
                            <div class="fragment">
                                <h4>1. 状態変更</h4>
                                <p>状態またはpropsの変更</p>
                            </div>

                            <div class="fragment">
                                <h4>2. 新しい仮想DOMツリー作成</h4>
                                <p>新しい状態に基づいてメモリ上に仮想DOMを構築</p>
                            </div>

                            <div class="fragment">
                                <h4>3. 差分検出【Diffing】</h4>
                                <p>前回の仮想DOMと今回の仮想DOMを比較</p>
                            </div>

                            <div class="fragment">
                                <h4>4. 最小限更新【Reconciliation】</h4>
                                <p>変更された部分のみ実DOMに反映</p>
                            </div>
                        </div>
                    </div>
                </section>

                <!-- Why Virtual DOM is Fast -->
                <section>
                    <h2>なぜ仮想DOMは高速なのか？</h2>

                    <div class="comparison">
                        <div class="comparison-item">
                            <h4>実DOM操作</h4>
                            <ul>
                                <li>ブラウザのレンダリングエンジンが重い</li>
                                <li>レイアウト計算が発生</li>
                                <li>再描画処理が必要</li>
                                <li>1つの変更でも全体に影響</li>
                            </ul>
                        </div>

                        <div class="comparison-item">
                            <h4>仮想DOM</h4>
                            <ul>
                                <li>JavaScriptオブジェクトなので軽量</li>
                                <li>メモリ上での比較計算</li>
                                <li>バッチ処理で最適化</li>
                                <li>変更部分のみ実DOM更新</li>
                            </ul>
                        </div>
                    </div>
                </section>

                <!-- Virtual DOM Example -->
                <section>
                    <h2>仮想DOM　具体例</h2>

                    <div class="example">
                        <h4>JSX</h4>
                        <pre><code data-lang="jsx">&lt;div&gt;
  &lt;h1&gt;カウント: {count}&lt;/h1&gt;
  &lt;button&gt;+1&lt;/button&gt;
&lt;/div&gt;</code></pre>

                        <h4>仮想DOM（概念）</h4>
                        <pre><code data-lang="javascript">{
  type: 'div',
  children: [
    {
      type: 'h1',
      children: `カウント: ${count}`
    },
    {
      type: 'button',
      children: '+1'
    }
  ]
}</code></pre>
                    </div>

                    <div class="note">
                        countが0→1に変わった時、h1のテキスト部分のみ実DOM更新
                    </div>
                </section>

                <!-- Similar frameworks/libs -->
                <section>
                    <h2>React類似技術の一覧</h2>
                    <ul>
                        <li>Vue</li>
                        <li>Angular</li>
                        <li>Svelte</li>
                        <li>SolidJS</li>
                        <li>Preact</li>
                        <li>Lit</li>
                    </ul>
                </section>
                <section>
                    <h2>なぜReactを学ぶのか？</h2>
                    <ul>
                        <li>手動DOM操作の複雑さを解決</li>
                        <li>状態とUIの同期を自動化</li>
                        <li>再利用可能なコンポーネント設計</li>
                        <li>現代的なWeb開発の標準</li>
                    </ul>
                </section>
            </section>

            <!-- Section 1: JSX Basics -->
            <section>
                <section>
                    <h1>JSX = JavaScript + XML</h1>
                    <p>普通のHTMLから始めよう</p>
                </section>

                <section>
                    <h2>HTMLをそのまま書ける</h2>
                    <pre><code data-lang="html">&lt;div class="greeting"&gt;
  &lt;h1&gt;Hello, World!&lt;/h1&gt;
  &lt;p&gt;今日はいい天気ですね&lt;/p&gt;
&lt;/div&gt;</code></pre>
                    <div class="fragment">
                        <p>→ JSXならこれをJS関数の中に書ける</p>
                    </div>
                </section>

                <section>
                    <h2>JSXの実際</h2>
                    <pre><code data-lang="jsx">function Greeting() {
  return (
    &lt;div className="greeting"&gt;
      &lt;h1&gt;Hello, World!&lt;/h1&gt;
      &lt;p&gt;今日はいい天気ですね&lt;/p&gt;
    &lt;/div&gt;
  );
}</code></pre>
                    <div class="note">
                        <code>className</code>に注意！ <code>class</code>はJSの予約語だから
                    </div>
                </section>

                <section>
                    <h2>JSXの正体</h2>
                    <p>JSXはこれにコンパイルされる：</p>
                    <pre><code data-lang="jsx">// JSX
&lt;div className="greeting"&gt;Hello!&lt;/div&gt;

// ↓ コンパイル後
React.createElement(
  "div",
  { className: "greeting" },
  "Hello!"
);</code></pre>
                    <div class="note">つまり<strong>JSX = syntactic sugar</strong></div>
                </section>

                <section>
                    <h2>JSXのルール</h2>
                    <div class="fragment">
                        <h3>1. 必ず1つの要素を返す</h3>
                        <pre><code data-lang="jsx">// ❌ ダメ
return (
  &lt;h1&gt;Title&lt;/h1&gt;
  &lt;p&gt;Content&lt;/p&gt;
);

// ✅ OK - Fragment使用
return (
  &lt;&gt;
    &lt;h1&gt;Title&lt;/h1&gt;
    &lt;p&gt;Content&lt;/p&gt;
  &lt;/&gt;
);</code></pre>
                    </div>
                </section>

                <section>
                    <h2>JSXのルール</h2>
                    <div>
                        <h3>2. すべてのタグを閉じる</h3>
                        <pre><code data-lang="jsx">// ❌ HTML風だとダメ
&lt;br&gt;
&lt;img src="photo.jpg"&gt;
&lt;input type="text"&gt;

// ✅ 必ず閉じる
&lt;br /&gt;
&lt;img src="photo.jpg" /&gt;
&lt;input type="text" /&gt;</code></pre>
                    </div>
                </section>

                <section>
                    <h2>JSXのルール</h2>
                    <div>
                        <h3>3. camelCase属性</h3>
                        <pre><code data-lang="jsx">// ❌ HTML属性名
&lt;div class="container" onclick="handleClick()"&gt;
&lt;label for="email"&gt;

// ✅ camelCase
&lt;div className="container" onClick={handleClick}&gt;
&lt;label htmlFor="email"&gt;</code></pre>
                        <div class="note">
                            <code>class</code> → <code>className</code><br>
                            <code>for</code> → <code>htmlFor</code><br>
                            <code>onclick</code> → <code>onClick</code>
                        </div>
                    </div>
                </section>
                <section>
                    <h4>理解度チェック①【JSXルール】</h4>
                    <div class="quiz">
                        <h3>どれが正しいJSX？</h3>
                        <div class="comparison">
                            <pre><code data-lang="jsx">{ /* A */ }
&lt;div&gt;
  &lt;h1&gt;Title&lt;/h1&gt;
  &lt;p&gt;Text&lt;/p&gt;
&lt;/div&gt;

{ /* B */ }
&lt;h1&gt;Title&lt;/h1&gt;
&lt;p&gt;Text&lt;/p&gt;</code></pre>
                            <pre><code data-lang="jsx">{ /* C */ }
&lt;&gt;
  &lt;h1&gt;Title&lt;/h1&gt;
  &lt;p&gt;Text&lt;/p&gt;
&lt;/&gt;</code></pre>
                        </div>
                        <div class="quiz-options small">
                            <div class="quiz-option">A)
                                <code>&lt;div&gt;&lt;h1&gt;Title&lt;/h1&gt;&lt;p&gt;Text&lt;/p&gt;&lt;/div&gt;</code>
                            </div>
                            <div class="quiz-option">B)
                                <code>&lt;h1&gt;Title&lt;/h1&gt;&lt;p&gt;Text&lt;/p&gt;</code>
                            </div>
                            <div class="quiz-option">C)
                                <code>&lt;&gt;&lt;h1&gt;Title&lt;/h1&gt;&lt;p&gt;Text&lt;/p&gt;&lt;/&gt;</code>
                            </div>
                            <div class="quiz-option fragment custom correct-answer" data-fragment-index="1">D) AとC両方
                            </div>
                        </div>
                    </div>
                    <div class="fragment" data-fragment-index="1">
                        <div class="note">
                            <strong>答え:</strong> D) 単一の親要素またはFragment必須
                        </div>
                    </div>
                </section>
            </section>

            <!-- Section 2: JavaScript in JSX -->
            <section>
                <section>
                    <h1>JSXにJavaScriptを埋め込む</h1>
                    <p>{}で動的コンテンツ</p>
                </section>

                <section>
                    <h2>変数を表示: {}</h2>
                    <pre><code data-lang="jsx">function User({ name, email }) {
  const greeting = 'こんにちは';
  
  return (
    &lt;div&gt;
      &lt;h2&gt;{greeting}, {name}さん&lt;/h2&gt;
      &lt;p&gt;{email}&lt;/p&gt;
      &lt;p&gt;今年は{new Date().getFullYear()}年です。&lt;/p&gt;
    &lt;/div&gt;
  );
}</code></pre>
                    <div class="note"><code>{}</code>の中は普通のJavaScript式</div>
                </section>

                <section>
                    <h2>条件レンダリング: 三項演算子</h2>
                    <pre><code data-lang="jsx">function UserProfile({ user, isLoggedIn }) {
  return (
    &lt;div&gt;
      {isLoggedIn ? (
        &lt;h1&gt;Welcome {user.name}!&lt;/h1&gt;  {/* trueの場合 */}
      ) : (
        &lt;h1&gt;Please log in&lt;/h1&gt;         {/* falseの場合 */}
      )}
    &lt;/div&gt;
  );
}</code></pre>
                    <div class="note">
                        <code>condition ? trueの時 : falseの時</code><br>
                        必ず両方の場合を書く必要がある
                    </div>
                </section>

                <section>
                    <h2>条件レンダリング: && 演算子</h2>
                    <pre><code data-lang="jsx">function UserProfile({ user }) {
  return (
    &lt;div&gt;
      &lt;h1&gt;Welcome {user.name}!&lt;/h1&gt;
      {user.isAdmin && (
        &lt;div className="admin-panel"&gt;  {/* trueの時だけ表示 */}
          Admin tools
        &lt;/div&gt;
      )}
      {user.notifications.length > 0 && &lt;span&gt;You have {user.notifications.length} messages&lt;/span&gt;}
    &lt;/div&gt;
  );
}</code></pre>
                    <div class="note">
                        <code>condition && JSX</code><br>
                        falseの時は何も表示しない（elseが不要な時）
                    </div>
                </section>

                <section>
                    <h2>ERBとの比較</h2>
                    <div class="comparison">
                        <div>
                            <p>JSX:</p>
                            <pre><code data-lang="jsx">{user.loggedIn ? (
  &lt;h1&gt;Welcome {user.name}!&lt;/h1&gt;
) : (
  &lt;h1&gt;Please log in&lt;/h1&gt;
)}

{user.isAdmin && (
  &lt;div className="admin-panel"&gt;
    Admin tools
  &lt;/div&gt;
)}</code></pre>
                        </div>
                        <div>
                            <p>ERB:</p>
                            <pre><code data-lang="erb">&lt;% if user.logged_in? %&gt;
  &lt;h1&gt;Welcome &lt;%= user.name %&gt;!&lt;/h1&gt;
&lt;% else %&gt;
  &lt;h1&gt;Please log in&lt;/h1&gt;
&lt;% end %&gt;

&lt;% if user.admin? %&gt;
  &lt;div class="admin-panel"&gt;
    Admin tools
  &lt;/div&gt;
&lt;% end %&gt;</code></pre>
                        </div>
                    </div>
                    <div class="note">JSXは式だからreturnの中に直接書ける</div>
                </section>

                <section>
                    <h2>配列をレンダリング</h2>
                    <pre><code data-lang="jsx">function TodoList({ todos }) {
  return (
    &lt;ul&gt;
      {todos.map(todo =&gt; (
        &lt;li key={todo.id}&gt;
          {todo.text}
        &lt;/li&gt;
      ))}
    &lt;/ul&gt;
  );
}</code></pre>
                    <div class="note">
                        <code>key</code>は必須！Reactが効率的に更新するため
                    </div>
                </section>
                <section>
                    <h2>key属性の重要性</h2>
                    <p>リストをレンダリングする時の必須属性</p>

                    <div class="comparison">
                        <div class="comparison-item">
                            <h4>❌ keyなし</h4>
                            <pre><code data-lang="jsx">{todos.map(todo =&gt; (
  &lt;li&gt;{todo.text}&lt;/li&gt;  {/* 状態がバグる */}
))}</code></pre>
                        </div>
                        <div class="comparison-item">
                            <h4>✅ keyあり</h4>
                            <pre><code data-lang="jsx">{todos.map(todo =&gt; (
  &lt;li key={todo.id}&gt;{todo.text}&lt;/li&gt;
))}</code></pre>
                        </div>
                    </div>

                    <div class="note">
                        keyがないとリストの順序が変わった時に状態がズレる
                    </div>
                </section>

                <section>
                    <h2>良いkey vs 悪いkey</h2>
                    <div class="comparison">
                        <div class="pros">
                            <h4>✅ 良いkey</h4>
                            <ul>
                                <li><code>item.id</code> データベースID</li>
                                <li><code>user.uuid</code> 一意識別子</li>
                                <li><code>product.sku</code> 商品コード</li>
                            </ul>
                        </div>
                        <div class="cons">
                            <h4>❌ 悪いkey</h4>
                            <ul>
                                <li><code>index</code> 配列インデックス</li>
                                <li><code>Math.random()</code> 毎回変わる</li>
                                <li><code>item.name</code> 重複可能</li>
                            </ul>
                        </div>
                    </div>

                    <div class="note">
                        keyは<strong>一意で不変</strong>である必要がある
                    </div>
                </section>
                <section>
                    <h4>理解度チェック②【条件レンダリング】</h4>
                    <div class="quiz">
                        <h3>何が表示される？</h3>
                        <pre><code data-lang="jsx">function AdminPanel() {
    const user = { name: "Ichigo", isAdmin: false };

    return &lt;&gt;{user.isAdmin && &lt;div&gt;Admin Panel&lt;/div&gt;}&lt;/&gt;;
}
</code></pre>
                        <div class="quiz-options">
                            <div class="quiz-option">A) <code>&lt;div&gt;Admin Panel&lt;/div&gt;</code></div>
                            <div class="quiz-option fragment custom correct-answer" data-fragment-index="1">B) 何も表示されない
                            </div>
                            <div class="quiz-option">C) <code>false</code></div>
                            <div class="quiz-option">D) エラー</div>
                        </div>
                    </div>
                    <div class="fragment" data-fragment-index="1">
                        <div class="note">
                            <strong>答え:</strong> B) &&の左側がfalseなので右側は評価されない
                        </div>
                    </div>
                </section>
            </section>

            <!-- Section 3: Components Basics -->
            <section>
                <section>
                    <h1>コンポーネント = 関数</h1>
                    <p>再利用できるUI部品</p>
                </section>

                <section>
                    <h2>最初のコンポーネント</h2>
                    <pre><code data-lang="jsx">// これがコンポーネント
function Welcome() {
  return &lt;h1&gt;Hello, World!&lt;/h1&gt;;
}

// 使う時
function App() {
  return (
    &lt;div&gt;
      &lt;Welcome /&gt;
      &lt;Welcome /&gt;
    &lt;/div&gt;
  );
}</code></pre>
                    <div class="note">関数名は<strong>大文字で始める</strong>（HTMLタグと区別するため）</div>
                </section>

                <section>
                    <h2>コンポーネントの解剖学</h2>
                    <pre><code data-lang="jsx">// 1. 関数宣言（大文字で始める）
function UserCard() {
  // 2. ロジック（普通のJS）
  const userName = 'Kurosaki Ichigo';
  
  // 3. JSXを返す（必須）
  return (
    &lt;div className="user-card"&gt;
      &lt;h3&gt;{userName}&lt;/h3&gt;
    &lt;/div&gt;
  );
}</code></pre>
                </section>

                <section>
                    <h2>コンポーネント合成</h2>
                    <pre><code data-lang="jsx">// 小さいコンポーネント
function Avatar({ src, alt }) {
  return &lt;img src={src} alt={alt} className="avatar" /&gt;;
}

function UserName({ name }) {
  return &lt;span className="username"&gt;{name}&lt;/span&gt;;
}</code></pre>

                    <pre><code data-lang="jsx">// 合成して大きいコンポーネント
function UserProfile({ user }) {
  return (
    &lt;div className="user-profile"&gt;
      &lt;Avatar src={user.avatar} alt={user.name} /&gt;
      &lt;UserName name={user.name} /&gt;
    &lt;/div&gt;
  );
}</code></pre>
                </section>
            </section>

            <!-- Section 4: Props -->
            <section>
                <section>
                    <h1>Props = 関数の引数</h1>
                    <p>コンポーネントにデータを渡す</p>
                </section>

                <section>
                    <h2>Props基本</h2>
                    <pre><code data-lang="jsx">// 普通の関数
function greet(name, age) {
  return `こんにちは、${name}さん（${age}歳）`;
}

// Reactコンポーネント
function Greeting({ name, age }) {
  return &lt;p&gt;こんにちは、{name}さん（{age}歳）&lt;/p&gt;;
}

// 使用
&lt;Greeting name="Kurosaki Ichigo" age={15} /&gt;</code></pre>
                    <p class="note">propsは<strong>読み取り専用</strong></p>
                </section>

                <section>
                    <h2>Props受け取り方法</h2>
                    <pre><code data-lang="jsx">// 方法1: propsオブジェクトそのまま
function Greeting(props) {
  return &lt;h1&gt;Hello, {props.name}!&lt;/h1&gt;;
}

// 方法2: 分割代入（destructuring）- 推奨
function Greeting({ name, age }) {
  return &lt;h1&gt;Hello, {name}! You are {age}&lt;/h1&gt;;
}

// 方法3: デフォルト値
function Greeting({ name = "Guest", age = 0 }) {
  return &lt;h1&gt;Hello, {name}! You are {age}&lt;/h1&gt;;
}</code></pre>
                </section>

                <section>
                    <h2>children prop</h2>
                    <pre><code data-lang="jsx">// Cardコンポーネント
function Card({ title, children }) {
  return (
    &lt;div className="card"&gt;
      &lt;h2&gt;{title}&lt;/h2&gt;
      &lt;div className="card-content"&gt;
        {children}
      &lt;/div&gt;
    &lt;/div&gt;
  );
}</code></pre>

                    <pre><code data-lang="jsx">// 使用方法
&lt;Card title="Profile"&gt;
  &lt;p&gt;This goes into children&lt;/p&gt;
  &lt;button&gt;Edit Profile&lt;/button&gt;
&lt;/Card&gt;</code></pre>
                    <div class="note">children = タグで囲んだ中身すべて</div>
                </section>

                <section>
                    <h2>イベントハンドラー</h2>
                    <pre><code data-lang="jsx">function Button({ onClick, children }) {
  return (
    &lt;button onClick={onClick}&gt;
      {children}
    &lt;/button&gt;
  );
}</code></pre>

                    <pre><code data-lang="jsx">// 使用
function App() {
  const handleClick = () => alert('クリック！');
  
  return (
    &lt;Button onClick={handleClick}&gt;
      クリックして
    &lt;/Button&gt;
  );
}</code></pre>
                </section>
                <section>
                    <h2>Props vs Rails partials</h2>
                    <div class="comparison">
                        <div>
                            <p>Reactのcomponent:</p>
                            <pre><code data-lang="jsx">&lt;UserCard 
  name={user.name}
  email={user.email} 
  isAdmin={true} /&gt;</code></pre>
                        </div>
                        <div>
                            <p>Railsのpartial:</p>
                            <pre><code data-lang="erb">&lt;%= render 'user_card', 
    user: @user, 
    show_admin: true %&gt;</code></pre>
                        </div>
                    </div>
                    <div class="note">props = partial variables みたいなもの</div>
                </section>
                <section>
                    <h4>理解度チェック③【Props】</h4>
                    <div class="quiz">
                        <h3>childrenには何が入る?</h3>
                        <pre><code data-lang="jsx">function Card({ title, children }) {
    return (
        &lt;div&gt;
            &lt;h2&gt;{title}&lt;/h2&gt;
            {children}
        &lt;/div&gt;
    );
}</code></pre>
                        <pre><code data-lang="jsx">
&lt;Card title="Profile"&gt;
    &lt;p&gt;Content here&lt;/p&gt;
&lt;/Card&gt;
</code></pre>
                        <div class="quiz-options small">
                            <div class="quiz-option">A) <code>Content here</code></div>
                            <div class="quiz-option">B)
                                <code>&lt;div&gt;&lt;h2&gt;{title}&lt;/h2&gt;Content here&lt;/div&gt;</code>
                            </div>
                            <div class="quiz-option fragment custom correct-answer" data-fragment-index="1">C)
                                <code>&lt;p&gt;Content here&lt;/p&gt;</code>
                            </div>
                            <div class="quiz-option">D) <code>&lt;h2&gt;Profile&lt;/h2&gt;Content here</code></div>
                        </div>
                    </div>
                    <div class="fragment" data-fragment-index="1">
                        <div class="note">
                            <strong>答え:</strong> C) <code>children</code>はコンポーネントの開始・終了タグの間の要素
                        </div>
                    </div>
                </section>
            </section>

            <!-- Debugging Tips -->
            <section>
                <section>
                    <h1>Reactデバッグ術</h1>
                    <p>バグと戦うための武器</p>
                </section>

                <section>
                    <h2>武器1: React Developer Tools</h2>
                    <div class="tool-intro">
                        <p><strong>ブラウザ拡張機能</strong> - Reactの状態を可視化</p>
                        <ul>
                            <li>Chrome/Firefox/Edge対応</li>
                            <li>コンポーネントツリー表示</li>
                            <li>Props/State監視</li>
                            <li>パフォーマンス分析</li>
                        </ul>
                    </div>

                    <div class="note">
                        開発者ツールにReactタブが追加される
                    </div>
                </section>

                <section>
                    <h2>武器2: console.log in JSX</h2>
                    <pre><code data-lang="jsx">function TodoItem({ todo }) {
  console.log('TodoItem rendered:', todo);  // 基本のログ
  
  return (
    &lt;li&gt;
      {console.log('Rendering todo text:', todo.text) || null}
      {todo.text}
      {/* デバッグ表示 */}
      &lt;pre style={{ fontSize: '10px', background: '#f0f0f0' }}&gt;
        {JSON.stringify(todo, null, 2)}
      &lt;/pre&gt;
    &lt;/li&gt;
  );
}</code></pre>

                    <div class="note">
                        JSX内でconsole.logする場合は<code>|| null</code>で戻り値を無効化
                    </div>
                </section>

                <section>
                    <h2>デバッグフロー</h2>
                    <ol>
                        <li><strong>エラーメッセージを読む</strong></li>
                        <li><strong>console.logで確認</strong> 値の存在確認</li>
                        <li><strong>React DevToolsで状態確認</strong> props/state監視</li>
                        <li><strong>コンポーネントを分割</strong> 問題箇所の特定</li>
                        <li><strong>最小再現例を作成</strong> 不要なコードを削除</li>
                    </ol>

                    <div class="note">
                        慌てず騒がず、一歩ずつ問題を切り分ける
                    </div>
                </section>
            </section>

            <!-- Practice -->
            <section>
                <section>
                    <h1>React 実践演習</h1>
                    <h3>1つの課題 (15-20分)</h3>

                    <p>今日学んだ内容を実際に使ってみよう！</p>
                    <div class="note"><a
                            href="https://github.com/cdefined/front-kaizen/blob/master/react-lessons/lesson_1/task.md">react-lessons/lesson_1/task.md</a>
                    </div>
                </section>
                <section>
                    <h3>セットアップ手順</h3>
                    <ol>
                        <li>masterブランチに切り替え、更新を取得する
                            <pre><code data-lang="bash">git switch master
git pull origin main</code></pre>
                        </li>
                        <li>パッケージをインストールする
                            <pre><code data-lang="bash">cd react-lessons/
npm install</code></pre>
                        </li>
                        <li>開発サーバーを起動する
                            <pre><code data-lang="bash">npm run dev</code></pre>
                        </li>
                        <li>ブラウザで「<a href="http://localhost:5173/">http://localhost:5173/</a>」を開く</li>
                    </ol>
                    <div class="note"><a
                            href="https://github.com/cdefined/front-kaizen/blob/master/react-lessons/lesson_1/task.md">react-lessons/lesson_1/task.md</a>
                    </div>
                </section>

                <!-- Task 1 -->
                <section>
                    <div class="timer"></div>

                    <h2><span class="task-number">課題1</span> Props付きのコンポーネント</h2>

                    <p><strong><code>&lt;ZanpakutoCard&gt;</code> コンポーネントを作成してください</strong></p>
                    <ul>
                        <li><code>zanpakuto</code> オブジェクトを <strong>Props</strong> として受け取る</li>
                        <li>以下のプロパティをすべて表示すること:
                            <ul>
                                <li><code>name</code>, <code>owner</code>, <code>type</code>, <code>bankai</code>,
                                    <code>shikaiAbility</code>, <code>powerLevel</code>, <code>isReleased</code>
                                </li>
                            </ul>
                        </li>
                        <li><code>bankai</code> は存在する場合のみ表示</li>
                    </ul>

                    <pre><code data-lang="typescript">export interface Zanpakuto {
  name: string;
  owner: string;
  type: "melee" | "kido" | "elemental" | "illusion";
  bankai?: string;
  shikaiAbility: string;
  powerLevel: number;
  isReleased: boolean;
}
    </code></pre>

                    <div class="note"><a
                            href="https://github.com/cdefined/front-kaizen/blob/master/react-lessons/lesson_1/task.md">react-lessons/lesson_1/task.md</a>
                    </div>
                </section>
                <section>
                    <h2><span class="task-number">課題1</span> 解答例</h2>
                    <p><code>props</code> を受け取って全てのプロパティを表示する</p>
                    <pre><code data-lang="tsx">function ZanpakutoCard({ zanpakuto }: { zanpakuto: Zanpakuto }) {
  const { name, owner, type, bankai, shikaiAbility, powerLevel, isReleased } = zanpakuto;  // 分割代入でプロパティを展開
  
  return (
    &lt;div&gt;
      &lt;h2&gt;{name}（{owner}の斬魄刀）&lt;/h2&gt; {/* JSXでは{}内にJavaScript式を書ける */}
      &lt;p&gt;タイプ: {type}&lt;/p&gt;
      {bankai && &lt;p&gt;卍解: {bankai}&lt;/p&gt;} {/* 条件付きレンダリングの&&演算子：左側がtruthyの場合、右側を実行 */}
      &lt;p&gt;始解能力: {shikaiAbility}&lt;/p&gt;
      &lt;p&gt;霊圧レベル: {powerLevel}&lt;/p&gt;
      &lt;p&gt;解放済み: {isReleased ? "はい" : "いいえ"}&lt;/p&gt; {/* 三項演算子 - 条件 ? 真の場合 : 偽の場合 */}
    &lt;/div&gt;
  );
}</code></pre>
                </section>
            </section>

            <section>
                <!-- Summary -->
                <section>
                    <h1>第1回まとめ</h1>

                    <h2>今日学んだこと</h2>
                    <ul>
                        <li><strong>Reactとは</strong> UIライブラリ、仮想DOM、宣言的プログラミング</li>
                        <li><strong>JSX</strong> JavaScript + XML、{}で動的コンテンツ</li>
                        <li><strong>コンポーネント</strong> 再利用可能なUI部品（関数）</li>
                        <li><strong>Props</strong> コンポーネント間のデータ受け渡し</li>
                        <li><strong>条件レンダリング</strong> 三項演算子、&&演算子</li>
                    </ul>
                </section>

                <!-- In next episode -->
                <section>
                    <h1>次回予告</h1>
                    <p><strong>React②:</strong> useState、イベント処理、フォーム</p>
                </section>
            </section>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/reveal.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/plugin/notes/notes.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/plugin/markdown/markdown.min.js"></script>
    <script src="../../scripts/reveal-timer-plugin.js"></script>
    <script type="module">
        import { codeToHtml } from 'https://esm.sh/shiki@3.0.0';

        const codeBlocks = document.querySelectorAll('pre code[data-lang]');

        for (const block of codeBlocks) {
            const lang = block.dataset.lang;
            const theme = block.dataset.theme || 'night-owl'; // 'material-theme-darker'
            const rawCode = block.textContent.trim();

            const html = await codeToHtml(rawCode, { lang, theme });

            const wrapper = document.createElement('div');
            wrapper.innerHTML = html;
            const shikiHTML = wrapper.firstElementChild;

            const pre = block.closest('pre');
            if (pre && shikiHTML) pre.replaceWith(shikiHTML);
        }
    </script>

    <script>
        Reveal.initialize({
            hash: true,
            slideNumber: true,
            width: 1800,
            height: 900,
            margin: 0.1,
            transition: 'slide',
            transitionSpeed: 'fast',
            backgroundTransition: 'fade',
            plugins: [RevealNotes, RevealTimer, RevealMarkdown],
            highlight: {
                escapeHTML: true
            }
        });
    </script>
</body>

</html>