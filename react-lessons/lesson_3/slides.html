<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta lang="ja">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>React 応用①</title>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/reveal.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/theme/black.min.css">
    <style>
        :root {
            --main-header: #667eea;
            --green: #27ae60;
            --yellow: #f39c12;
            --red: #fc5342;
            --bg: #f8f8f810;
        }

        .reveal {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        .reveal h1,
        .reveal h2,
        .reveal h3,
        .reveal h4 {
            color: var(--main-header);
            text-transform: none;
        }

        .reveal h4,
        .reveal h3 {
            margin-bottom: 0;
        }

        .reveal .pale {
            opacity: 0.9;
            font-size: 1em;
        }

        .reveal .slides section {
            text-align: left;
        }

        .reveal .title-slide {
            text-align: center;
        }

        .reveal .code-wrapper code {
            font-size: 1.3em;
        }

        .reveal .code-wrapper .font-smaller {
            font-size: 1.19em;
        }

        .reveal .code-wrapper .font-smaller-small {
            font-size: 1.1em;
        }

        .reveal .code-wrapper .code-small,
        .code-small {
            font-size: 0.9em;
        }

        .code-small .code-wrapper {
            width: 100%;
        }

        ul>li,
        dl>dd {
            line-height: 2em;
        }

        ul.compact-list>li,
        dl.compact-list>dd {
            line-height: 1.5em;
        }

        dd {
            margin-bottom: 0.5em;
        }

        .arrow {
            background: none;
            font-size: 100px;
            color: var(--main-header);
            flex: 0;
        }

        .down-arrow {
            opacity: 0.7;
            display: flex;
            justify-content: center;
            font-size: 50px;
            flex: 0;
        }

        .comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            justify-content: start;
        }

        .comparison.centered {
            align-items: center;
        }

        .triptych {
            display: flex;
            justify-content: space-between;
            align-items: start;
            gap: 1em;
        }

        .triptych.centered {
            justify-content: center;
        }

        .triptych-transformation {
            display: flex;
            justify-content: start;
            align-items: center;
            gap: 20px;
        }

        .note {
            background: rgba(52, 152, 219, 0.2);
            border-left: 4px solid var(--main-header);
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .warning {
            background: rgba(231, 76, 60, 0.2);
            border-left: 4px solid var(--red);
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .quiz {
            background: rgba(46, 204, 113, 0.1);
            border-left: 4px solid var(--green);
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
        }

        .quiz-options {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr 1fr;
            gap: 10px;
        }

        .quiz-option {
            display: block;
            padding: 8px 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .quiz-option:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .quiz-options.small {
            font-size: 0.65em;
        }

        .fragment.correct-answer.visible {
            border-left: 4px solid #2ecc71;
            background: rgba(46, 204, 113, 0.3);
        }

        .reveal pre {
            width: 100%;
            margin-top: 10px;
        }

        .reveal pre code {
            padding: 1em;
        }

        .timer {
            position: absolute;
            top: -30px;
            right: 15px;
        }

        .comparison-table {
            font-size: 0.75em;
            border-collapse: collapse;
            width: 100%;
            margin: 1rem 0;
        }

        .comparison-table th,
        .comparison-table td {
            padding: 0.6rem 0.4rem;
            text-align: center;
        }

        .comparison-table thead th {
            font-weight: bold;
        }

        .comparison-table .metric {
            font-weight: bold;
            text-align: left;
        }

        .mpa-spa {
            border-radius: 8px;
            padding: 1.5rem;
            border-top: 4px solid var(--main-header);
            background: var(--bg);

            h3,
            p {
                text-align: center;
            }

            ol {
                font-size: 0.93em;
                width: 100%;
                padding-left: 0;
                margin: 0;
            }

            li {
                list-style-position: inside;
                background: #667eea15;
                color: white;
                padding: 0.75rem 1.5rem;
                margin: 0.75rem 0;
                border-radius: 4px;
            }
        }

        .lifecycle {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 2rem;
            margin-top: 2rem;

            div {
                border-radius: 8px;
                padding: 1.5rem;
                border-top: 4px solid;
                border-left: 4px solid;
                background: var(--bg);
            }

            p {
                text-align: center;
            }

            p,
            ul {
                font-size: 0.9em;
            }

            ol {
                font-size: 0.8em;
                margin: 0 5px;
            }

            ol>li {
                line-height: 2em;
            }

            .mount {
                position: relative;
                border-color: var(--green);

                h3 {
                    color: var(--green);
                    text-align: center;
                }
            }

            .mount::after,
            .update::after {
                content: "🡆";
                position: absolute;
                top: 50%;
                right: -36px;
                color: #f8f8f8b0;
                font-size: 45px;
                font-weight: bold;
            }

            .update {
                position: relative;
                border-color: var(--yellow);

                h3 {
                    color: var(--yellow);
                    text-align: center;
                }
            }

            .update::before {
                content: '⭯';
                position: absolute;
                top: -20px;
                right: -10px;
                background: var(--yellow);
                color: white;
                width: 105px;
                height: 105px;
                border-radius: 50%;
                display: flex;
                align-items: flex-start;
                justify-content: center;
                font-size: 75px;
                font-weight: bold;
            }

            .unmount {
                border-color: var(--red);

                h3 {
                    color: var(--red);
                    text-align: center;
                }
            }
        }

        .four-square {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 2rem;
            margin-top: 2rem;

            div {
                border-radius: 8px;
                padding: 1.5rem;
                background: #f8f8f810;
                font-size: 0.9em;
            }
        }

        .four-square.centered {
            h3 {
                text-align: center;
            }
        }

        .part,
        .pattern {
            border-radius: 8px;
            padding: 0.5rem;
            background: var(--bg);

            pre {
                margin: 0;
            }
        }

        .part {
            margin-top: 0.5em;
            padding: 0.75rem;
        }

        .pattern {
            margin-bottom: 0.5em;
            font-size: 0.9em;
        }

        .split {
            display: grid;
            grid-template-columns: 1.2fr 2fr;
            gap: 20px;
            align-items: center;
        }

        .centered {
            text-align: center;
        }

        .reveal .success {
            color: var(--green);
            padding: 0.75rem;
            border-radius: 4px;
            text-align: center;
        }

        .reveal .error {
            color: var(--red);
            padding: 0.75rem;
            border-radius: 4px;
            text-align: center;
        }

        .list-flow {
            font-size: 0.8em;
            padding: 0;
        }

        .flow-diagram {
            font-size: 0.65em;
            display: flex;
            flex-direction: column;
            gap: 0;

            .part {
                margin: 0;
                text-align: center;
            }

            .flow-arrow::after {
                content: "🡇";
                position: relative;
                top: 0;
                left: 50%;
                color: #f8f8f890;
                font-size: 30px;
            }
        }

        .font-smaller {
            font-size: 0.9em;
        }

        .muted {
            color: #bebebe;
            font-size: 0.8em;
        }

        .split-triptych {
            display: grid;
            align-items: center;
            gap: 1em;
            grid-template-columns: 1fr 3fr 3fr;
            margin: 1.5em 0;
        }
    </style>
</head>

<body>
    <div class="reveal">
        <div class="slides">
            <section class="title-slide">
                <h1>React 応用①</h1>
                <h2>useEffect、SPA</h2>
            </section>

            <!-- In previous episode -->
            <section>
                <section>
                    <h1>前回の復習</h1>
                    <p>React基礎②のおさらい</p>
                    <aside class="notes">まず、<ruby>前回<rt>ぜんかい</rt></ruby>の<ruby>内容<rt>ないよう</rt></ruby>を<ruby>確認<rt>かくにん
                            </rt></ruby>します。<br>
                        わからないところがあったら<ruby>質問<rt>しつもん</rt></ruby>してください。</aside>
                </section>

                <section>
                    <h2>JSX = JavaScript + HTML風の文法</h2>
                    <div class="syntax-review">
                        <pre><code data-lang="jsx">// 変数の表示
const name = "Ichigo";
&lt;h1&gt;Hello, {name}!&lt;/h1&gt;</code></pre>
                        <pre><code data-lang="jsx">
// 条件表示
{isLoggedIn ? &lt;Profile /&gt; : &lt;Login /&gt;}
{user.isAdmin && &lt;AdminPanel /&gt;}
</code></pre>
                        <pre><code data-lang="jsx">
// リスト表示  
{todos.map(todo =&gt; 
  &lt;li key={todo.id}&gt;{todo.text}&lt;/li&gt;
)}</code></pre>
                    </div>

                    <div class="note">
                        <code>{}</code>でJavaScript、<code>key</code>は必須
                    </div>
                    <aside class="notes">
                        ReactではJSXという<ruby>特別<rt>とくべつ</rt></ruby>な<ruby>文法<rt>ぶんぽう</rt></ruby>を<ruby>使<rt>つ</rt>
                        </ruby>います。<br>
                        jsxはhtmlみたいな<ruby>文法<rt>ぶんぽう</rt></ruby>をjavascriptで<ruby>使<rt>つか</rt></ruby>えます。<br>
                        <ruby>波格好<rt>なみかっこ</rt></ruby>を<ruby>使<rt>つか</rt></ruby>ってjavascriptを<ruby>書<rt>か</rt>
                        </ruby>きます。
                    </aside>
                </section>

                <section>
                    <h2>コンポーネント = 関数</h2>
                    <div class="syntax-review">
                        <pre><code data-lang="jsx">// コンポーネント定義（大文字で開始）
function UserCard({ name, email, children }) {
  return (
    &lt;div className="card"&gt;
      &lt;h3&gt;{name}&lt;/h3&gt;
      &lt;p&gt;{email}&lt;/p&gt;
      {children}
    &lt;/div&gt;
  );
}</code></pre>
                        <pre><code data-lang="jsx">
// 使用
&lt;UserCard name="Kurotsuchi Mayuri" email="m.kurotsuchi@seireitei.co.jp"&gt;
  &lt;button&gt;編集&lt;/button&gt;
&lt;/UserCard&gt;</code></pre>
                    </div>

                    <div class="note">
                        <code>props</code> = 関数の引数、<code>children</code> = タグの中身
                    </div>
                    <aside class="notes">
                        Reactの<ruby>コンポーネント</ruby>は<ruby>関数<rt>かんすう</rt></ruby>として<ruby>書<rt>か</rt>
                        </ruby>きます。<br><ruby>名前<rt>なまえ</rt></ruby>は<ruby>必<rt>かなら</rt></ruby>ず<ruby>大文字<rt>おおもじ</rt>
                        </ruby>から<ruby>始<rt>はじ</rt></ruby>めます。<br>
                        この<ruby>関数<rt>かんすう</rt></ruby>は、<ruby>props<rt>プロップス</rt></ruby>という<ruby>データ</ruby>を<ruby>受<rt>う
                            </rt>
                        </ruby>け<ruby>取<rt>と</rt></ruby>って、<ruby>JSX</ruby>を<ruby>返<rt>かえ</rt></ruby>します。
                    </aside>
                </section>

                <section>
                    <h2>イベント処理</h2>
                    <div class="fragment" data-fragment-index="0">
                        <p>Reactでは、イベントハンドラーはJSXの属性として指定されます</p>
                        <pre><code data-lang="jsx">// ボタンクリックの基本
const handleClick = () => {
  alert('押したよ！');
};

return &lt;button onClick={handleClick}&gt;押す&lt;/button&gt;;</code></pre>
                    </div>
                    <div class="fragment" data-fragment-index="1">
                        <pre><code data-lang="jsx">
// 複数ボタン + データ渡し
const characters = ['Rena', 'Satoko', 'Rika'];
return (
  &lt;div&gt;
    {characters.map(name => (
      &lt;button key={name} onClick={() => handleSelect(name)}&gt;
        {name}
      &lt;/button&gt;
    ))}
  &lt;/div&gt;
);</code></pre>
                    </div>
                    <div class="note fragment" data-fragment-index="1">
                        イベントハンドラーは関数を直接渡す、アロー関数で引数を渡すことも可能
                    </div>
                    <aside class="notes">ユーザーの<ruby>操作<rt>そうさ</rt>
                        </ruby>に<ruby>反応<rt>はんのう</rt></ruby>するためにイベント<ruby>処理<rt>しょり</rt></ruby>を<ruby>使<rt>つか
                            </rt></ruby>います。<br>
                        イベントハンドラーは<ruby>関数<rt>かんすう</rt></ruby>を<ruby>直接<rt>ちょくせつ</rt></ruby><ruby>渡<rt>わた</rt>
                        </ruby>します。<br>
                        <ruby>引数<rt>ひきすう</rt></ruby>を<ruby>渡<rt>わた</rt></ruby>したい<ruby>場合<rt>ばあい</rt></ruby>はアロー<ruby>関数
                            <rt>かんすう</rt>
                        </ruby>を<ruby>使<rt>つか</rt></ruby>います。
                    </aside>
                </section>

                <section>
                    <h2>ステート = 再レンダリングを引き起こす変数</h2>
                    <h4 class="fragment" data-fragment-index="0">状態管理【useState】</h4>
                    <div class="fragment" data-fragment-index="0">
                        <pre><code data-lang="jsx">import { useState } from 'react'; // フックをインポート</code></pre>
                    </div>
                    <div class="fragment triptych-transformation" data-fragment-index="1">
                        <pre><code data-lang="jsx">// 基本構文
const [likes, setLikes] = useState(0); // 初期値は0

// 数値の更新
setLikes(likes + 1);           // 現在の値を使って直接更新
setLikes(prev => prev + 1);    // 前の値を使って関数で安全に更新</code></pre>
                        <div class="arrow">↔</div>
                        <pre><code data-lang="jsx">// 配列の分割代入なし版
const likesState = useState(0); 

// likesState[0] = 現在値
// likesState[1] = セッター関数
likesState[1](likesState[0] + 1);</code></pre>
                    </div>
                    <div class="fragment" data-fragment-index="2">
                        <pre><code data-lang="jsx">
// オブジェクトの更新
const [user, setUser] = useState({ name: 'Ichigo', age: 17 });
setUser({...user, age: 18}); // スプレッド構文で既存保持

// 配列の更新  
const [items, setItems] = useState(['bat', 'knife']);
setItems([...items, 'nata']); // 新しい配列を作成</code></pre>
                    </div>

                    <div class="note fragment" data-fragment-index="2">
                        必ずセッター関数を使用、オブジェクト/配列は新しく作成
                    </div>
                    <aside class="notes">useStateは<ruby>状態<rt>じょうたい</rt></ruby>を<ruby>管理<rt>かんり</rt>
                        </ruby>するreactの<ruby>機能<rt>きのう</rt></ruby>です。<br>
                        <ruby>直接<rt>ちょくせつ</rt></ruby><ruby>変更<rt>へんこう</rt></ruby>するとreactが<ruby>気<rt>き</rt>
                        </ruby>づかないことがあるため、<br>
                        <ruby>オブジェクト</ruby>や<ruby>配列<rt>はいれつ</rt></ruby>は<ruby>新<rt>あたら</rt></ruby>しく<ruby>作成<rt>さくせい
                            </rt></ruby>してください。
                    </aside>
                </section>

                <section>
                    <h2>制御されたコンポーネント【Controlled Component】</h2>

                    <div class="comparison">
                        <div class="fragment">
                            <h4>基本構造</h4>
                            <pre><code data-lang="jsx">// 3つの要素が必須
const [value, setValue] = useState('');        // 1. 状態

return (
  &lt;input 
    value={value}                              // 2. input要素
    onChange={(e) => setValue(e.target.value)} // 3. ハンドラー関数
  /&gt;
);</code></pre>
                        </div>

                        <div class="fragment">
                            <h4>重要なポイント</h4>
                            <ul class="compact-list">
                                <li><code>value</code>は必ずstate由来</li>
                                <li><code>onChange</code>でstateを更新</li>
                                <li>状態変更 → 再レンダリング</li>
                                <li>Reactが完全に制御</li>
                            </ul>
                        </div>
                    </div>

                    <div class="note fragment">
                        ・「Controlled」では、Reactが状態を管理します<br>
                        ・「Uncontrolled」では、Reactが状態を知らない、DOMに任せます
                    </div>
                    <aside class="notes">
                        <ruby>制御<rt>せいぎょ</rt></ruby>されたコンポーネントは、Reactが<ruby>入力値<rt>あたい</rt></ruby>を<ruby>状態<rt>じょうたい
                            </rt></ruby><ruby>経由<rt>けいゆ</rt></ruby>で<ruby>一元管理<rt>いちげんかんり</rt></ruby>するしくみ。<br>
                        ユーザーが<ruby>入力<rt>にゅうりょく</rt></ruby>するとonChangeイベントが<ruby>発火<rt>はっか</rt></ruby>して、Stateが<ruby>更新
                            <rt>こうしん</rt>
                        </ruby>される。<br>
                        inputの<ruby>表示<rt>ひょうじ</rt></ruby><ruby>値<rt>あたい</rt></ruby>は<ruby>常<rt>つね</rt>
                        </ruby>にStateに<ruby>依存<rt>いぞん</rt></ruby>。<br>
                        この<ruby>構造<rt>こうぞう</rt></ruby>により、<ruby>検証<rt>けんしょう</rt></ruby>や<ruby>制御<rt>せいぎょ</rt>
                        </ruby>が<ruby>容易<rt>ようい</rt></ruby>になる。
                    </aside>
                </section>
            </section>

            <!-- SPA Introduction -->
            <section>
                <section>
                    <h1>シングルページアプリ【SPA】</h1>
                    <p>SPAとは、従来のWebアプリとの違い</p>
                </section>
                <section>
                    <h2>SPAの基本概念</h2>
                    <div class="spa-concept">
                        <h3 class="fragment">シングルページアプリケーション = 単一HTMLファイル</h3>
                        <ul class="fragment">
                            <li>アプリケーション全体が<strong>1つの<code>index.html</code></strong>から始まる</li>
                            <li>ページ遷移時も<strong>同じHTMLファイル内</strong>で完結</li>
                            <li><strong>JavaScript</strong>がDOMを直接操作してコンテンツを切り替える</li>
                            <li>URLが変わる場合もあるが、実際には<strong>ページリロードしない</strong></li>
                        </ul>
                    </div>

                    <div class="example fragment">
                        <pre><code data-lang="html">
<!-- 最初から最後まで、このHTMLファイル1つだけ -->
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;React App&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id="root"&gt;&lt;/div&gt; &lt;!-- ここにReactがコンテンツを描画 --&gt;
    &lt;script src="bundle.js"&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
                    </div>
                    <aside class="notes">
                        SPAは「シングルページアプリケーション」の<ruby>略<rt>りゃく</rt></ruby>です。<br>
                        <ruby>普通<rt>ふつう</rt></ruby>のWebサイトは<ruby>複数<rt>ふくすう</rt></ruby>のHTMLファイルがありますが、<br>
                        SPAは1つのHTMLファイルだけを<ruby>使<rt>つか</rt></ruby>います。<br>
                        ページを<ruby>移動<rt>いどう</rt></ruby>してもHTMLファイルは<ruby>変<rt>か</rt></ruby>わりません。<br>
                        JavaScriptが<ruby>画面<rt>がめん</rt></ruby>の<ruby>内容<rt>ないよう</rt></ruby>を<ruby>変更<rt>へんこう</rt>
                        </ruby>します。
                    </aside>
                </section>

                <section>
                    <h2>SPAのファイル構造イメージ</h2>
                    <div class="comparison">
                        <div class="fragment">
                            <h4>従来のWebサイト</h4>
                            <pre><code>
website/
├── index.html      ← ホーム
├── about.html      ← 概要ページ  
├── contact.html    ← お問い合わせ
├── products.html   ← 商品一覧
└── ...
</code></pre>
                            <p class="note">各ページ = 別々のHTMLファイル</p>
                        </div>

                        <div class="fragment">
                            <h4>SPA</h4>
                            <pre><code>
react-app/
├── index.html      ← これ1つだけ！
├── app.jsx         ← React アプリケーション
├── styles.css
├── components/
└── ...
</code></pre>
                            <p class="note">全ページ = 1つのHTMLファイル内で切り替え</p>
                        </div>
                    </div>
                    <aside class="notes">
                        <ruby>従来<rt>じゅうらい</rt></ruby>のWebサイトは<ruby>各<rt>かく</rt></ruby>ページに<ruby>別<rt>べつ</rt>
                        </ruby>のHTMLファイルが<ruby>必要<rt>ひつよう</rt></ruby>です。<br>
                        SPAは<ruby>最初<rt>さいしょ</rt></ruby>のindex.htmlだけを<ruby>使<rt>つか</rt></ruby>います。<br>
                        React、Vue、Angularなどがこの<ruby>方式<rt>ほうしき</rt></ruby>を<ruby>使<rt>つか</rt></ruby>っています。<br>
                        <ruby>開発<rt>かいはつ</rt></ruby><ruby>時<rt>じ</rt></ruby>はファイルが<ruby>分<rt>わ</rt>
                        </ruby>かれていても、<ruby>最終的<rt>さいしゅうてき</rt></ruby>に1つにまとまります。
                    </aside>
                </section>

                <section>
                    <h2>従来のWebアプリ vs SPA</h2>
                    <div class="comparison">
                        <div class="mpa-spa fragment">
                            <h3>マルチページアプリ【MPA】</h3>
                            <p>複数のHTMLファイル</p>
                            <ol>
                                <li>ユーザーがリンクをクリック</li>
                                <li>ブラウザが<strong>新しいHTMLファイル</strong>を要求</li>
                                <li>サーバーが<strong>完全な別ページ</strong>を送信</li>
                                <li>ブラウザが古いページを破棄</li>
                                <li>新しいページを描画</li>
                                <li><strong>画面のフラッシュ/再読み込み</strong></li>
                            </ol>
                        </div>

                        <div class="mpa-spa fragment">
                            <h3>シングルページアプリ【SPA】</h3>
                            <p>単一のHTMLファイル</p>
                            <ol>
                                <li>ユーザーがリンクをクリック</li>
                                <li>JavaScriptがクリックを検知</li>
                                <li>必要なデータのみをAPI経由で取得</li>
                                <li>Reactが<strong>同じページ内のDOM</strong>で変更部分のみを更新</li>
                                <li><strong>瞬間的なページ遷移</strong></li>
                            </ol>
                        </div>
                    </div>
                    <aside class="notes">
                        MPAは「マルチページアプリ」の<ruby>略<rt>りゃく</rt></ruby>です。<br>
                        <ruby>従来<rt>じゅうらい</rt></ruby>の<ruby>方法<rt>ほうほう</rt></ruby>では<ruby>新<rt>あたら</rt>
                        </ruby>しいページを<ruby>読<rt>よ</rt></ruby>み<ruby>込<rt>こ</rt></ruby>むとき、<br>
                        <ruby>画面<rt>がめん</rt></ruby>が<ruby>一瞬<rt>いっしゅん</rt></ruby><ruby>白<rt>しろ</rt></ruby>くなります。<br>
                        SPAはページ<ruby>遷移<rt>せんい</rt></ruby>が<ruby>速<rt>はや</rt></ruby>くて、アプリみたいに<ruby>感<rt>かん</rt>
                        </ruby>じます。<br>
                        YouTubeやメルカリもSPAの<ruby>技術<rt>ぎじゅつ</rt></ruby>を<ruby>使<rt>つか</rt></ruby>っています。
                    </aside>
                </section>

                <section>
                    <h2>コード例：ページ遷移の違い</h2>
                    <div class="comparison">
                        <div>
                            <h4>従来のWebアプリ</h4>
                            <p>ブラウザがHTMLファイルを切り替え</p>
                            <pre><code data-lang="html">
&lt;!-- about.html という別ファイルに移動 --&gt;
&lt;a href="/about.html"&gt;概要&lt;/a&gt;

&lt;!-- contact.html という別ファイルに移動 --&gt;
&lt;a href="/contact.html"&gt;お問い合わせ&lt;/a&gt;</code></pre>
                        </div>
                        <div>
                            <h4>SPA</h4>
                            <p>JavaScriptでコンテンツを切り替え</p>
                            <pre><code data-lang="jsx">
// 表示するコンテンツを状態で管理
const [currentPage, setCurrentPage] = useState('home');

const showAbout = () => {
  setCurrentPage('about'); // DOMを書き換え
}

// 条件分岐でコンテンツを切り替え
{currentPage === 'home' && &lt;HomeContent /&gt;}
{currentPage === 'about' && &lt;AboutContent /&gt;}</code></pre>
                        </div>
                    </div>
                    <p class="note">実際にはルーティングライブラリを使用することが多い</p>
                    <aside class="notes">
                        <ruby>実際<rt>じっさい</rt></ruby>のSPAではReact Routerなどのライブラリを<ruby>使<rt>つか</rt></ruby>います。<br>
                        この<ruby>例<rt>れい</rt></ruby>は<ruby>簡単<rt>かんたん</rt></ruby>にするために<ruby>基本的<rt>きほんてき</rt>
                        </ruby>な<ruby>書<rt>か</rt></ruby>き<ruby>方<rt>かた</rt></ruby>です。<br>
                        <ruby>状態<rt>じょうたい</rt></ruby>を<ruby>使<rt>つか</rt></ruby>ってどのコンテンツを<ruby>表示<rt>ひょうじ</rt>
                        </ruby>するか<ruby>決<rt>き</rt></ruby>めます。<br>
                        URLも<ruby>同時<rt>どうじ</rt></ruby>に<ruby>変更<rt>へんこう</rt></ruby>することができます。
                    </aside>
                </section>

                <section>
                    <h2>SPAの注意点</h2>
                    <div class="comparison">
                        <div class="pros">
                            <h4>メリット</h4>
                            <ul>
                                <li>高速なページ遷移</li>
                                <li>アプリ風UX</li>
                                <li>サーバー負荷軽減</li>
                            </ul>
                        </div>
                        <div class="cons">
                            <h4>懸念点</h4>
                            <ul>
                                <li>初回ロードが重い</li>
                                <li>SEOが困難</li>
                                <li>JavaScriptが必須</li>
                            </ul>
                        </div>
                    </div>
                    <aside class="notes">
                        SPAは<ruby>最初<rt>さいしょ</rt></ruby>にすべてのJavaScriptをダウンロードするため、<br>
                        <ruby>初回<rt>しょかい</rt></ruby>のロード<ruby>時間<rt>じかん</rt></ruby>が<ruby>長<rt>なが</rt>
                        </ruby>くなることがあります。<br>
                        SEOは「Search Engine Optimization」の<ruby>略<rt>りゃく</rt></ruby>です。<br>
                        GoogleやYahooなどの<ruby>検索<rt>けんさく</rt></ruby>に<ruby>引<rt>ひ</rt></ruby>っかかりにくい<ruby>問題<rt>もんだい</rt>
                        </ruby>があります。
                    </aside>
                </section>

                <!-- The SPA Problem -->
                <section>
                    <h2>SPAの根本的な問題</h2>
                    <div class="warning">
                        <p><strong>純粋なSPAは多くの問題を抱えており現在は「呪われた」技術とされることも</strong></p>
                    </div>

                    <h3>主な問題点</h3>
                    <ul>
                        <li><strong>初回ロード</strong> : すべてのJavaScriptをダウンロードするまで何も表示されない</li>
                        <li><strong>SEO</strong> : 検索エンジンがJavaScriptを実行しないと内容が見えない</li>
                        <li><strong>パフォーマンス</strong> : バンドルが大きくなりがち</li>
                        <li><strong>複雑性</strong> : クライアントサイドでの状態管理が複雑</li>
                    </ul>
                    <img src="./images/cursed.png" alt="SPAが呪われた技術" />

                    <aside class="notes">
                        これらの<ruby>技術<rt>ぎじゅつ</rt></ruby>でSPAの<ruby>問題<rt>もんだい</rt></ruby>を<ruby>解決<rt>かいけつ</rt>
                        </ruby>できます。<br>
                        SSRはサーバーでHTMLを<ruby>作<rt>つく</rt></ruby>ってから<ruby>送<rt>おく</rt></ruby>る<ruby>方法<rt>ほうほう</rt>
                        </ruby>です。<br>
                        SSGはWebサイトを<ruby>作<rt>つく</rt></ruby>る<ruby>時<rt>とき</rt></ruby>に<ruby>全<rt>すべ</rt>
                        </ruby>てのHTMLを<ruby>用意<rt>ようい</rt></ruby>します。
                    </aside>
                </section>

                <!-- SPA Solutions -->
                <section>
                    <h2>【念のため】現実的な解決策</h2>
                    <p>SPAの問題を解決するレンダリング戦略</p>
                    <ul>
                        <li><strong>SSR【Server Side Rendering】</strong><br>サーバーでHTMLを生成</li>
                        <li><strong>SSG【Static Site Generation】</strong><br>ビルド時に静的HTMLを生成</li>
                        <li><strong>ISR【Incremental Static Regeneration】</strong><br>必要に応じて静的ページを再生成</li>
                    </ul>

                    <div class="note">
                        純粋SPAの問題を解決するためのフレームワーク：<br>Next.js、React Router/Remix、Astro、Gatsbyなど
                    </div>
                </section>
                <section>
                    <h2>まとめ：SPA</h2>
                    <ul>
                        <li><strong>構造:</strong> 単一HTMLファイル、JSでDOMを操作し、リロードなしで表示更新</li>
                        <li><strong>体験:</strong> 高速な遷移、アプリ風UX</li>
                        <li><strong>課題:</strong> 初回ロード重い、SEOに弱い</li>
                        <li><strong>実践解:</strong> フレームワークでレンダリング戦略を補完</li>
                    </ul>
                    <aside class="notes">
                        SPAは<ruby>速<rt>はや</rt></ruby>くて<ruby>便利<rt>べんり</rt></ruby>ですが、<ruby>問題<rt>もんだい</rt>
                        </ruby>もあります。<br>
                        <ruby>実際<rt>じっさい</rt></ruby>の<ruby>開発<rt>かいはつ</rt></ruby>ではフレームワークを<ruby>使<rt>つか</rt>
                        </ruby>って<ruby>問題<rt>もんだい</rt></ruby>を<ruby>解決<rt>かいけつ</rt></ruby>します。<br>
                        ReactだけでなくVueやAngularでもSPAを<ruby>作<rt>つく</rt></ruby>れます。<br>
                        <ruby>基本<rt>きほん</rt></ruby>の<ruby>考<rt>かんが</rt></ruby>え<ruby>方<rt>かた</rt></ruby>を<ruby>理解<rt>りかい
                            </rt></ruby>することが<ruby>大切<rt>たいせつ</rt></ruby>です。
                    </aside>
                </section>
            </section>

            <!-- lifecycle and effects -->
            <section>
                <section>
                    <h1>Reactのライフサイクル</h1>
                    <p>コンポーネントの状態管理と描画サイクルを理解する</p>
                </section>

                <!-- Basic lifecycle -->
                <section>
                    <h2>コンポーネントのライフサイクル</h2>
                    <p>すべてのコンポーネントは3つの段階を経ます</p>

                    <div class="lifecycle">
                        <div class="mount">
                            <h3>マウント</h3>
                            <p>コンポーネントが作成される</p>
                            <ul class="compact">
                                <li>初期state・propsの設定</li>
                                <li>JSXから仮想DOMの生成</li>
                                <li>実DOMへの挿入</li>
                                <li>レイアウト・ペイント</li>
                            </ul>
                        </div>

                        <div class="update">
                            <h3>更新</h3>
                            <p>コンポーネントが変更される</p>
                            <ul class="compact">
                                <li>stateやpropsの変更検知</li>
                                <li>仮想DOMの再生成</li>
                                <li>差分計算（Reconciliation）</li>
                                <li>実DOMの更新</li>
                            </ul>
                        </div>

                        <div class="unmount">
                            <h3>アンマウント</h3>
                            <p>コンポーネントが破棄される</p>
                            <ul class="compact">
                                <li>実DOMからの削除</li>
                                <li>イベントリスナーの解除</li>
                                <li>メモリの解放</li>
                            </ul>
                        </div>
                    </div>
                    <aside class="notes">
                        コンポーネントは人間と同じように<ruby>生<rt>う</rt></ruby>まれて、<ruby>成長<rt>せいちょう</rt></ruby>して、<ruby>死<rt>し</rt>
                        </ruby>にます。<br>
                        マウントは「<ruby>生<rt>う</rt></ruby>まれる」、<ruby>更新<rt>こうしん</rt></ruby>は「<ruby>成長<rt>せいちょう</rt>
                        </ruby>する」、アンマウントは「<ruby>死<rt>し</rt></ruby>ぬ」です。<br>
                        Reactはこの3つの<ruby>段階<rt>だんかい</rt></ruby>でコンポーネントを<ruby>管理<rt>かんり</rt></ruby>します。<br>
                        <ruby>仮想<rt>かそう</rt></ruby>DOMは<ruby>実際<rt>じっさい</rt></ruby>のDOMより<ruby>軽<rt>かる</rt>
                        </ruby>くて<ruby>速<rt>はや</rt></ruby>いです。
                    </aside>
                </section>

                <!-- Why Pure components -->
                <section>
                    <h2>純粋コンポーネント</h2>
                    <p>Reactの基本原則：同じ入力には同じ出力</p>
                    <br>
                    <div class="fragment">
                        <h3>純粋関数の特徴</h3>
                        <ul>
                            <li>同じ<code>props</code>で常に同じJSXを返す</li>
                            <li>レンダリング中に外部状態を変更しない</li>
                            <li>外部の変数に依存しない</li>
                        </ul>
                    </div>

                    <div class="comparison">
                        <div class="part fragment">
                            <h4 class="success">純粋なコンポーネント</h4>
                            <pre><code data-lang="jsx">function PureComponent({ name }) {
  return (
        &lt;h1&gt;こんにちは、{name}さん！&lt;/h1&gt;
  );
}</code></pre>
                        </div>
                        <div class="part fragment">
                            <h4 class="error">不純なコンポーネント</h4>
                            <pre><code data-lang="jsx">function ImpureComponent({ name }) {
  document.title = `Welcome ${name}`; // 副作用
  
  return &lt;h1&gt;こんにちは、{Math.random()}さん！&lt;/h1&gt;; // 非決定的
}</code></pre>
                        </div>
                    </div>
                    <aside class="notes">
                        <ruby>純粋<rt>じゅんすい</rt></ruby><ruby>関数<rt>かんすう</rt></ruby>は<ruby>数学<rt>すうがく</rt></ruby>の<ruby>関数
                            <rt>かんすう</rt>
                        </ruby>と同じです。<br>
                        同じ<ruby>入力<rt>にゅうりょく</rt></ruby>なら<ruby>必<rt>かなら</rt></ruby>ず同じ<ruby>結果<rt>けっか</rt>
                        </ruby>が<ruby>出<rt>で</rt></ruby>ます。<br>
                        <ruby>副作用<rt>ふくさよう</rt></ruby>は<ruby>外<rt>そと</rt></ruby>の<ruby>世界<rt>せかい</rt></ruby>に<ruby>影響
                            <rt>えいきょう</rt>
                        </ruby>を<ruby>与<rt>あた</rt></ruby>えることです。<br>
                        <ruby>純粋<rt>じゅんすい</rt></ruby>なコンポーネントはテストしやすくてバグが少ないです。
                    </aside>
                </section>

                <!-- Side effects -->
                <section>
                    <h2>副作用（Side Effect）とは</h2>
                    <p>コンポーネントの純粋性を破る操作、でも現実的なアプリには不可欠</p>

                    <div class="four-square">
                        <div>
                            <h3>データ操作</h3>
                            <ul class="compact-list">
                                <li>API呼び出し</li>
                                <li>データベース操作、ローカルストレージ</li>
                                <li>I/O操作</li>
                            </ul>
                        </div>

                        <div>
                            <h3>DOM操作</h3>
                            <ul class="compact-list">
                                <li>要素への直接アクセス</li>
                                <li>フォーカス制御</li>
                                <li>スクロール操作</li>
                            </ul>
                        </div>

                        <div>
                            <h3>購読・解除</h3>
                            <ul class="compact-list">
                                <li>イベントリスナー</li>
                                <li>WebSocket接続</li>
                                <li>タイマー設定</li>
                            </ul>
                        </div>

                        <div>
                            <h3>外部ライブラリ</h3>
                            <ul class="compact-list">
                                <li>チャートライブラリ</li>
                                <li>アニメーションライブラリ</li>
                                <li>マップライブラリ</li>
                            </ul>
                        </div>
                    </div>

                    <div class="warning">
                        レンダリング中の副作用は予期しない動作を引き起こす
                        <br>
                        例：無限ループ、予期しない再レンダリング
                    </div>

                    <aside class="notes">
                        <ruby>現実<rt>げんじつ</rt></ruby>のアプリでは<ruby>外<rt>そと</rt></ruby>の<ruby>世界<rt>せかい</rt>
                        </ruby>とやりとりが必要です。<br>
                        APIからデータを<ruby>取<rt>と</rt></ruby>る、ボタンを<ruby>押<rt>お</rt></ruby>したときの<ruby>音<rt>おと</rt>
                        </ruby>を<ruby>鳴<rt>な</rt></ruby>らすなど。<br>
                        これらはすべて<ruby>副作用<rt>ふくさよう</rt></ruby>です。<br>
                        レンダリング<ruby>中<rt>ちゅう</rt></ruby>に<ruby>副作用<rt>ふくさよう</rt></ruby>をするとバグになります。
                    </aside>
                </section>

                <!-- useEffect intro -->
                <section>
                    <h2>useEffect：副作用の安全な実行</h2>
                    <p>Reactが提供する副作用管理の仕組み</p>
                    <div class="comparison">
                        <div class="part fragment">
                            <div>
                                <h3 class="centered">レンダーフェーズ</h3>
                                <p class="centered">JSX → 仮想DOM</p>
                                <p class="centered muted">コンポーネントが何を表示するかを「計算」する段階</p>
                            </div>
                            <ul>
                                <li>前回との差分を計算（reconciliation）</li>
                                <li>実際のDOMはまだ変更されない</li>
                                <li>中断・再実行される可能性</li>
                            </ul>
                            <div class="part error">
                                副作用禁止
                            </div>
                        </div>

                        <div class="part fragment">
                            <div>
                                <h3 class="centered">コミットフェーズ</h3>
                                <p class="centered">仮想DOM → 実DOM</p>
                                <p class="centered muted">実際にDOMを「更新」する段階 </p>
                            </div>
                            <ul>
                                <li>計算された差分を実DOMに適用</li>
                                <li>副作用を安全に実行</li>
                                <li>useEffectはペイント後に実行（非同期）</li>
                            </ul>
                            <div class="part success">
                                副作用OK
                            </div>
                        </div>
                    </div>
                    <aside class="notes">
                        レンダーフェーズは「<ruby>計算<rt>けいさん</rt></ruby>」、<ruby>コミットフェーズ<rt></rt>
                        </ruby>は「<ruby>実行<rt>じっこう</rt></ruby>」です。<br>
                        レンダーフェーズは<ruby>何度<rt>なんど</rt></ruby>も<ruby>実行<rt>じっこう</rt>
                        </ruby>される<ruby>場合<rt>ばあい</rt></ruby>があります。<br>
                        コミットフェーズは<ruby>必<rt>かなら</rt></ruby>ず<ruby>一回<rt>いっかい</rt></ruby>だけ<ruby>実行
                            <rt>じっこう</rt>
                        </ruby>されます。<br>
                        <code>useEffect</code>はコミットフェーズで<ruby>実行<rt>じっこう</rt></ruby>されるので<ruby>安全
                            <rt>あんぜん</rt>
                        </ruby>です。
                    </aside>
                </section>

                <!-- useEffect basic form -->
                <section>
                    <h2><code>useEffect</code>の基本形</h2>
                    <div class="split-triptych">
                        <pre><code data-lang="jsx">useEffect(setup, dependencies?)</code></pre>
                        <div class="fragment">
                            <h4><code>setup</code>関数</h4>
                            <ul class="compact-list">
                                <li>副作用を実行する関数</li>
                                <li>必須パラメータ</li>
                                <li>クリーンアップ関数を返せる</li>
                            </ul>
                        </div>
                        <div class="fragment">
                            <h4><code>dependencies</code>配列</h4>
                            <ul class="compact-list">
                                <li>再実行の条件を指定</li>
                                <li>オプション（省略可能）</li>
                                <li>値の変更を監視</li>
                            </ul>
                        </div>
                    </div>

                    <div class="fragment">
                        <pre><code data-lang="jsx">import { useEffect } from 'react';

function MyComponent() {
  function setup() {
    console.log('副作用を実行');
  }

  useEffect(setup);

  return &lt;div&gt;...&lt;/div&gt;;
}</code></pre>
                    </div>
                    <aside class="notes">
                        セットアップは<ruby>実際<rt>じっさい</rt></ruby>に<ruby>副作用<rt>ふくさよう</rt></ruby>を<ruby>行<rt>おこな
                            </rt>
                        </ruby>う<ruby>処理<rt>しょり</rt></ruby>を<ruby>書<rt>か</rt></ruby>く<ruby>関数<rt>かんすう</rt>
                        </ruby>です。<br>
                        <code>dependencies</code>でいつ<ruby>実行<rt>じっこう</rt></ruby>するかをReactに<ruby>教<rt>おし</rt>
                        </ruby>えます。<br>
                        <code>useEffect</code>は<ruby>必<rt>かなら</rt></ruby>ずReactからインポートしてください。<br>
                    </aside>
                </section>

                <!-- useEffect syntax -->
                <section>
                    <h2><code>useEffect</code>の基本構文</h2>
                    <div class="comparison">
                        <div class="font-smaller">
                            <pre><code data-lang="jsx">import { useEffect } from "react";

function Component() {
    function cleanup() { // クリーンアップ関数：リソースの解放
        console.log("アンマウント時や次のエフェクト実行前");
    }

    function setup() { // エフェクト関数：副作用を実行
        console.log("DOM更新後に実行される");
        return cleanup;
    }

    useEffect(setup, [/* 依存配列 */]);

    return &lt;div&gt;...&lt;/div&gt;;
}</code></pre>
                        </div>
                        <dl>
                            <dt>エフェクト関数</dt>
                            <dd>副作用を実行する関数</dd>
                            <dt>クリーンアップ関数</dt>
                            <dd>リソース解放（オプション）</dd>
                            <dt>依存配列</dt>
                            <dd>参照する値の一覧（オプション）</dd>
                        </dl>
                    </div>
                    <aside class="notes">
                        セットアップ<ruby>関数<rt>かんすう</rt></ruby>からクリーンアップ<ruby>関数<rt>かんすう</rt>
                        </ruby>を<ruby>返<rt>かえ</rt>
                        </ruby>すことができます。<br>
                        クリーンアップ<ruby>関数<rt>かんすう</rt></ruby>でリソースを<ruby>片付<rt>かたづ</rt></ruby>けます。<br>
                        クリーンアップは<ruby>コンポーネント<rt></rt></ruby>が<ruby>消<rt>き</rt></ruby>える<ruby>前<rt>まえ</rt>
                        </ruby>に<ruby>実行<rt>じっこう</rt></ruby>されます。
                    </aside>
                </section>

                <!-- Dependency array patterns -->
                <section>
                    <h2>依存配列による実行制御</h2>

                    <ol>
                        <li class="fragment">
                            <p>毎回実行</p>
                            <pre><code data-lang="jsx">useEffect(() => {
  console.log('毎回のレンダリング後に実行');
}); // 依存配列なし</code></pre>
                        </li>

                        <li class="fragment">
                            <p>初回のみ実行</p>
                            <pre><code data-lang="jsx">useEffect(() => {
  console.log('マウント時のみ実行');
}, []); // 空の依存配列</code></pre>
                        </li>

                        <li class="fragment">
                            <p>条件付き実行</p>
                            <pre><code data-lang="jsx">useEffect(() => {
  console.log('userIdが変わった時のみ実行');
}, [userId]); // userIdを監視して、変わったら実行</code></pre>
                        </li>
                    </ol>
                    <aside class="notes">
                        <ruby>依存<rt>いぞん</rt></ruby><ruby>配列<rt>はいれつ</rt></ruby>でいつ<ruby>実行<rt>じっこう</rt>
                        </ruby>するかを<ruby>決<rt>き</rt></ruby>めます。<br>
                        <ruby>配列<rt>はいれつ</rt></ruby>なしは「<ruby>毎回<rt>まいかい</rt></ruby>」という<ruby>意味<rt>いみ</rt>
                        </ruby>です。<br>
                        <ruby>空<rt>から</rt></ruby>の<ruby>配列<rt>はいれつ</rt></ruby>は「<ruby>最初<rt>さいしょ</rt>
                        </ruby>だけ」という<ruby>意味<rt>いみ</rt></ruby>です。<br>
                        <ruby>値<rt>あたい</rt></ruby>を<ruby>入<rt>い</rt></ruby>れると「その<ruby>値<rt>あたい</rt></ruby>が<ruby>変<rt>か
                            </rt></ruby>わったとき」です。
                    </aside>
                </section>

                <!-- useEffect flow -->
                <section>
                    <h2><code>useEffect</code>の実行フロー</h2>

                    <div class="split">
                        <div class="font-smaller">
                            <pre><code data-lang="jsx">import { useEffect } from "react";

function Component() {
  useEffect(
    () => { // エフェクト関数：副作用を実行
      console.log("DOM更新後に実行される");

      return () => { // クリーンアップ関数：リソースの解放
        console.log("アンマウント時や次のエフェクト実行前");
      };
    },
    [/* 依存配列 */]
  );

  return &lt;div&gt;...&lt;/div&gt;;
}</code></pre>
                        </div>
                        <div class="flow-diagram">
                            <div class="part fragment" data-fragment-index="0">
                                <h4>1. レンダリング完了</h4>
                                <p>コンポーネントのJSXが仮想DOMに変換され、実DOMが更新される</p>
                            </div>

                            <div class="flow-arrow fragment" data-fragment-index="1"></div>

                            <div class="part fragment" data-fragment-index="1">
                                <h4>2. 依存配列チェック</h4>
                                <p>前回の値と比較し、変更があるかを確認</p>
                                <ul class="compact-list">
                                    <li>初回実行時：常に実行</li>
                                    <li>再レンダリング時：依存値の変更時のみ</li>
                                </ul>
                            </div>

                            <div class="flow-arrow fragment" data-fragment-index="2"></div>

                            <div class="part fragment" data-fragment-index="2">
                                <h4>3. クリーンアップ実行</h4>
                                <p>前回のエフェクトのクリーンアップ関数（ある場合）</p>
                            </div>

                            <div class="flow-arrow fragment" data-fragment-index="3"></div>

                            <div class="part fragment" data-fragment-index="3">
                                <h4>4. 新しいエフェクト実行</h4>
                                <p>セットアップ関数が実行され、副作用処理を行う</p>
                            </div>
                        </div>
                    </div>
                    <aside class="notes">
                        <code>useEffect</code>の<ruby>実行<rt>じっこう</rt></ruby>の<ruby>流<rt>なが</rt></ruby>れを<ruby>説明<rt>せつめい
                            </rt></ruby>します。<br>
                        1. まずコンポーネントがレンダリングされます<br>
                        2. <ruby>次<rt>つぎ</rt></ruby>に<ruby>依存<rt>いぞん</rt></ruby><ruby>配列<rt>はいれつ</rt></ruby>の<ruby>値<rt>
                                あたい</rt></ruby>をチェックします<br>
                        3. <ruby>値<rt>あたい</rt></ruby>が<ruby>変<rt>か</rt></ruby>わっていたら、<ruby>古<rt>ふる</rt>
                        </ruby>いセットアップ<ruby>関数<rt>かんすう</rt></ruby>を<ruby>実行<rt>じっこう</rt></ruby>します<br>
                        4. <ruby>最後<rt>さいご</rt></ruby>に<ruby>新<rt>あたら</rt></ruby>しいセットアップ<ruby>関数<rt>かんすう</rt>
                        </ruby>を<ruby>実行<rt>じっこう</rt></ruby>します<br>
                        この<ruby>順番<rt>じゅんばん</rt></ruby>はいつも<ruby>同<rt>おな</rt></ruby>じです。
                    </aside>
                </section>

                <!-- Practical example -->
                <section>
                    <h2>実践例：ポケットモンデータの取得</h2>

                    <iframe
                        src="https://codesandbox.io/embed/twm23k?view=editor+%2B+preview&module=%2Fsrc%2FApp.tsx&hidenavigation=1"
                        style="width:100%; height: 700px; border:0; border-radius: 4px; overflow:hidden;"
                        title="PokemonCard"
                        allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
                        sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"></iframe>
                    <aside class="notes">
                        <ruby>実際<rt>じっさい</rt></ruby>のアプリでよくあるパターンです。<br>
                        <ruby>最初<rt>さいしょ</rt></ruby>はloading: trueで「<ruby>読込中<rt>よみこみちゅう</rt></ruby>」を<ruby>表示<rt>ひょうじ
                            </rt></ruby>します。<br>
                        データが<ruby>来<rt>き</rt></ruby>たらloading: falseにして<ruby>結果<rt>けっか</rt></ruby>を<ruby>表示<rt>ひょうじ</rt>
                        </ruby>します。<br>
                        propsが<ruby>変<rt>か</rt></ruby>わると<ruby>自動的<rt>じどうてき</rt></ruby>に<ruby>新<rt>あたら</rt>
                        </ruby>しいデータを<ruby>取<rt>と</rt></ruby>ります。
                    </aside>
                </section>

                <!-- Practical example flow -->
                <section>
                    <h2><code>useEffect</code>の動作フロー</h2>

                    <div class="comparison">
                        <div>
                            <h4 class="fragment">初回表示時</h4>
                            <ol class="list-flow">
                                <li class="fragment">
                                    <strong>コンポーネントマウント</strong>：<br>
                                    <code>selectedPokemon="jigglypuff"</code>で<code>PokemonCard</code>が初回レンダリング
                                    <pre><code data-lang="jsx">&lt;PokemonCard name="jigglypuff" /&gt;</code></pre>
                                </li>

                                <li class="fragment">
                                    <strong>useEffect実行</strong>：<br>
                                    レンダリング完了後、<code>useEffect</code>が実行される<br>
                                    <code>loading: true</code>、<code>fetch</code>でデータ取得開始
                                    <pre><code data-lang="jsx">useEffect(() => {
  setLoading(true);
  fetch(`https://pokeapi.co/api/v2/pokemon/jigglypuff`)
  ...
</code></pre>
                                </li>

                                <li class="fragment">
                                    <strong>データ取得と状態更新</strong>：<br>
                                    <code>loading: true → false</code>、<code>pokemon: null → データ</code>
                                    <pre><code data-lang="jsx">
.then((pokemonData) => {
  setPokemon(pokemonData);
  setLoading(false);
});</code></pre>
                                </li>
                            </ol>
                        </div>
                        <div>
                            <h4 class="fragment">ボタンクリック時</h4>
                            <ol class="list-flow" start="4">
                                <li class="fragment">
                                    <strong>state変更</strong>：<br>
                                    <code>selectedPokemon: "jigglypuff" → "pikachu"</code>
                                    <pre><code data-lang="jsx">&lt;button onClick={() => setSelectedPokemon("pikachu")}&gt;</code></pre>
                                </li>

                                <li class="fragment">
                                    <strong>propsの変更検知</strong>：<br>
                                    <code>name: "jigglypuff" → "pikachu"</code>
                                    <pre><code data-lang="jsx">&lt;PokemonCard name="pikachu" /&gt; // propsが変更された</code></pre>
                                </li>

                                <li class="fragment">
                                    <strong>useEffect再実行</strong>：<br>
                                    依存配列<code>[name]</code>の値が変わったため、useEffectが再度実行される
                                    <pre><code data-lang="jsx">}, [name]); // "pikachu"に変更されたので再実行</code></pre>
                                </li>

                                <li class="fragment">
                                    <strong>新しいデータ取得</strong>：<br>
                                    ピカチュウのデータを取得し、UIが更新される
                                    <pre><code data-lang="jsx">fetch(`https://pokeapi.co/api/v2/pokemon/pikachu`)</code></pre>
                                </li>
                            </ol>
                        </div>
                    </div>

                </section>

                <!-- Lifecycle with useEffect -->
                <section>
                    <h2><code>useEffect</code>とライフサイクル</h2>

                    <div class="lifecycle compact">
                        <div class="mount">
                            <h3>マウント</h3>
                            <ol>
                                <li>コンポーネント初期化</li>
                                <li>初回レンダリング</li>
                                <li>DOM更新</li>
                                <li><strong><code>useEffect</code>実行</strong></li>
                            </ol>
                        </div>

                        <div class="update">
                            <h3>更新</h3>
                            <ol>
                                <li>stateやpropsの変更検知</li>
                                <li>再レンダリング</li>
                                <li>DOM差分更新</li>
                                <li><strong>前のエフェクトクリーンアップ</strong></li>
                                <li><strong>新しいエフェクト実行</strong></li>
                            </ol>
                        </div>

                        <div class="unmount">
                            <h3>アンマウント</h3>
                            <ol>
                                <li><strong>全エフェクトクリーンアップ</strong></li>
                                <li>DOMから削除</li>
                                <li>メモリ解放</li>
                            </ol>
                        </div>
                    </div>
                    <p class="note">
                        <a href="https://julesblom.com/writing/react-hook-component-timeline/" target="_blank"
                            rel="noopener">
                            ビジュアル解説はこちら
                        </a>
                    <p>
                    <aside class="notes">
                        useEffectはライフサイクルの<ruby>重要<rt>じゅうよう</rt></ruby>な<ruby>部分<rt>ぶぶん</rt></ruby>です。<br>
                        マウント<ruby>時<rt>じ</rt></ruby>、<ruby>更新時<rt>こうしんじ</rt></ruby>、アンマウント<ruby>時<rt>じ</rt>
                        </ruby>に<ruby>実行
                            <rt>じっこう</rt>
                        </ruby>されます。<br>
                        クリーンアップでメモリリークを<ruby>防<rt>ふせ</rt></ruby>ぎます。<br>
                        リンク<ruby>先<rt>さき</rt></ruby>のビジュアル<ruby>解説<rt>かいせつ</rt></ruby>もぜひ<ruby>見<rt>み</rt></ruby>てください。
                    </aside>
                </section>

                <!-- Common mistakes -->
                <section>
                    <h2>よくあるミス</h2>

                    <ul class="compact-list">
                        <li class="fragment">
                            <p>依存配列の漏れ</p>
                            <div class="split">
                                <pre><code data-lang="jsx">useEffect(() => {
  fetchData(userId); // userIdに依存しているが...
}, []); // 依存配列に含まれていない</code></pre>
                                <span><strong>対策：</strong> ESLint plugin-react-hooksを使用</span>
                            </div>
                        </li>
                        <li class="fragment">
                            <p>無限ループ</p>
                            <div class="split">
                                <pre><code data-lang="jsx">useEffect(() => {
    setCount(count + 1); // countに依存
}, [count]); // 無限ループ発生</code></pre>
                                <p><strong>対策：</strong> 関数型更新を使用: <code>setCount(c => c + 1)</code></p>
                            </div>
                        </li>
                        <li class="fragment">
                            <p>クリーンアップ忘れ</p>
                            <div class="split">
                                <pre><code data-lang="jsx">useEffect(() => {
  const timer = setInterval(updateData, 1000);
  // クリーンアップなし → メモリリーク
}, []);</code></pre>
                                <p><strong>対策：</strong> 必ずクリーンアップ関数でリソース解放</p>
                            </div>
                        </li>
                    </ul>
                    <aside class="notes">
                        1. <ruby>依存<rt>いぞん</rt></ruby><ruby>配列<rt>はいれつ</rt></ruby>に<ruby>必要<rt>ひつよう</rt></ruby>な<ruby>値
                            <rt>
                                あたい</rt>
                        </ruby>を<ruby>入<rt>い</rt></ruby>れ<ruby>忘<rt>わす</rt></ruby>れることが<ruby>多<rt>おお
                            </rt></ruby>いです。<br>
                        リンターがルール<ruby>違反<rt>いはん</rt></ruby>を<ruby>教<rt>おし</rt></ruby>えてくれます。<br>
                        2. <ruby>無限<rt>むげん</rt></ruby>ループが<ruby>発生<rt>はっせい</rt></ruby>することがあります。<br>
                        3. タイマーやサブスクリプションは<ruby>必<rt>かなら</rt></ruby>ず<ruby>解除<rt>かいじょ</rt></ruby>してください。<br>
                        メモリリークの<ruby>原因<rt>げんいん</rt></ruby>になります。

                    </aside>
                </section>

                <!-- Strict Mode -->
                <section>
                    <h2>開発環境での注意点</h2>
                    <p>ReactのStrict Mode</p>

                    <div class="comparison">
                        <div>
                            <h3>開発環境</h3>
                            <ul class="compact">
                                <li>エフェクトが2回実行される</li>
                                <li>意図的な動作</li>
                                <li>バグの早期発見</li>
                            </ul>
                        </div>

                        <div>
                            <h3>本番環境</h3>
                            <ul class="compact">
                                <li>通常通り1回のみ実行</li>
                                <li>最適化された動作</li>
                                <li>パフォーマンス重視</li>
                            </ul>
                        </div>
                    </div>

                    <div class="note">
                        <strong>重要:</strong> 開発環境で2回実行されても正常に動作するようにクリーンアップを実装する
                    </div>

                    <aside class="notes">
                        <ruby>開発中<rt>かいはつちゅう</rt></ruby>は<ruby>2回<rt>かい</rt></ruby><ruby>実行<rt>じっこう</rt>
                        </ruby>されますが、これは<ruby>正常<rt>せいじょう</rt></ruby>です。
                        <ruby>バグ<rt>ばぐ</rt></ruby>を<ruby>見<rt>み</rt></ruby>つけやすくするためのReactの<ruby>機能<rt>きのう</rt>
                        </ruby>です。
                        <ruby>本番<rt>ほんばん</rt></ruby>では<ruby>1回<rt>かい</rt></ruby>だけ<ruby>実行<rt>じっこう</rt></ruby>されます。
                    </aside>
                </section>

                <!-- useLayoutEffect -->
                <section>
                    <h2><code>useLayoutEffect</code>との違い</h2>

                    <div class="comparison">
                        <div>
                            <h3><code>useEffect</code></h3>
                            <ul class="compact">
                                <li>ブラウザの描画後に実行</li>
                                <li>非同期実行</li>
                                <li>一般的な副作用に使用</li>
                                <li><strong>推奨：</strong>ほとんどのケース</li>
                            </ul>
                        </div>

                        <div>
                            <h3><code>useLayoutEffect</code></h3>
                            <ul class="compact">
                                <li>ブラウザの描画前に実行</li>
                                <li>同期実行</li>
                                <li>DOM測定・操作に使用</li>
                                <li><strong>使用場面：</strong>レイアウト計算時</li>
                            </ul>
                        </div>
                    </div>

                    <pre><code data-lang="jsx">// DOM要素のサイズを測定する場合のみ
useLayoutEffect(() => {
  const rect = ref.current.getBoundingClientRect();
  setDimensions({ width: rect.width, height: rect.height });
}, []);</code></pre>

                    <p class="note">99%の場合は<code>useEffect</code>で十分</p>

                    <aside class="notes">
                        <code>useLayoutEffect</code>は、<ruby>画面<rt>がめん</rt></ruby>が<ruby>見える前<rt>みえるまえ</rt>
                        </ruby>に<ruby>実行<rt>じっこう</rt></ruby>されるため、サイズやレイアウトを<ruby>測る<rt>はかる</rt></ruby>ときに<ruby>便利
                            <rt>べんり</rt>
                        </ruby>です。<br>

                        <ruby>大抵<rt>たいてい</rt></ruby>はuseEffectで<ruby>十分<rt>じゅうぶん</rt></ruby>ですが、useLayoutEffectは<ruby>特別
                            <rt>とくべつ</rt>
                        </ruby>な<ruby>場合<rt>ばあい</rt></ruby>にのみ<ruby>使<rt>つか</rt>
                        </ruby>います。<br>たとえば、DOM<ruby>要素<rt>ようそ</rt></ruby>のサイズを<ruby>測<rt>はか</rt></ruby>る<ruby>時<rt>とき
                            </rt></ruby>など、<ruby>限定的<rt>げんていてき</rt></ruby>な<ruby>用途<rt>ようと</rt></ruby>です。<br><ruby>迷<rt>
                                まよ
                            </rt></ruby>ったらuseEffectを<ruby>使<rt>つか</rt></ruby>ってください。
                    </aside>
                </section>

                <!-- まとめ -->
                <section>
                    <h2>まとめ</h2>

                    <dl>
                        <dt>純粋性を保つ</dt>
                        <dd>レンダリング中は副作用を避ける</dd>

                        <dt>適切なタイミング</dt>
                        <dd>useEffectで副作用を安全に実行</dd>

                        <dt>依存関係の管理</dt>
                        <dd>依存配列で実行タイミングを制御</dd>

                        <dt>リソースの解放</dt>
                        <dd>クリーンアップでメモリリーク防止</dd>
                    </dl>
                </section>
            </section>

            <section>
                <!-- Quiz 1: Basic lifecycle -->
                <section>
                    <h4>理解度チェック①【ライフサイクル】</h4>
                    <div class="quiz">
                        <h3>Reactコンポーネントの正しいライフサイクルの順序は？</h3>
                        <br>
                        <div class="quiz-options">
                            <div class="quiz-option">A) 更新 → マウント → アンマウント</div>
                            <div class="quiz-option custom correct-answer fragment" data-fragment-index="1">B) マウント → 更新
                                →
                                アンマウント</div>
                            <div class="quiz-option">C) マウント → アンマウント → 更新</div>
                            <div class="quiz-option">D) アンマウント → マウント → 更新</div>
                        </div>
                    </div>
                    <div class="fragment note" data-fragment-index="1">
                        <strong>答え:</strong> B) コンポーネントは作成(マウント)→変更(更新)→破棄(アンマウント)の順
                    </div>
                </section>

                <!-- Quiz 2: Pure components -->
                <section>
                    <h4>理解度チェック②【純粋コンポーネント】</h4>
                    <div class="quiz">
                        <h3>どのコンポーネントが純粋？</h3>
                        <pre><code data-lang="jsx">
function ComponentA({ name }) { // A
  console.log('Rendering:', name);
  return &lt;h1&gt;Hello {name}&lt;/h1&gt;;
}

function ComponentB({ name }) { // B  
  return &lt;h1&gt;Hello {name}&lt;/h1&gt;;
}

function ComponentC({ name }) { // C
  document.title = name;
  return &lt;h1&gt;Hello {name}&lt;/h1&gt;;
}</code></pre>
                        <div class="quiz-options">
                            <div class="quiz-option">A) ComponentA（ログ出力するから）</div>
                            <div class="quiz-option custom fragment correct-answer" data-fragment-index="1">B)
                                ComponentB（副作用なし）</div>
                            <div class="quiz-option">C) ComponentC（タイトル更新するから）</div>
                            <div class="quiz-option">D) どれも純粋ではない</div>
                        </div>
                    </div>
                    <div class="fragment note" data-fragment-index="1">
                        <strong>答え:</strong> B) 同じpropsで常に同じJSXを返し、副作用がない
                    </div>
                </section>

                <!-- Quiz 3: Dependency array -->
                <section>
                    <h4>理解度チェック③【依存配列】</h4>
                    <div class="quiz">
                        <h3>この<code>useEffect</code>はいつ実行される？</h3>
                        <pre><code data-lang="jsx">const [count, setCount] = useState(0);
const [name, setName] = useState('');

useEffect(() => {
  console.log('Effect runs');
}, [count]);</code></pre>
                        <div class="quiz-options">
                            <div class="quiz-option">A) 毎回のレンダリング後</div>
                            <div class="quiz-option custom fragment correct-answer" data-fragment-index="1">B)
                                <code>count</code>が変更された時のみ
                            </div>
                            <div class="quiz-option">C) <code>name</code>が変更された時のみ</div>
                            <div class="quiz-option">D) マウント時のみ</div>
                        </div>
                    </div>
                    <div class="fragment note" data-fragment-index="1">
                        <strong>答え:</strong> B) 依存配列に含まれる<code>count</code>が変更された時のみ実行
                    </div>
                </section>

                <!-- Quiz 4: Cleanup -->
                <section>
                    <h4>理解度チェック④【クリーンアップ】</h4>
                    <div class="quiz">
                        <h3>このコードの問題点は？</h3>
                        <pre><code data-lang="jsx">function UserStatus({ userId }) {
  const [status, setStatus] = useState('offline');
  
  useEffect(() => {
    function handleStatusChange(newStatus) {
      setStatus(newStatus);
    }
    
    StatusAPI.subscribe(userId, handleStatusChange);
  }, [userId]);
  
  return &lt;div&gt;Status: {status}&lt;/div&gt;;
}</code></pre>
                        <div class="quiz-options">
                            <div class="quiz-option">A) <code>useEffect</code>の使い方が間違い</div>
                            <div class="quiz-option">B) 依存配列に<code>userId</code>が含まれている</div>
                            <div class="quiz-option fragment custom correct-answer" data-fragment-index="1">C)
                                サブスクリプションが解除されない</div>
                            <div class="quiz-option">D) 特に問題なし</div>
                        </div>
                    </div>
                    <div class="fragment" data-fragment-index="1">
                        <div class="note">
                            <strong>答え:</strong> C) アンマウント時や次のエフェクト前にunsubscribeが必要
                        </div>
                    </div>
                </section>
            </section>

            <!-- Practice -->
            <section>
                <section>
                    <h1>React 実践演習</h1>
                    <h3>1つの課題 (15-20分)</h3>

                    <p>今日学んだ内容を実際に使ってみよう！</p>
                    <div class="note"><a target="_blank"
                            href="https://github.com/cdefined/front-kaizen/blob/master/react-lessons/lesson_3/task.md">react-lessons/lesson_3/task.md</a>
                    </div>
                </section>

                <section>
                    <div class="timer"></div>

                    <h2><span class="task-number">課題1</span> 斬魄刀ロアダー</h2>

                    <p><strong><code>&lt;ZanpakutoLoader&gt;</code> コンポーネントを作成してください</strong></p>
                    <ul class="compact-list">
                        <li>ローディング中は「読み込み中...」と表示</li>
                        <li>成功時は <code>name</code> と <code>powerLevel</code> を表示</li>
                        <li>失敗時はエラーメッセージを表示</li>
                        <li><code>useState</code> と <code>useEffect</code> を組み合わせて実装すること</li>
                    </ul>

                    <pre><code data-lang="typescript">function ZanpakutoLoader({ name }: { name: string }) {
  const [zanpakuto, setZanpakuto] = useState&lt;Zanpakuto | null&gt;(null);
  const [error, setError] = useState("");
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    // name が変更された時に loadZanpakto を呼び出す処理を書く
  }, [name]);

  return &lt;div&gt;{/* ローディング、結果、エラーの表示 */}&lt;/div&gt;;
}</code></pre>

                    <div class="note"><a target="_blank"
                            href="https://github.com/cdefined/front-kaizen/blob/master/react-lessons/lesson_3/task.md">react-lessons/lesson_3/task.md</a>
                    </div>
                </section>
                <section>
                    <h2><span class="task-number">課題1</span> 斬魄刀ロアダー</h2>
                    <iframe
                        src="https://codesandbox.io/embed/mgy7j3?view=editor+%2B+preview&module=%2Fsrc%2FApp.tsx&hidenavigation=1&expanddevtools=1"
                        style="width:100%; height: 700px; border:0; border-radius: 4px; overflow:hidden;"
                        title="Zanpakuto Loader"
                        allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
                        sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"></iframe>
                </section>
            </section>

            <section>
                <!-- Summary -->
                <section>
                    <h1>第3回まとめ</h1>

                    <h2>今日学んだこと</h2>
                    <ul>
                        <li>SPAとは、従来のWebアプリとの違い</li>
                        <li>コンポーネントのライフサイクル</li>
                        <li>副作用と純粋コンポーネントの概念</li>
                        <li><code>useEffect</code>の基本的な使い方</li>
                    </ul>
                </section>

                <!-- In next episode -->
                <section>
                    <h1>次回予告</h1>
                    <p><strong>React④:</strong> カスタムフック、共通化、振り返り</p>
                </section>
            </section>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/reveal.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/plugin/notes/notes.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/plugin/markdown/markdown.min.js"></script>
    <script src="../../scripts/reveal-timer-plugin.js"></script>
    <script type="module">
        import { codeToHtml } from 'https://esm.sh/shiki@3.0.0';

        const codeBlocks = document.querySelectorAll('pre code[data-lang]');

        for (const block of codeBlocks) {
            const lang = block.dataset.lang;
            const theme = block.dataset.theme || 'night-owl'; // 'material-theme-darker'
            const rawCode = block.textContent.trim();

            const html = await codeToHtml(rawCode, { lang, theme });

            const wrapper = document.createElement('div');
            wrapper.innerHTML = html;
            const shikiHTML = wrapper.firstElementChild;

            const pre = block.closest('pre');
            if (pre && shikiHTML) pre.replaceWith(shikiHTML);
        }
    </script>

    <script>
        Reveal.initialize({
            hash: true,
            slideNumber: true,
            width: 1800,
            height: 900,
            margin: 0.1,
            transition: 'slide',
            transitionSpeed: 'fast',
            backgroundTransition: 'fade',
            plugins: [RevealNotes, RevealTimer, RevealMarkdown]
        });
    </script>
</body>

</html>