<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta lang="ja">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>React 応用②</title>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/reveal.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/theme/black.min.css">
    <style>
        :root {
            --main-header: #667eea;
            --green: #27ae60;
            --yellow: #f39c12;
            --red: #fc5342;
            --bg: #f8f8f810;
        }

        .reveal {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        .reveal h1,
        .reveal h2,
        .reveal h3,
        .reveal h4 {
            color: var(--main-header);
            text-transform: none;
        }

        .reveal h4,
        .reveal h3 {
            margin-bottom: 0;
        }

        .reveal .pale {
            opacity: 0.9;
            font-size: 1em;
        }

        .reveal .slides section {
            text-align: left;
        }

        .reveal .title-slide {
            text-align: center;
        }

        .reveal pre code {
            max-height: unset;
        }

        ul>li,
        dl>dd,
        ol>li {
            line-height: 2em;
        }

        ul.compact-list>li,
        dl.compact-list>dd,
        ol.compact-list>li {
            line-height: 1.5em;
        }


        dd {
            margin-bottom: 0.5em;
        }

        .arrow {
            background: none;
            font-size: 100px;
            color: #f8f8f890;
            flex: 0;
        }

        .down-arrow {
            opacity: 0.7;
            display: flex;
            justify-content: center;
            font-size: 50px;
            flex: 0;
        }

        .comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            justify-content: start;
        }

        .comparison.centered {
            text-align: left;
            align-items: center;
        }

        .triptych {
            display: flex;
            justify-content: space-between;
            align-items: start;
            gap: 0.25em;
        }

        .triptych.centered {
            align-items: center;
        }

        .triptych-transformation {
            display: flex;
            justify-content: start;
            align-items: center;
            gap: 2em;
        }

        .note {
            background: rgba(52, 152, 219, 0.2);
            border-left: 4px solid var(--main-header);
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;

            ol,
            ul,
            dl {
                margin-left: 0.2em;
            }
        }

        .warning {
            background: rgba(231, 76, 60, 0.2);
            border-left: 4px solid var(--red);
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .quiz {
            background: rgba(46, 204, 113, 0.1);
            border-left: 4px solid var(--green);
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
        }

        .quiz-options {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr 1fr;
            gap: 10px;
        }

        .quiz-option {
            display: block;
            padding: 8px 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .quiz-option:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .quiz-options.small {
            font-size: 0.65em;
        }

        .fragment.correct-answer.visible {
            border-left: 4px solid #2ecc71;
            background: rgba(46, 204, 113, 0.3);
        }

        .reveal pre {
            width: 100%;
            margin-top: 10px;
        }

        .reveal pre code {
            padding: 1em;
        }

        .timer {
            position: absolute;
            top: -30px;
            right: 15px;
        }

        .comparison-table {
            font-size: 0.75em;
            border-collapse: collapse;
            width: 100%;
            margin: 1rem 0;
        }

        .comparison-table th,
        .comparison-table td {
            padding: 0.6rem 0.4rem;
            text-align: center;
        }

        .comparison-table thead th {
            font-weight: bold;
        }

        .comparison-table .metric {
            font-weight: bold;
            text-align: left;
        }

        .mpa-spa {
            border-radius: 8px;
            padding: 1.5rem;
            border-top: 4px solid var(--main-header);
            background: var(--bg);
            width: 50%;

            h3,
            p {
                text-align: center;
            }

            ol {
                font-size: 0.93em;
                width: 100%;
                padding-left: 0;
                margin: 0;
            }

            li {
                list-style-position: inside;
                background: #667eea15;
                color: white;
                padding: 0.75rem 1.5rem;
                margin: 0.75rem 0;
                border-radius: 4px;
            }
        }

        .lifecycle {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 2rem;
            margin-top: 2rem;

            >div {
                display: flex;
                flex-direction: column;
                justify-content: space-between;
                border-radius: 8px;
                padding: 1.5rem;
                border-top: 4px solid;
                border-left: 4px solid;
                background: var(--bg);

                >div {
                    font-size: 0.9em;
                    border-radius: 8px;
                    padding: 0.15rem;
                    background: var(--bg);

                    div {
                        margin: 0.2em 0 0.5em 0;
                    }

                    ul {
                        margin: 0 0.5em 0.2em;
                    }
                }
            }

            p {
                text-align: center;
            }

            p,
            ul {
                font-size: 0.9em;
            }

            ol {
                font-size: 0.8em;
                margin: 0 5px;
                margin-bottom: 0.5em;
            }

            .mount {
                position: relative;
                border-color: var(--green);

                h3 {
                    color: var(--green);
                    text-align: center;
                }
            }

            .mount::after,
            .update::after {
                content: "🡆";
                position: absolute;
                top: 50%;
                right: -36px;
                color: #f8f8f8b0;
                font-size: 45px;
                font-weight: bold;
            }

            .update {
                position: relative;
                border-color: var(--yellow);

                h3 {
                    color: var(--yellow);
                    text-align: center;
                }
            }

            .update::before {
                content: '⭯';
                position: absolute;
                top: -20px;
                right: -10px;
                background: var(--yellow);
                color: white;
                width: 105px;
                height: 105px;
                border-radius: 50%;
                display: flex;
                align-items: flex-start;
                justify-content: center;
                font-size: 75px;
                font-weight: bold;
            }

            .unmount {
                border-color: var(--red);

                h3 {
                    color: var(--red);
                    text-align: center;
                }
            }
        }

        .four-square {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 2rem;
            margin-top: 2rem;

            div {
                border-radius: 8px;
                padding: 1.5rem;
                background: #f8f8f810;
                font-size: 0.9em;
            }
        }

        .four-square.centered {
            h3 {
                text-align: center;
            }
        }

        .part,
        .pattern {
            border-radius: 8px;
            padding: 0.5rem;
            background: var(--bg);

            pre {
                margin: 0;
            }
        }

        .part {
            margin-top: 0.5em;
            padding: 0.75rem;
        }

        .pattern {
            margin-bottom: 0.5em;
            font-size: 0.9em;
        }

        .split {
            display: grid;
            grid-template-columns: 1.5fr 2fr;
            gap: 20px;
            align-items: center;
            justify-items: stretch;
        }

        .simple-split {
            display: grid;
            grid-template-columns: 1fr 3fr;
            align-items: center;
        }

        .centered {
            text-align: center;
        }

        .reveal .success {
            color: var(--green);
            padding: 0.75rem;
            border-radius: 4px;
            text-align: center;
        }

        .reveal .error {
            color: var(--red);
            padding: 0.75rem;
            border-radius: 4px;
            text-align: center;
        }

        .list-flow {
            font-size: 0.8em;
            padding: 0;
        }

        .flow-diagram {
            font-size: 0.65em;
            display: flex;
            flex-direction: column;
            gap: 0;

            .part {
                margin: 0;
                text-align: center;
            }

            .flow-arrow::after {
                content: "🡇";
                position: relative;
                top: 0;
                left: 50%;
                color: #f8f8f890;
                font-size: 30px;
            }
        }

        .font-smaller {
            font-size: 0.9em;
        }

        .muted {
            color: #bebebe;
            font-size: 0.8em;
        }

        .quote {
            padding: 0.3em 0.5em;
            margin-bottom: 1em;
            border-left: 10px solid var(--main-header);
        }
    </style>
</head>

<body>
    <div class="reveal">
        <div class="slides">
            <section class="title-slide">
                <h1>React 応用②</h1>
                <h2>カスタムフック、共通化、振り返り</h2>
            </section>

            <!-- In previous episode -->
            <section>
                <section>
                    <h1>前回の復習</h1>
                    <p>React 応用①のおさらい</p>
                    <aside class="notes">まず、<ruby>前回<rt>ぜんかい</rt></ruby>の<ruby>内容<rt>ないよう</rt></ruby>を<ruby>確認<rt>かくにん
                            </rt></ruby>します。<br>
                        わからないところがあったらChatWorkで<ruby>質問<rt>しつもん</rt></ruby>してください。</aside>
                </section>

                <section>
                    <h2>シングルページアプリ【SPA】＝ 単一HTMLファイル</h2>
                    <div class="spa-concept">
                        <ul>
                            <li>アプリケーション全体が<strong>1つの<code>index.html</code></strong>から始まる</li>
                            <li>ページ遷移時も<strong>同じHTMLファイル内</strong>で完結</li>
                            <li><strong>JavaScript</strong>がDOMを直接操作してコンテンツを切り替える</li>
                            <li>URLが変わる場合もあるが、実際には<strong>ページリロードしない</strong></li>
                        </ul>
                    </div>

                    <div class="example">
                        <pre><code data-lang="html">
<!-- 最初から最後まで、このHTMLファイル1つだけ -->
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;React App&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id="root"&gt;&lt;/div&gt; &lt;!-- ここにReactがコンテンツを描画 --&gt;
    &lt;script src="bundle.js"&gt;&lt;/script&gt; &lt;!-- アプリケーションのコード --&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
                    </div>
                    <aside class="notes">
                        <ruby>従来<rt>じゅうらい</rt></ruby>のサイトは、ページごとに<ruby>別<rt>べつ</rt></ruby>のHTMLファイルを<ruby>読<rt>よ</rt>
                        </ruby>み<ruby>込<rt>こ</rt></ruby>みます。<br>
                        でもSPAは<ruby>違<rt>ちが</rt></ruby>います。<ruby>最初<rt>さいしょ</rt></ruby>に<ruby>一度<rt>いちど</rt>
                        </ruby>だけHTMLを<ruby>読<rt>よ</rt></ruby>み<ruby>込<rt>こ</rt></ruby>んで、あとはJavaScriptで<ruby>中身<rt>
                                なかみ</rt></ruby>を<ruby>入<rt>い</rt></ruby>れ<ruby>替<rt>か</rt></ruby>えます。<br>
                        だから<ruby>画面<rt>がめん</rt></ruby>の<ruby>切<rt>き</rt></ruby>り<ruby>替<rt>か</rt></ruby>えが<ruby>速<rt>はや
                            </rt></ruby>いです。<br>
                        ただし、SPAは<ruby>最初<rt>さいしょ</rt></ruby>にすべてのJavaScriptをダウンロードするため、
                        <ruby>初回<rt>しょかい</rt></ruby>のロード<ruby>時間<rt>じかん</rt></ruby>が<ruby>長<rt>なが</rt>
                        </ruby>くなることがあります。<br>
                    </aside>
                </section>

                <section>
                    <h2>コンポーネント ＝ 関数</h2>
                    <div class="syntax-review">
                        <pre><code data-lang="jsx">// コンポーネント定義（大文字で開始）
function UserCard({ name, email, children }) {
  return (
    &lt;div className="card"&gt;
      &lt;h3&gt;{name}&lt;/h3&gt;
      &lt;p&gt;{email}&lt;/p&gt;
      {children}
    &lt;/div&gt;
  );
}</code></pre>
                        <pre><code data-lang="jsx">
// 使用
&lt;UserCard name="Kurotsuchi Mayuri" email="m.kurotsuchi@seireitei.co.jp"&gt;
  &lt;button&gt;編集&lt;/button&gt;
&lt;/UserCard&gt;</code></pre>
                    </div>

                    <div class="note">
                        <code>props</code> = 関数の引数<br><code>children</code> = タグの中身
                    </div>
                    <aside class="notes">
                        Reactのコンポーネントは、ただの<ruby>関数<rt>かんすう</rt></ruby>です。<br>
                        <ruby>引数<rt>ひきすう</rt></ruby>でデータを<ruby>受<rt>う</rt></ruby>け<ruby>取<rt>と</rt></ruby>って、JSXを<ruby>返
                            <rt>かえ</rt>
                        </ruby>します。<br>
                        childrenは<ruby>特別<rt>とくべつ</rt></ruby>なpropsで、タグの<ruby>間<rt>あいだ</rt></ruby>に<ruby>書<rt>か</rt>
                        </ruby>いた<ruby>内容<rt>ないよう</rt></ruby>が<ruby>入<rt>はい</rt></ruby>ります。<br>
                        この<ruby>例<rt>れい</rt></ruby>では、ボタンがchildrenになっています。
                    </aside>
                </section>
                <section>
                    <h2>状態 ＝ 再レンダーを引き起こす変数</h2>
                    <div class="comparison">
                        <pre><code data-lang="jsx">
import React, { useState } from 'react';

function LikeButton() {
  // [現在の値, セッター関数] = useState(初期値)
  const [likes, setLikes] = useState(0);

  return (
    &lt;div&gt;
      &lt;button onClick={() =&gt; setLikes((prevLikes) => prevLikes + 1)}&gt;
        ♡ {likes}
      &lt;/button&gt;
    &lt;/div&gt;
  );
}
                </code></pre>
                        <div>
                            <h4>動作の流れ</h4>
                            <ol class="font-smaller">
                                <li><code>useState(0)</code> → 初期値0でいいね数を作成</li>
                                <li>ボタンクリック → <code>setLikes(likes + 1)</code></li>
                                <li>状態更新 → コンポーネント再レンダリング</li>
                                <li>新しい値でUI更新</li>
                            </ol>
                        </div>
                    </div>
                    <br>
                    <div class="note">
                        <strong>重要：</strong>状態が変わるたびに関数コンポーネント全体が再実行される
                    </div>
                    <aside class="notes">
                        <ruby>普通<rt>ふつう</rt></ruby>の<ruby>変数<rt>へんすう</rt></ruby>を<ruby>変<rt>か</rt></ruby>えても、<ruby>画面
                            <rt>がめん</rt>
                        </ruby>は<ruby>更新<rt>こうしん</rt></ruby>されません。<br>
                        でもuseStateで<ruby>作<rt>つく</rt></ruby>った<ruby>変数<rt>へんすう</rt></ruby>なら、<ruby>値<rt>あたい</rt>
                        </ruby>が<ruby>変<rt>か</rt></ruby>わると<ruby>自動的<rt>じどうてき</rt></ruby>に<ruby>再<rt>さい</rt>
                        </ruby>レンダリングされます。<br>
                        setLikesを<ruby>呼<rt>よ</rt></ruby>ぶと、コンポーネント<ruby>全体<rt>ぜんたい</rt></ruby>がもう<ruby>一度<rt>いちど</rt>
                        </ruby><ruby>実行<rt>じっこう</rt></ruby>されて、<ruby>新<rt>あたら</rt></ruby>しい<ruby>値<rt>あたい</rt>
                        </ruby>で<ruby>画面<rt>がめん</rt></ruby>が<ruby>描<rt>えが</rt></ruby>かれます。<br>
                        これがReactの<ruby>基本<rt>きほん</rt></ruby>の<ruby>仕組<rt>しく</rt></ruby>みです。
                    </aside>
                </section>

                <section>
                    <h2>制御されたコンポーネント ＝ 状態 ＋ イベントハンドラー</h2>
                    <br>

                    <div class="comparison">
                        <div>
                            <h4>基本構造</h4>
                            <pre><code data-lang="jsx">// 3つの要素が必須
const [value, setValue] = useState('');        // 1. 状態

return (
  &lt;input 
    value={value}                              // 2. input要素
    onChange={(e) => setValue(e.target.value)} // 3. ハンドラー関数
  /&gt;
);</code></pre>
                        </div>

                        <div>
                            <h4>重要なポイント</h4>
                            <ul class="compact-list">
                                <li><code>value</code>は必ず<code>state</code>由来</li>
                                <li><code>onChange</code>で<code>state</code>を更新</li>
                                <li>状態変更 → 再レンダリング</li>
                                <li>Reactが完全に制御</li>
                            </ul>
                        </div>
                    </div>

                    <div class="note">
                        ・「Controlled」では、Reactが扱います<br>
                        ・「Uncontrolled」では、Reactが状態を知らない、DOMに任せます
                    </div>
                    <aside class="notes">
                        input<ruby>要素<rt>ようそ</rt></ruby>を<ruby>直接<rt>ちょくせつ</rt></ruby>DOMに<ruby>任<rt>まか</rt>
                        </ruby>せると、Reactが<ruby>値<rt>あたい</rt></ruby>を<ruby>知<rt>し</rt></ruby>りません。<br>
                        <ruby>制御<rt>せいぎょ</rt></ruby>されたコンポーネントでは、inputsの<ruby>値<rt>あたい</rt></ruby>を<ruby>必<rt>かなら</rt>
                        </ruby>ずstateから<ruby>渡<rt>わた</rt></ruby>します。<br>
                        ユーザーが<ruby>入力<rt>にゅうりょく</rt></ruby>すると、onChangeでstateを<ruby>更新<rt>こうしん</rt>
                        </ruby>して、それがまたinputに<ruby>反映<rt>はんえい</rt></ruby>されます。<br>
                        こうすれば、<ruby>入力<rt>にゅうりょく</rt></ruby>チェックやフォーマットも<ruby>簡単<rt>かんたん</rt></ruby>にできます。
                    </aside>
                </section>

                <section>
                    <h2>なぜ純粋コンポーネントが必要なのか？</h2>
                    <div class="centered part"><code>コンポーネント(props, state) → JSX</code></div>


                    <div class="split">
                        <div>
                            <div class="fragment" data-fragment-index="0">
                                <p><strong>Reactの要求:</strong></p>
                                <ul class="compact-list">
                                    <li>同じ入力 → 同じ出力</li>
                                    <li>レンダー中に副作用を起こさない</li>
                                </ul>
                            </div>
                            <br>
                            <div class="fragment" data-fragment-index="1">
                                <p><strong>理由:</strong> レンダー中、Reactは勝手に</p>
                                <ul class="compact-list">
                                    <li>コンポーネントを複数回実行</li>
                                    <li>途中でキャンセル・やり直し</li>
                                    <li>最適化のため結果を破棄</li>
                                </ul>
                            </div>
                        </div>
                        <div class="fragment" data-fragment-index="0">
                            <br>
                            <div class="font-smaller centered">
                                副作用 ＝ 外部世界との相互作用
                            </div>
                            <img width="100%" src="./images/component-world.svg" alt="コンポーネント＋外の世界" />
                        </div>
                    </div>

                    <div class="warning fragment" data-fragment-index="1">
                        レンダー中に副作用を実行すると → いつ何回実行されるかわからない
                    </div>
                    <aside class="notes">
                        Reactは、<ruby>同<rt>おな</rt></ruby>じpropsとstateなら<ruby>同<rt>おな</rt></ruby>じ<ruby>結果<rt>けっか</rt>
                        </ruby>が<ruby>返<rt>かえ</rt></ruby>ることを<ruby>期待<rt>きたい</rt></ruby>しています。<br>
                        なぜなら、Reactは<ruby>最適化<rt>さいてきか</rt></ruby>のために、コンポーネントを<ruby>何度<rt>なんど</rt></ruby>も<ruby>実行<rt>
                                じっこう</rt></ruby>したり、<ruby>途中<rt>とちゅう</rt></ruby>でキャンセルしたりするからです。<br>
                        もしレンダー<ruby>中<rt>ちゅう</rt></ruby>にAPIを<ruby>叩<rt>たた</rt></ruby>いたら、<ruby>同<rt>おな</rt>
                        </ruby>じリクエストが<ruby>何回<rt>なんかい</rt></ruby>も<ruby>飛<rt>と</rt></ruby>んでしまいます。<br>
                        だから<ruby>副作用<rt>ふくさよう</rt></ruby>は、<ruby>決<rt>き</rt></ruby>まったタイミングでだけ<ruby>実行<rt>じっこう</rt>
                        </ruby>する<ruby>必要<rt>ひつよう</rt></ruby>があります。
                    </aside>
                </section>

                <section>
                    <h2>管理された副作用</h2>

                    <div class="split">
                        <div>
                            <div>
                                <h5>ユーザーアクション時 ✅</h5>
                                <pre><code data-lang="jsx">function handleClick() {
  fetch('/api/data'); // 予測可能
}</code></pre>
                            </div>

                            <div>
                                <h5>コンポーネント状態変化時 ✅</h5>
                                <pre><code data-lang="jsx">useEffect(() => {
  fetch('/api/data'); // 安全なタイミング
}, []);</code></pre>
                            </div>
                            <div>
                                <h5>レンダー中 ❌</h5>
                                <pre><code data-lang="jsx">function Component() {
  fetch('/api/data'); // 同じAPIを何回も叩く
  document.title = "バカ"; // タイトルがチカチカする
  ...
}</code></pre>
                            </div>
                        </div>
                        <img src="./images/component-world-bridge.svg" alt="コンポーネントvs外の世界" />
                    </div>
                    <aside class="notes">
                        <ruby>副作用<rt>ふくさよう</rt></ruby>を<ruby>実行<rt>じっこう</rt></ruby>していい<ruby>場所<rt>ばしょ</rt>
                        </ruby>は<ruby>二<rt>ふた</rt></ruby>つだけです。<br>
                        <ruby>一<rt>ひと</rt></ruby>つ<ruby>目<rt>め</rt></ruby>は、ボタンクリックなどのイベントハンドラー。これは<ruby>予測<rt>よそく</rt>
                        </ruby>できます。<br>
                        <ruby>二<rt>ふた</rt></ruby>つ<ruby>目<rt>め</rt></ruby>は、useEffect。これは<ruby>安全<rt>あんぜん</rt>
                        </ruby>なタイミングで<ruby>実行<rt>じっこう</rt></ruby>されます。<br>
                        レンダー<ruby>中<rt>ちゅう</rt></ruby>に<ruby>直接<rt>ちょくせつ</rt></ruby><ruby>副作用<rt>ふくさよう</rt>
                        </ruby>を<ruby>書<rt>か</rt></ruby>くと、バグの<ruby>原因<rt>げんいん</rt></ruby>になります。
                    </aside>
                </section>

                <section>
                    <h3>エフェクト ＝ 副作用を「いつ実行するか」で制御する仕組み</h3>
                    <br>
                    <div class="comparison">
                        <div class="font-smaller">
                            <pre><code data-lang="jsx">import { useEffect } from "react";

function Component() {
    function cleanup() { // クリーンアップ関数：リソースの解放
        console.log("アンマウント時や次のエフェクト実行前");
    }

    function setup() { // エフェクト関数：副作用を実行
        console.log("DOM更新後に実行される");
        return cleanup;
    }

    useEffect(setup, [/* 依存配列 */]);

    return &lt;div&gt;...&lt;/div&gt;;
}</code></pre>
                        </div>
                        <dl>
                            <dt>エフェクト関数</dt>
                            <dd>副作用を実行する関数</dd>
                            <dt>クリーンアップ関数（オプション）</dt>
                            <dd>リソース解放</dd>
                            <dt>依存配列（オプション）</dt>
                            <dd>実行制御</dd>
                        </dl>
                    </div>
                    <div class="note">
                        <ul class="compact-list">
                            <li><strong>依存配列なし</strong> → 毎回実行</li>
                            <li><strong>空の依存配列 <code>[]</code></strong> → 初回のみ</li>
                            <li><strong>値を指定 <code>[userId]</code></strong> → 値変更時のみ</li>
                        </ul>
                    </div>
                    <aside class="notes">
                        セットアップ<ruby>関数<rt>かんすう</rt></ruby>からクリーンアップ<ruby>関数<rt>かんすう</rt>
                        </ruby>を<ruby>返<rt>かえ</rt>
                        </ruby>すことができます。<br>
                        クリーンアップ<ruby>関数<rt>かんすう</rt></ruby>でリソースを<ruby>片付<rt>かたづ</rt></ruby>けます。<br>
                        クリーンアップは<ruby>コンポーネント<rt></rt></ruby>が<ruby>消<rt>き</rt></ruby>える<ruby>前<rt>まえ</rt>
                        </ruby>に<ruby>実行<rt>じっこう</rt></ruby>されます。
                    </aside>
                </section>

                <section>
                    <h2>コンポーネントのライフサイクル</h2>

                    <div class="lifecycle compact">
                        <div class="mount">
                            <h3>マウント</h3>
                            <ol class="compact-list">
                                <li>コンポーネント初期化</li>
                                <li>初回レンダリング</li>
                                <li>DOM更新</li>
                                <li><code>useEffect</code>実行</li>
                            </ol>
                            <div class="font-smaller">
                                <div class="centered"><strong>画面に追加された時</strong></div>
                                <ul class="compact-list">
                                    <li>初回ページ読み込み</li>
                                    <li>親コンポーネントが初回作成</li>
                                    <li>条件付きレンダリング<br>
                                        <pre><code data-lang="jsx">{show && &lt;Component /&gt;} // show → true</code></pre>
                                    </li>
                                </ul>
                            </div>
                        </div>

                        <div class="update">
                            <h3>更新</h3>
                            <ol class="compact-list">
                                <li><code>state</code>や<code>props</code>の変更検知</li>
                                <li>再レンダリング</li>
                                <li>DOM差分更新</li>
                                <li>前のエフェクトクリーンアップ</li>
                                <li>新しいエフェクト実行</li>
                            </ol>
                            <div class="font-smaller">
                                <div class="centered"><strong><code>props</code>や<code>state</code>が変化した時</strong>
                                </div>
                                <ul class="compact-list">
                                    <li><code>setState</code>呼び出し</li>
                                    <li>親から<code>props</code>が変更</li>
                                    <li><code>useEffect</code>依存配列の値変更</li>
                                </ul>
                            </div>
                        </div>

                        <div class="unmount">
                            <h3>アンマウント</h3>
                            <ol class="compact-list">
                                <li>全エフェクトクリーンアップ</li>
                                <li>DOMから削除</li>
                                <li>メモリ解放</li>
                            </ol>
                            <div class="font-smaller">
                                <div class="centered"><strong>画面から削除された時</strong></div>
                                <ul class="compact-list">
                                    <li>親コンポーネントが削除</li>
                                    <li>ページを閉じる/離脱</li>
                                    <li>条件付きレンダリング<br>
                                        <pre><code data-lang="jsx">{show && &lt;Component /&gt;} // show → false</code></pre>
                                    </li>
                                </ul>
                            </div>
                        </div>
                    </div>
                    <p class="note">
                        <a href="https://julesblom.com/writing/react-hook-component-timeline/" target="_blank"
                            rel="noopener">
                            ビジュアル解説はこちら
                        </a>
                    <p>

                    <aside class="notes">
                        コンポーネントには<ruby>三<rt>みっ</rt></ruby>つの<ruby>段階<rt>だんかい</rt></ruby>があります。<ruby>生<rt>う</rt>
                        </ruby>まれて、<ruby>変化<rt>へんか</rt></ruby>して、<ruby>消<rt>き</rt></ruby>えます。<br>
                        useEffectは、ライフサイクルと<ruby>関係<rt>かんけい</rt></ruby>がありますが、それだけじゃありません。<br>
                        <ruby>本当<rt>ほんとう</rt></ruby>の<ruby>役割<rt>やくわり</rt></ruby>は、コンポーネントを<ruby>外<rt>そと</rt>
                        </ruby>の<ruby>世界<rt>せかい</rt></ruby>と<ruby>同期<rt>どうき</rt></ruby>させることです。<br>
                        「マウント<ruby>時<rt>じ</rt></ruby>に<ruby>実行<rt>じっこう</rt></ruby>」より、「この<ruby>値<rt>あたい</rt>
                        </ruby>が<ruby>変<rt>か</rt></ruby>わったら<ruby>同期<rt>どうき</rt></ruby>する」と<ruby>考<rt>かんが</rt>
                        </ruby>える<ruby>方<rt>ほう</rt></ruby>が<ruby>分<rt>わ</rt></ruby>かりやすいです。
                    </aside>
                </section>
            </section>

            <!-- Hook intro -->
            <section>
                <section>
                    <h1>フックとは</h1>
                    <p><code>use</code>で始まる特別な関数</p>
                    <aside class="notes">
                        <ruby>今回<rt>こんかい</rt></ruby>は、フックについて<ruby>学<rt>まな</rt></ruby>びます。<br>
                        フックはReactの<ruby>大事<rt>だいじ</rt></ruby>な<ruby>機能<rt>きのう</rt></ruby>です。
                    </aside>
                </section>

                <!-- What is a Hook -->
                <section>
                    <h2>フックとは</h2>

                    <p class="quote">コンポーネント内でReactの機能を使うための関数</p>
                    <div class="simple-split">
                        <img src="./images/hooked-component.svg" alt="コンポーネントにフック" />
                        <div class="fragment">
                            <p><strong>すべて<code>use</code>で始まる特別な関数 → フック</strong></p>
                            <pre><code data-lang="jsx">function Counter() {
    const [count, setCount] = useState(0);        // 状態管理
    const inputRef = useRef(null);                // DOM参照
    
    useEffect(() => {                             // 副作用
        document.title = `カウント: ${count}`;
    }, [count]);
    
    return &lt;div&gt;カウント: {count}&lt;/div&gt;;
}</code></pre>
                        </div>
                    </div>

                    <p class="note fragment">
                        <a href="https://ja.react.dev/reference/react/hooks" rel="noopener">組み込みの React フック</a>
                    </p>
                    <aside class="notes">
                        フックを<ruby>使<rt>つか</rt></ruby>うと、コンポーネントに<ruby>色々<rt>いろいろ</rt></ruby>な<ruby>機能<rt>きのう</rt>
                        </ruby>を<ruby>追加<rt>ついか</rt></ruby>できます。<br>
                        <ruby>例<rt>たと</rt></ruby>えば、データを<ruby>記憶<rt>きおく</rt></ruby>したり、DOMを<ruby>直接<rt>ちょくせつ</rt>
                        </ruby><ruby>触<rt>さわ</rt></ruby>ったり。<br>
                        <ruby>名前<rt>なまえ</rt></ruby>が<ruby>必<rt>かなら</rt></ruby>ず<code>use</code>で<ruby>始<rt>はじ</rt>
                        </ruby>まるので、すぐ<ruby>分<rt>わ</rt></ruby>かります。<br>
                        <ruby>公式<rt>こうしき</rt></ruby>ドキュメントには、もっとたくさんのフックが<ruby>載<rt>の</rt></ruby>っています。
                    </aside>
                </section>

                <!-- Mental Model: React's Hook Tracking -->
                <section>
                    <h3>Reactはフックを順序で管理する</h3>

                    <pre><code data-lang="jsx">function MyComponent() {
    const [name, setName] = useState("");     // フック #1
    const [age, setAge] = useState(0);        // フック #2
    useEffect(() => { ... }, []);             // フック #3
    const [email, setEmail] = useState("");   // フック #4
    
    // React内部では配列のように管理（概念的に）
    // [useState, useState, useEffect, useState]
}</code></pre>

                    <div class="fragment">
                        <p class="note">
                            各レンダー時に<strong>同じ順序</strong>でフックが呼ばれることをReactは期待している
                        </p>
                    </div>
                    <aside class="notes">
                        Reactは<ruby>内部<rt>ないぶ</rt></ruby>で、どのフックがどの<ruby>値<rt>あたい</rt></ruby>を<ruby>持<rt>も</rt>
                        </ruby>っているか<ruby>覚<rt>おぼ</rt></ruby>えています。<br>
                        でも<ruby>名前<rt>なまえ</rt></ruby>では<ruby>覚<rt>おぼ</rt></ruby>えません。<ruby>順番<rt>じゅんばん</rt>
                        </ruby>で<ruby>覚<rt>おぼ</rt></ruby>えます。<br>
                        だから、<ruby>毎回<rt>まいかい</rt></ruby><ruby>同<rt>おな</rt></ruby>じ<ruby>順番<rt>じゅんばん</rt></ruby>で<ruby>呼
                            <rt>よ</rt>
                        </ruby>ばないといけません。<br>
                        これが<ruby>分<rt>わ</rt></ruby>かると、<ruby>次<rt>つぎ</rt></ruby>のルールの<ruby>理由<rt>りゆう</rt>
                        </ruby>が<ruby>理解<rt>りかい</rt></ruby>できます。
                    </aside>
                </section>

                <section>
                    <h3>順序が変わると何が起こるか</h3>

                    <div class="comparison">
                        <div class="fragment">
                            <h5>1回目のレンダー：<code>showAge = true</code></h5>
                            <pre><code data-lang="jsx">function Component({ showAge }) {
    const [name, setName] = useState("竜騎");  // #1

    if (showAge) {
        const [age, setAge] = useState(51);   // #2
    }

    const [email, setEmail] = useState("");   // #3
    
    // React: [useState, useState, useState]
}</code></pre>
                            <p>React: <code>[name, age, email]</code></p>
                        </div>

                        <div class="fragment">
                            <h5>2回目のレンダー：<code>showAge = false</code></h5>
                            <pre><code data-lang="jsx">function Component({ showAge }) {
    const [name, setName] = useState("竜騎");  // #1

    // age のフックがスキップされる！

    const [email, setEmail] = useState("");   // #2 ← 前回の#3
    
    // React: [useState, useState] 
    // 「あれ？ #3 のフックはどこ？」
}</code></pre>
                            <p>React: <code>[name, email]</code> ← 順序が変わった！</p>
                        </div>
                    </div>

                    <div class="fragment warning">
                        Reactが混乱 → エラーまたは予期しない動作
                    </div>

                    <aside class="notes">
                        もし<ruby>条件<rt>じょうけん</rt></ruby>によってフックを<ruby>呼<rt>よ</rt></ruby>んだり<ruby>呼<rt>よ</rt>
                        </ruby>ばなかったりすると、<ruby>順番<rt>じゅんばん</rt></ruby>が<ruby>変<rt>か</rt></ruby>わります。<br>
                        <ruby>一回目<rt>いっかいめ</rt></ruby>は<ruby>三<rt>みっ</rt></ruby>つのフックがあったのに、<ruby>二回目<rt>にかいめ</rt>
                        </ruby>は<ruby>二<rt>ふた</rt></ruby>つしかない。<br>
                        Reactは「<ruby>三番目<rt>さんばんめ</rt></ruby>のフックはどこ？」と<ruby>混乱<rt>こんらん</rt></ruby>します。<br>
                        そして、<ruby>間違<rt>まちが</rt></ruby>った<ruby>値<rt>あたい</rt></ruby>を<ruby>返<rt>かえ</rt>
                        </ruby>したり、エラーになったりします。
                    </aside>
                </section>

                <!-- Rule of Hooks -->
                <section>
                    <h2>フックのルール</h2>
                    <div class="quote">要するに：毎回同じ順序でフックを呼び出す</div>

                    <div class="comparison">
                        <div class="fragment">
                            <h4>ルール1：トップレベルでのみ呼び出し</h4>
                            <ul class="font-smaller">
                                <li>ループ、条件分岐、ネストした関数内で<br><strong>呼び出してはいけない</strong></li>
                                <li>コンポーネントやフックの<strong>最上位で呼び出す</strong></li>
                            </ul>
                        </div>

                        <div class="fragment">
                            <h4>ルール2：React関数からのみ呼び出し</h4>
                            <ul class="font-smaller">
                                <li>Reactコンポーネントから呼び出す</li>
                                <li>または<code>use</code>で始まる関数から呼び出す</li>
                            </ul>
                        </div>
                    </div>

                    <aside class="notes">
                        フックのルールは<ruby>二<rt>ふた</rt></ruby>つだけです。<br>
                        トップレベルで<ruby>呼<rt>よ</rt></ruby>べば、<ruby>順番<rt>じゅんばん</rt></ruby>が<ruby>変
                            <rt>か</rt>
                        </ruby>わらないことを<ruby>保証<rt>ほしょう</rt></ruby>します。<br>
                        React<ruby>関数<rt>かんすう</rt></ruby>から<ruby>呼<rt>よ</rt></ruby>べば、Reactが<ruby>正<rt>ただ</rt>
                        </ruby>しく<ruby>管理<rt>かんり</rt></ruby>できることを<ruby>保証<rt>ほしょう</rt></ruby>します。<br>
                        このルールを<ruby>守<rt>まも</rt></ruby>れば、<ruby>問題<rt>もんだい</rt></ruby>は<ruby>起<rt>お</rt></ruby>きません。
                    </aside>
                </section>

                <!-- Rule of Hooks Violations -->
                <section>
                    <h2>フックのルール違反例</h2>

                    <div class="comparison">
                        <div class="pattern fragment" data-fragment-index="0">
                            <h4 class="error">条件分岐内でのフック</h4>
                            <pre><code data-lang="jsx">function Component({ condition }) {
  if (condition) {
    const [state, setState] = useState(0); // NG!
    
    useEffect(() => {
      // ...
    }, []);
  }
  
  return &lt;div&gt;...&lt;/div&gt;;
}</code></pre>
                        </div>

                        <div class="pattern fragment">
                            <h4 class="success">正しい書き方</h4>
                            <pre><code data-lang="jsx">function Component({ condition }) {
  const [state, setState] = useState(0); // OK!
  
  useEffect(() => {
    if (condition) {
      // 条件分岐はフック内部で
    }
  }, [condition]);
  
  return &lt;div&gt;...&lt;/div&gt;;
}</code></pre>
                        </div>
                    </div>

                    <div class="warning fragment" data-fragment-index="0">
                        フックの実行順序が変わると、Reactの内部状態管理が破綻します
                    </div>

                    <aside class="notes">
                        <ruby>左側<rt>ひだりがわ</rt></ruby>の<ruby>例<rt>れい</rt></ruby>は、conditionがfalseになると、useStateが<ruby>呼
                            <rt>よ</rt>
                        </ruby>ばれなくなります。<br>
                        これは<ruby>順番<rt>じゅんばん</rt></ruby>が<ruby>変<rt>か</rt></ruby>わるので、ダメです。<br>
                        <ruby>右側<rt>みぎがわ</rt></ruby>の<ruby>例<rt>れい</rt></ruby>では、フックは<ruby>必<rt>かなら</rt></ruby>ず<ruby>呼
                            <rt>よ</rt>
                        </ruby>ばれます。<br>
                        <ruby>条件<rt>じょうけん</rt></ruby>による<ruby>処理<rt>しょり</rt></ruby>は、フックの<ruby>中<rt>なか</rt>
                        </ruby>に<ruby>書<rt>か</rt></ruby>きます。これが<ruby>正<rt>ただ</rt></ruby>しい<ruby>方法<rt>ほうほう</rt>
                        </ruby>です。
                    </aside>
                </section>

                <!-- まとめ -->
                <section>
                    <h2>まとめ</h2>

                    <ul>
                        <li>Reactはフックを呼び出し順序で管理している</li>
                        <li>毎回同じ順序で呼ぶ必要がある（ルール）</li>
                        <li>ルールを破ると予期しない動作やエラーが発生</li>
                        <li>リンター（ESLintなど）でルール違反を自動検出できる</li>
                    </ul>

                    <aside class="notes">
                        フックは<ruby>便利<rt>べんり</rt></ruby>ですが、ルールを<ruby>守<rt>まも</rt></ruby>らないと<ruby>危険<rt>きけん</rt>
                        </ruby>です。<br>
                        でも、ルールは<ruby>簡単<rt>かんたん</rt></ruby>です。トップレベルで<ruby>呼<rt>よ</rt></ruby>ぶだけ。<br>
                        ESLintを<ruby>使<rt>つか</rt></ruby>えば、<ruby>間違<rt>まちが</rt></ruby>いを<ruby>自動<rt>じどう</rt>
                        </ruby>で<ruby>見<rt>み</rt></ruby>つけてくれます。
                    </aside>
                </section>
            </section>

            <!-- Custom hooks -->
            <section>
                <section>
                    <h1>カスタムフック</h1>
                    <p>コンポーネント間でのロジック共有</p>
                    <aside class="notes">
                        <ruby>次<rt>つぎ</rt></ruby>は、<ruby>自分<rt>じぶん</rt></ruby>でフックを<ruby>作<rt>つく</rt></ruby>る<ruby>方法
                            <rt>ほうほう</rt>
                        </ruby>を<ruby>学<rt>まな</rt></ruby>びます。<br>
                        これができると、コードがずっと<ruby>綺麗<rt>きれい</rt></ruby>になります。
                    </aside>
                </section>

                <!-- Custom hook anathomy -->
                <section>
                    <h2>カスタムフック</h2>

                    <div class="triptych centered">
                        <div>
                            <h5>既存のフックを組み合わせて作る独自のフック</h5>
                            <pre><code data-lang="jsx">// 1. 名前は「use」で始める（必須）
function useToggle(initialValue = false) { 
    // 2. 組み込みフックを最上位で呼び出す
    const [value, setValue] = useState(initialValue); 
    
    // 3. 必要なロジックを書く
    const toggle = () => setValue(prev => !prev);
    
    // 4. 必要なロジックを書く
    return [value, toggle];
}
</code></pre>
                            <ul class="font-smaller fragment" data-fragment-index="1">
                                <li>useStateを内部で使っている → これはフック</li>
                                <li>複数のコンポーネントで再利用できる</li>
                                <li>同じフックのルールが適用される</li>
                            </ul>
                        </div>
                        <div class="arrow fragment" data-fragment-index="2">➡</div>
                        <div class="fragment" data-fragment-index="2">
                            <h5>使用例：通常のフックと同じように使う</h5>
                            <pre><code data-lang="jsx">function Modal() {
    // カスタムフックを呼び出す
    const [isOpen, toggleOpen] = useToggle(false); 
    
    return (
        &lt;&gt;
            &lt;button onClick={toggleOpen}&gt;
                {isOpen ? '閉じる' : '開く'}
            &lt;/button&gt;
            {isOpen &amp;&amp; &lt;div&gt;モーダル内容&lt;/div&gt;}
        &lt;/&gt;
    );
}

// 他のコンポーネントでも同じロジックを再利用可能
function Sidebar() {
    const [isVisible, toggleVisible] = useToggle(true);
    // ...
}</code></pre>
                        </div>
                    </div>

                    <aside class="notes">
                        カスタムフックは、<ruby>既存<rt>きぞん</rt></ruby>のフックを<ruby>組<rt>く</rt></ruby>み<ruby>合<rt>あ</rt>
                        </ruby>わせて<ruby>作<rt>つく</rt></ruby>ります。<br>
                        <ruby>名前<rt>なまえ</rt></ruby>を<code>use</code>で<ruby>始<rt>はじ</rt></ruby>めるのは、Reactへの<ruby>約束<rt>
                                やくそく</rt></ruby>です。<br>
                        この<ruby>例<rt>れい</rt></ruby>では、useStateを<ruby>使<rt>つか</rt></ruby>っているので、これは<ruby>立派<rt>りっぱ</rt>
                        </ruby>なフックです。<br>
                        <ruby>一度<rt>いちど</rt></ruby><ruby>作<rt>つく</rt></ruby>れば、<ruby>色々<rt>いろいろ</rt>
                        </ruby>なコンポーネントで<ruby>使<rt>つか</rt></ruby>い<ruby>回<rt>まわ</rt></ruby>せます。
                    </aside>
                </section>

                <!-- What Makes a Function a Hook -->
                <section>
                    <h2>何がフックを「フック」にするのか</h2>
                    <div class="quote fragment">フック = 他のフック（組み込みのReact機能）を呼び出す関数</div>

                    <div class="comparison">
                        <div class="fragment">
                            <h4>実際のフック</h4>
                            <p><code>useState</code>を呼び出している → <strong>フック</strong></p>
                            <pre><code data-lang="jsx">function useCounter(initialValue = 0) {
    const [count, setCount] = useState(initialValue);
    
    const increment = () => setCount(prev => prev + 1);
    
    return [count, increment];
}</code></pre>
                        </div>
                        <div class="fragment">
                            <h4>フックではない普通の関数</h4>
                            <p>他のフックを呼び出していない → <strong>ただの関数</strong></p>
                            <pre><code data-lang="jsx">function formatPrice(price) {
    return `¥${price.toLocaleString()}`;
}</code></pre>
                        </div>
                    </div>

                    <aside class="notes">
                        <ruby>見分<rt>みわ</rt></ruby>け<ruby>方<rt>かた</rt></ruby>は<ruby>簡単<rt>かんたん</rt></ruby>です。<ruby>中<rt>
                                なか</rt></ruby>で<ruby>他<rt>ほか</rt></ruby>のフックを<ruby>呼<rt>よ</rt></ruby>んでいるか？<br>
                        <ruby>左側<rt>ひだりがわ</rt></ruby>はuseStateを<ruby>呼<rt>よ</rt></ruby>んでいるので、フックです。<br>
                        <ruby>右側<rt>みぎがわ</rt></ruby>はフックを<ruby>全然<rt>ぜんぜん</rt></ruby><ruby>呼<rt>よ</rt>
                        </ruby>んでいません。ただの<ruby>関数<rt>かんすう</rt></ruby>です。<br>
                        フックじゃない<ruby>関数<rt>かんすう</rt></ruby>なら、<code>use</code>で<ruby>始<rt>はじ</rt></ruby>めちゃダメです。
                    </aside>
                </section>

                <!-- Custom hook can call custom hooks -->
                <section>
                    <h2>フックは他のフックを呼び出せる</h2>
                    <div class="quote">カスタムフック同士も組み合わせ可能</div>

                    <pre><code data-lang="jsx">// 基本的なフック
function useToggle(initialValue = false) {
    const [value, setValue] = useState(initialValue);
    const toggle = () => setValue(prev => !prev);
    return [value, toggle];
}

// 他のカスタムフックを使うカスタムフック
function useModal() {
    const [isOpen, toggleOpen] = useToggle(false);  // カスタムフック呼び出し
    const [data, setData] = useState(null);         // 組み込みフック呼び出し
    
    const openModal = (modalData) => {
        setData(modalData);
        toggleOpen();
    };
    
    return { isOpen, data, openModal, closeModal: toggleOpen };
}</code></pre>

                    <p class="note fragment">フックの中でフックを呼ぶ = 普通のこと</p>

                    <aside class="notes">
                        フックの<ruby>中<rt>なか</rt></ruby>で、<ruby>別<rt>べつ</rt></ruby>のカスタムフックを<ruby>呼<rt>よ</rt>
                        </ruby>ぶこともできます。<br>
                        useModalは、useToggleという<ruby>別<rt>べつ</rt></ruby>のカスタムフックを<ruby>使<rt>つか</rt></ruby>っています。<br>
                        これは<ruby>全然<rt>ぜんぜん</rt></ruby><ruby>問題<rt>もんだい</rt></ruby>ありません。むしろ<ruby>推奨<rt>すいしょう</rt>
                        </ruby>されています。<br>
                        <ruby>小<rt>ちい</rt></ruby>さいフックを<ruby>組<rt>く</rt></ruby>み<ruby>合<rt>あ</rt></ruby>わせて、<ruby>大<rt>
                                おお</rt></ruby>きいフックを<ruby>作<rt>つく</rt></ruby>る<ruby>感<rt>かん</rt></ruby>じです。
                    </aside>
                </section>

                <!-- Custom hook also obey rule of hooks -->
                <section>
                    <h2>カスタムフックも同じルールに従う</h2>
                    <div class="quote">カスタムフックは既存のフックの組み合わせ</div>
                    <div class="fragment">
                        <pre><code data-lang="jsx">function useToggle(initialValue) {
    const [value, setValue] = useState(initialValue); // これは普通のuseState呼び出
    const toggle = () => setValue(prev => !prev);
    
    return [value, toggle];
}

// Reactから見ると：
function MyComponent() {
    const [isOpen, toggleOpen] = useToggle(false);    // useToggleの中のuseState
    const [isDark, toggleDark] = useToggle(true);     // 2つ目のuseToggleの中のuseState
    
    // Reactから見ると普通のフック呼び出しと同じ
}</code></pre>
                    </div>

                    <div class="note fragment">
                        Reactの追跡システムに新しい魔法は加えない
                    </div>

                    <aside class="notes">
                        カスタムフックも、<ruby>組<rt>く</rt></ruby>み<ruby>込<rt>こ</rt></ruby>みフックと<ruby>全<rt>まった</rt>
                        </ruby>く<ruby>同<rt>おな</rt></ruby>じルールに<ruby>従<rt>したが</rt></ruby>います。<br>
                        Reactから<ruby>見<rt>み</rt></ruby>ると、useToggleの<ruby>中<rt>なか</rt></ruby>のuseStateは、<ruby>普通<rt>ふつう
                            </rt></ruby>のuseStateです。<br>
                        だから、<ruby>条件分岐<rt>じょうけんぶんき</rt></ruby>の<ruby>中<rt>なか</rt></ruby>で<ruby>呼<rt>よ</rt>
                        </ruby>んだりしちゃダメです。<br>
                        <ruby>特別<rt>とくべつ</rt></ruby>なことは<ruby>何<rt>なに</rt></ruby>もありません。ただの<ruby>関数<rt>かんすう</rt>
                        </ruby>の<ruby>組<rt>く</rt></ruby>み<ruby>合<rt>あ</rt></ruby>わせです。
                    </aside>
                </section>

                <!-- When custom hooks required -->
                <section>
                    <h2>【例】同じロジックを何度も書いている...</h2>

                    <div class="comparison fragment">
                        <pre><code data-lang="jsx">function UserProfile({ userId }) {
    const [user, setUser] = useState(null);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState(null);
    
    useEffect(() => {
        fetch(`/api/users/${userId}`)
            .then(res => res.json())
            .then(setUser)
            .catch(setError)
            .finally(() => setLoading(false));
    }, [userId]);
    
    if (loading) return &lt;div&gt;ユーザーを読み込み中...&lt;/div&gt;;
    // ...
}</code></pre>
                        <div>
                            <pre><code data-lang="jsx">
function PostList() {
    const [posts, setPosts] = useState(null);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState(null);
    
    useEffect(() => {
        fetch('/api/posts')
            .then(res => res.json())
            .then(setPosts)
            .catch(setError)
            .finally(() => setLoading(false));
    }, []);
    
    if (loading) return &lt;div&gt;投稿を読み込み中...&lt;/div&gt;;
    // ...
}</code></pre>
                        </div>
                    </div>

                    <ol class="fragment compact-list">
                        <li>この3つの状態パターンが繰り返されている</li>
                        <li>この<code>useEffect</code>の<code>fetch</code>パターンも同じ</li>
                    </ol>
                    <p class="note fragment">バグ修正や機能追加で両方変更する必要があります</p>

                    <aside class="notes">
                        <ruby>二<rt>ふた</rt></ruby>つのコンポーネントが、ほぼ<ruby>同<rt>おな</rt></ruby>じコードを<ruby>書<rt>か</rt>
                        </ruby>いています。<br>
                        <ruby>三<rt>みっ</rt></ruby>つのstate、fetch、エラーハンドリング。<ruby>全部<rt>ぜんぶ</rt></ruby><ruby>同<rt>おな
                            </rt></ruby>じパターンです。<br>
                        もしバグがあったら、<ruby>両方<rt>りょうほう</rt></ruby><ruby>直<rt>なお</rt></ruby>さないといけません。<ruby>面倒<rt>めんどう
                            </rt></ruby>ですね。<br>
                        こういう<ruby>時<rt>とき</rt></ruby>が、カスタムフックを<ruby>作<rt>つく</rt></ruby>るタイミングです。
                    </aside>
                </section>

                <!-- Custom hook use case -->
                <section>
                    <h2>【例】カスタムフック</h2>

                    <div class="triptych centered">
                        <div>
                            <h5>共通状態ロジックを抽出</h5>
                            <pre><code data-lang="jsx">function useApi(url) {
    const [data, setData] = useState(null);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState(null);
    
    useEffect(() => {
        setLoading(true);
        fetch(url)
            .then(res => res.json())
            .then(setData)
            .catch(setError)
            .finally(() => setLoading(false));
    }, [url]);
    
    return { data, loading, error };
}</code></pre>
                        </div>
                        <div class="arrow fragment" data-fragment-index="1">➡</div>
                        <div class="fragment" data-fragment-index="1">
                            <h5>使用例：</h5>
                            <pre><code data-lang="jsx">function UserProfile({ userId }) {
    const { data, loading, error } = useApi(`/api/users/${userId}`);
    
    if (loading) return &lt;div&gt;ユーザーを読み込み中...&lt;/div&gt;;
    if (error) return &lt;div&gt;エラー&lt;/div&gt;;
    
    return &lt;div&gt;{data.name}&lt;/div&gt;;
}

function PostList() {
    const { data, loading, error } = useApi('/api/posts');
    
    if (loading) return &lt;div&gt;投稿を読み込み中...&lt;/div&gt;;
    if (error) return &lt;div&gt;エラー&lt;/div&gt;;
    
    return data.map(post => &lt;div&gt;{post.title}&lt;/div&gt;);
}</code></pre>
                        </div>
                    </div>

                    <aside class="notes">
                        <ruby>共通<rt>きょうつう</rt></ruby>のロジックをuseApiというフックに<ruby>抜<rt>ぬ</rt></ruby>き<ruby>出<rt>だ</rt>
                        </ruby>しました。<br>
                        これで、<ruby>二<rt>ふた</rt></ruby>つのコンポーネントはずっとシンプルになりました。<br>
                        バグ<ruby>修正<rt>しゅうせい</rt></ruby>も、useApiを<ruby>直<rt>なお</rt></ruby>すだけで<ruby>済<rt>す</rt>
                        </ruby>みます。<br>
                        <ruby>新<rt>あたら</rt></ruby>しいコンポーネントでも、<ruby>同<rt>おな</rt></ruby>じフックをすぐ<ruby>使<rt>つか</rt>
                        </ruby>えます。
                    </aside>
                </section>

                <section>
                    <h2>【例】なぜレンダリングロジックは含めないのか？</h2>
                    <div class="quote">フックはロジック、コンポーネントは表示</div>
                    <pre><code data-lang="jsx">// ❌ 責任が混在 - 再利用しにくい
function useBadApi(url) {
    // ... fetchロジック
    
    if (loading) return &lt;div&gt;読み込み中...&lt;/div&gt;;  // UIをフックが決めてる

    return data; // フックがデーターもを返してる？
}

// ✅ データだけを返して、表示は各コンポーネントに任せる
function useApi(url) {
    // ... fetchロジック

    return { data, loading, error };  // コンポーネントが表示を決める
}</code></pre>
                    <p class="note">フックは状態を管理、コンポーネントがJSXを管理</p>

                    <aside class="notes">
                        フックはデータだけを<ruby>返<rt>かえ</rt></ruby>すべきです。JSXは<ruby>返<rt>かえ</rt></ruby>しません。<br>
                        なぜなら、<ruby>表示<rt>ひょうじ</rt></ruby>の<ruby>仕方<rt>しかた</rt></ruby>は、コンポーネントごとに<ruby>違<rt>ちが</rt>
                        </ruby>うからです。<br>
                        ユーザープロフィールと<ruby>投稿<rt>とうこう</rt></ruby>リストでは、ローディング<ruby>画面<rt>がめん</rt></ruby>も<ruby>違<rt>ちが
                            </rt></ruby>うかもしれません。<br>
                        フックは「<ruby>何<rt>なに</rt></ruby>」を<ruby>提供<rt>ていきょう</rt></ruby>して、コンポーネントが「どう」<ruby>表示<rt>ひょうじ
                            </rt></ruby>するか<ruby>決<rt>き</rt></ruby>めます。
                    </aside>
                </section>

                <!-- Why make custom hook -->
                <section>
                    <h2>カスタムフックを作る理由</h2>

                    <div class="four-square">
                        <div class="fragment">
                            <h3>1. ロジックの再利用</h3>
                            <pre><code data-lang="jsx">// 複数のコンポーネントで同じロジック
function Profile() {
    const [isOpen, toggleOpen] = useToggle(false);
    // ...
}

function Settings() {
    const [isVisible, toggleVisible] = useToggle(true);
    // ...
}</code></pre>
                            <p>一度書けば、どこでも使える</p>
                        </div>

                        <div class="fragment">
                            <h3>2. 複雑なロジックの抽象化</h3>
                            <pre><code data-lang="jsx">function useApi(url) {
    // 3つの状態 + useEffect
    // 複雑なfetchロジック
    // ...
}

function Profile() {
    // シンプルな1行
    const { data, loading, error } = useApi(url);
}</code></pre>
                            <p>実装の詳細を気にしなくていい</p>
                        </div>

                        <div class="fragment">
                            <h3>3. テストが簡単</h3>
                            <p>フックは独立してテストできる</p>
                        </div>

                        <div class="fragment">
                            <h3>4. コンポーネントがすっきり</h3>
                            <p>ビジネスロジック vs 表示ロジック</p>
                        </div>
                    </div>

                    <aside class="notes">
                        カスタムフックの<ruby>一番<rt>いちばん</rt></ruby>の<ruby>利点<rt>りてん</rt></ruby>は、コードの<ruby>再利用<rt>さいりよう</rt>
                        </ruby>です。<br>
                        でも、それだけじゃありません。<ruby>複雑<rt>ふくざつ</rt></ruby>なロジックを<ruby>隠<rt>かく</rt></ruby>すこともできます。<br>
                        テストも<ruby>書<rt>か</rt></ruby>きやすくなります。フックだけをテストすればいいからです。<br>
                        <ruby>結果<rt>けっか</rt></ruby>として、コンポーネントは<ruby>表示<rt>ひょうじ</rt></ruby>に<ruby>集中<rt>しゅうちゅう</rt>
                        </ruby>できます。<ruby>綺麗<rt>きれい</rt></ruby>ですね。
                    </aside>
                </section>

                <!-- まとめ -->
                <section>
                    <h2>まとめ</h2>

                    <ul>
                        <li>既存のフックを組み合わせて作る独自のフック</li>
                        <li>複雑な状態ロジックを抽象化できる</li>
                        <li>コンポーネント間でロジックを簡単に共有できる</li>
                        <li>同じフックのルールが適用される</li>
                    </ul>

                    <aside class="notes">
                        カスタムフックは、Reactで<ruby>綺麗<rt>きれい</rt></ruby>なコードを<ruby>書<rt>か</rt></ruby>くための<ruby>重要<rt>じゅうよう
                            </rt></ruby>なテクニックです。<br>
                        <ruby>最初<rt>さいしょ</rt></ruby>は<ruby>難<rt>むずか</rt></ruby>しく<ruby>感<rt>かん</rt>
                        </ruby>じるかもしれませんが、<ruby>慣<rt>な</rt></ruby>れれば<ruby>自然<rt>しぜん</rt></ruby>に<ruby>使<rt>つか</rt>
                        </ruby>えます。<br>
                        <ruby>同<rt>おな</rt></ruby>じコードを<ruby>二回<rt>にかい</rt></ruby><ruby>書<rt>か</rt>
                        </ruby>いたら、カスタムフックを<ruby>考<rt>かんが</rt></ruby>えてみてください。
                    </aside>
                </section>
            </section>

            <section>
                <section>
                    <h4>理解度チェック①【フックのルール】</h4>
                    <div class="quiz">
                        <h3>このコードの問題は？</h3>
                        <pre><code data-lang="jsx">function Component({ showData }) {
  if (showData) {
    const [data, setData] = useState(null);
    
    useEffect(() => {
      fetchData().then(setData);
    }, []);
  }
  
  return &lt;&gt;...&lt;/&gt;;
}</code></pre>
                        <div class="quiz-options">
                            <div class="quiz-option">A) <code>fetchData</code>が定義されていない</div>
                            <div class="quiz-option custom fragment correct-answer" data-fragment-index="1">B)
                                条件分岐内でフックを呼んでいる</div>
                            <div class="quiz-option">C) <code>useEffect</code>の依存配列が間違い</div>
                            <div class="quiz-option">D) 特に問題なし</div>
                        </div>
                    </div>
                    <div class="fragment note" data-fragment-index="1">
                        <strong>答え:</strong> B) フックは必ずトップレベルで呼び出す必要がある
                    </div>
                    <aside class="notes">このコードは、<ruby>条件分岐<rt>じょうけんぶんき</rt></ruby>の中でフックを<ruby>使<rt>つか</rt>
                        </ruby>っています。<br>でも、Reactでは、フックは<ruby>関数<rt>かんすう</rt>
                        </ruby>の<ruby>一番上<rt>いちばんうえ</rt></ruby>で<ruby>使<rt>
                                つか</rt></ruby>わないといけません。<br>だから、Bが<ruby>正解<rt>せいかい</rt>
                        </ruby>です。</aside>
                </section>

                <section>
                    <h4>理解度チェック②【カスタムフック】</h4>
                    <div class="quiz">
                        <h3>次のうち、カスタムフックとして正しいものは？</h3>
                        <div class="comparison">
                            <pre><code data-lang="jsx">function getUser(id) { // A
    return fetch(`/users/${id}`); 
}

function useUser(id) { // C
    const [user, setUser] = useState(null); 
    return user; 
}
 </code></pre>
                            <pre><code data-lang="jsx">function useUser(id) { // B
    return fetch(`/users/${id}`); 
}

function User(id) { // D
    const [user, setUser] = useState(null); 
    return &lt;div&gt;{user}&lt;/div&gt;; 
}
</code></pre>
                        </div>
                        <div class="quiz-options">
                            <div class="quiz-option">A) <code>getUser(id)</code></div>
                            <div class="quiz-option">B) <code>useUser(id)</code></div>
                            <div class="quiz-option custom fragment correct-answer" data-fragment-index="1">C)
                                <code>useUser(id)</code>
                            </div>
                            <div class="quiz-option">D) <code>User(id)</code></div>
                        </div>
                    </div>
                    <div class="fragment note" data-fragment-index="1">
                        <strong>答え:</strong> C) 他のフックを呼んでいて、<code>use</code>で始まる
                    </div>
                    <aside class="notes">カスタムフックは、<code>use</code>で<ruby>始<rt>はじ</rt>
                        </ruby>まり、<ruby>中<rt>なか</rt></ruby>で<ruby>他<rt>ほか</rt></ruby>のフックを<ruby>使<rt>つか</rt>
                        </ruby>います。<br>Cの<code>useUser</code>は<code>useState</code>を<ruby>使<rt>つか</rt>
                        </ruby>っているので、<ruby>正<rt>ただ</rt></ruby>しいカスタムフックです。<br>だから、Cが<ruby>正解<rt>せいかい</rt></ruby>です。
                    </aside>
                </section>

                <section>
                    <h4>理解度チェック③【フックの呼び出し】</h4>
                    <div class="quiz">
                        <h3>このコードの問題は？</h3>
                        <pre><code data-lang="jsx">function useCounter() {
  let count = 0;  // 普通の変数
  const increment = () => count++;

  return [count, increment];
}
</code></pre>
                        <div class="quiz-options small">
                            <div class="quiz-option">A) 名前が間違っている</div>
                            <div class="quiz-option custom fragment correct-answer" data-fragment-index="1">B)
                                <code>count</code>が<code>useState</code>じゃない → 再レンダリングされない
                            </div>
                            <div class="quiz-option">C) <code>increment</code>の書き方が間違い</div>
                            <div class="quiz-option">D) 問題なし</div>
                        </div>
                    </div>
                    <div class="fragment note" data-fragment-index="1">
                        <strong>答え:</strong> B) 状態は<code>useState</code>で管理する必要がある
                    </div>
                    <aside class="notes">このコードでは、<code>count</code>が<ruby>普通<rt>ふつう</rt></ruby>の<ruby>変数<rt>へんすう</rt>
                        </ruby>です。<br>でも、Reactでは<ruby>状態<rt>じょうたい</rt>
                        </ruby>を<code>useState</code>で<ruby>管理<rt>かんり</rt></ruby>しないと、<ruby>再<rt>さい</rt>
                        </ruby>レンダリングされません。<br>だから、Bが<ruby>正解<rt>せいかい</rt></ruby>です。
                    </aside>
                </section>
            </section>

            <!-- Practice -->
            <section>
                <section>
                    <h1>React 実践演習</h1>
                    <h3>1つの課題 (15-20分)</h3>

                    <p>今日学んだ内容を実際に使ってみよう！</p>
                    <div class="note"><a target="_blank"
                            href="https://github.com/cdefined/front-kaizen/blob/master/react-lessons/lesson_4/task.md">react-lessons/lesson_4/task.md</a>
                    </div>
                </section>

                <section>
                    <div class="timer"></div>

                    <h2><span class="task-number">実践演習</span> ポケモンAPIフック</h2>

                    <p><strong>共通の<code>fetch</code>パターンを<code>useApi</code>フックに抽出してください</strong></p>
                    <br>
                    <div class="triptych-transformation">
                        <div>
                            <h4>現在：重複したコード</h4>
                            <ul class="compact-list font-smaller">
                                <li><code>PokemonCard</code> で <code>fetch</code></li>
                                <li><code>TypeInfo</code> でも同じ <code>fetch</code></li>
                                <li>同じ状態管理パターン</li>
                            </ul>
                        </div>

                        <div class="arrow">→</div>

                        <div>
                            <h4>目標：共通化</h4>
                            <ul class="compact-list font-smaller">
                                <li><code>useApi(url)</code> を作成</li>
                                <li>両方のコンポーネントで使用</li>
                                <li>重複を削除</li>
                            </ul>
                        </div>
                    </div>

                    <pre><code data-lang="typescript">function useApi&lt;T&gt;(url: string) {
  // 1. data, loading, error の状態を管理
  // 2. useEffect で fetch 処理を実装
  // 3. { data, loading, error } を返す
}

// 使用例
const { data, loading, error } = useApi&lt;Pokemon&gt;(url);</code></pre>

                    <div class="note"><a target="_blank"
                            href="https://github.com/cdefined/front-kaizen/blob/master/react-lessons/lesson_4/task.md">react-lessons/lesson_4/task.md</a>
                    </div>

                    <aside class="notes">
                        PokemonCard と TypeInfo を見てください。<br>
                        同じパターンがありますね。<br>
                        useApi を作って、共通化しましょう。<br>
                        15分くらいで作ってみてください。
                    </aside>
                </section>
            </section>

            <section>
                <!-- Summary -->
                <section>
                    <h1>第4回まとめ</h1>

                    <h2>今日学んだこと</h2>
                    <ul>
                        <li>フックは React の機能を活用するための特別な関数です</li>
                        <li>フックのルールを守らないと、バグやエラーが発生する可能性があります</li>
                        <li>カスタムフックを使えば、状態ロジックを抽象化して再利用できます</li>
                    </ul>
                </section>

                <section>
                    <h1>次のステップ</h1>

                    <ul>
                        <li>実際のプロジェクトで使ってみる</li>
                        <li>質問があればChatWorkで</li>
                        <li>宿題のプルリクエストは（まだ）大歓迎です</li>
                    </ul>
                </section>

                <section>
                    <h1>お疲れ様でした！</h1>
                    <p>ありがとうございました</p>
                </section>
            </section>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/reveal.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/plugin/notes/notes.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/plugin/markdown/markdown.min.js"></script>
    <script src="../../scripts/reveal-timer-plugin.js"></script>
    <script type="module">
        import { codeToHtml } from 'https://esm.sh/shiki@3.0.0';

        const codeBlocks = document.querySelectorAll('pre code[data-lang]');

        for (const block of codeBlocks) {
            const lang = block.dataset.lang;
            const theme = block.dataset.theme || 'night-owl'; // 'material-theme-darker'
            const rawCode = block.textContent.trim();

            const html = await codeToHtml(rawCode, { lang, theme });

            const wrapper = document.createElement('div');
            wrapper.innerHTML = html;
            const shikiHTML = wrapper.firstElementChild;

            const pre = block.closest('pre');
            if (pre && shikiHTML) pre.replaceWith(shikiHTML);
        }
    </script>

    <script>
        Reveal.initialize({
            hash: true,
            slideNumber: true,
            width: 1800,
            height: 900,
            margin: 0.1,
            transition: 'slide',
            transitionSpeed: 'fast',
            backgroundTransition: 'fade',
            plugins: [RevealNotes, RevealTimer, RevealMarkdown]
        });
    </script>
</body>

</html>