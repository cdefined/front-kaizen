<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta lang="ja">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TypeScript 入門 - 基礎編</title>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/reveal.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/theme/black.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">

    <style>
        .reveal {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        .reveal h1,
        .reveal h2,
        .reveal h3,
        .reveal h4 {
            color: #667eea;
            text-transform: none;
        }

        .reveal .slides section {
            text-align: left;
        }

        .reveal .title-slide {
            text-align: center;
        }

        .reveal .code-wrapper code {
            font-size: 1.3em;
        }

        .reveal .code-wrapper .code-medium {
            font-size: 1.19em;
        }

        .reveal .code-wrapper .code-medium-small {
            font-size: 1.1em;
        }

        .reveal .code-wrapper .code-small,
        .code-small {
            font-size: 0.9em;
        }

        .code-small .code-wrapper {
            width: 100%;
        }

        .reveal .comparison .hljs {
            max-height: 350px;
            min-height: unset;
            height: 100%;
        }

        ul>li {
            line-height: 2em;
        }

        .lifecycle {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 40px 0;
            padding: 20px;
            border-radius: 10px;
        }

        .lifecycle div {
            background: rgba(255, 255, 255, 0.1);
            flex: 1;
            text-align: center;
            padding: 10px;
            border-radius: 10px;
        }

        .lifecycle .arrow {
            background: none;
            font-size: 100px;
            color: #667eea;
            flex: 0;
        }

        .comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }

        .js-side,
        .ts-side {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 8px;
        }

        .js-side h4 {
            color: #f39c12;
        }

        .ts-side h4 {
            color: #3498db;
        }

        .note {
            background: rgba(52, 152, 219, 0.2);
            border-left: 4px solid #3498db;
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .warning {
            background: rgba(231, 76, 60, 0.2);
            border-left: 4px solid #e74c3c;
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .quiz {
            background: rgba(46, 204, 113, 0.1);
            border-left: 4px solid #2ecc71;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
        }

        .quiz-options {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr 1fr;
            gap: 10px;
        }

        .quiz-option {
            display: block;
            margin: 8px 0;
            padding: 8px 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .quiz-option:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .fragment.correct-answer.visible {
            border-left: 4px solid #2ecc71;
            background: rgba(46, 204, 113, 0.3);
        }

        .reveal pre code {
            max-height: 500px;
            font-size: 0.7em;
            line-height: 1.4;
        }

        .reveal code {
            color: #ff79c6;
        }

        .reveal .code-comment {
            color: #6272a4;
            font-style: italic;
        }

        .playground-demo {
            text-align: center;
            margin: 30px 0;
        }

        .reveal .playground-link {
            display: inline-block;
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            padding: 15px 30px;
            border-radius: 8px;
            text-decoration: none;
            font-weight: bold;
            transition: transform 0.3s;
            text-decoration: underline;
        }

        .reveal .playground-link:hover {
            color: white;
            transform: translateY(-2px);
        }
    </style>
</head>

<body>
    <div class="reveal">
        <div class="slides">
            <!-- Title -->
            <section class="title-slide">
                <h1>TypeScript 入門</h1>
                <h2>基礎編</h2>
            </section>

            <!-- Slide Group: What is TypeScript -->
            <section>

                <!-- Core Concept -->
                <section>
                    <h1>TypeScriptとは？</h1>
                    <p><strong>TypeScript = JavaScript + 静的型システム</strong></p>

                    <ul>
                        <li>JavaScriptはTypeScriptの部分集合です</li>
                        <li>実行にはJavaScriptへのトランスパイルが必要</li>
                        <li>Microsoftが2012年に開発</li>
                        <li>現在の最新バージョンは <strong>5.8.3</strong></li>
                        <li>TypeScript自体もTypeScriptで書かれている</li>
                    </ul>

                    <div class="note">
                        TypeScript 7 は、パフォーマンス向上のために Go で書き直される予定です。
                    </div>
                </section>


                <!-- Compilation Flow -->
                <section>
                    <h2>TypeScriptのライフサイクル</h2>
                    <div class="lifecycle">
                        <div>
                            <h4>.ts ファイル</h4>
                            <p>TypeScriptコード</p>
                        </div>
                        <div class="arrow">→</div>
                        <div>
                            <h4>tsc</h4>
                            <p>型チェック & 変換</p>
                        </div>
                        <div class="arrow">→</div>
                        <div>
                            <h4>.js ファイル</h4>
                            <p>実行可能なJS</p>
                        </div>
                    </div>
                    <div class="note">
                        <strong>重要:</strong> TypeScriptは実行時に存在しない。型情報はコンパイル時のみで使用される。
                    </div>
                </section>

                <!-- TS → JS Code Example -->
                <section>
                    <h2>コード例（変換前後）</h2>
                    <div class="comparison">
                        <div class="ts-side">
                            <h4>TypeScript</h4>
                            <pre>
                                <code class="language-typescript">
    // hello.ts
    function greet(name: string): string {
        return `Hello, ${name}!`;
    }
                                </code>
                            </pre>
                        </div>
                        <div class="js-side">
                            <h4>JavaScript</h4>
                            <pre>
                                <code class="language-javascript">
    // hello.js（コンパイル後）
    function greet(name) {
        return `Hello, ${name}!`;
    }
                                </code>
                            </pre>
                        </div>
                    </div>
                </section>

                <!-- Turing Complete + Doom -->
                <section>
                    <h2>型だけでDoom</h2>
                    <p>
                        TypeScriptの型システムはチューリング完全であり、型だけで
                        <a href="https://www.youtube.com/watch?v=0mCsluv5FXA" target="_blank">Doom</a>を再現可能。
                    </p>
                    <div class="note">
                        このプロジェクトでは3.5兆行の型定義と177TBのデータを処理し、1フレームの描画に12日間かかりました。
                    </div>
                </section>

            </section>


            <!-- Why TypeScript? -->
            <section>
                <section>
                    <h1>なぜ2025年にTypeScript？</h1>

                    <div class="fragment fade-in">
                        <h2>1. 型安全性 - バグの早期発見</h2>
                        <div class="comparison">
                            <div class="js-side code-small">
                                <h4>JavaScript - 実行時エラー</h4>
                                <pre><code class="language-javascript">function getUser(id) {
  return users.find(u => u.id === id);
}

const user = getUser("123");
console.log(user.name.toUpperCase());
// ☠️ TypeError: Cannot read property 'name' of undefined
</code></pre>
                            </div>
                            <div class="ts-side code-small">
                                <h4>TypeScript - コンパイル時に防げる</h4>
                                <pre><code class="language-typescript">function getUser(id: string): User | undefined {
  return users.find(u => u.id === id);
}

const user = getUser("123");
console.log(user.name.toUpperCase());
// ❌ Error: Object is possibly 'undefined'
</code></pre>
                            </div>
                        </div>
                    </div>
                </section>

                <section>
                    <h2>2. チーム開発に強い</h2>
                    <ul>
                        <li><strong>共通理解:</strong> 型定義がAPIの仕様書になる</li>
                        <li><strong>安全なリファクタ:</strong> 型が変更の影響を可視化</li>
                        <li><strong>IDE支援:</strong> 補完、警告、ジャンプ機能など</li>
                    </ul>
                </section>

                <section>
                    <h2>3. ドキュメントと型の一体化</h2>
                    <ul>
                        <li><strong>ドリフト防止:</strong> コードと仕様が常に一致</li>
                        <li><strong>自動生成:</strong> 型とコメントからAPI仕様を生成</li>
                        <li><strong>型ベースの検証:</strong> zodなどでランタイムにも活用可</li>
                    </ul>
                </section>

                <!-- DX -->
                <section>
                    <h2>4. なめらかな開発体験</h2>
                    <ul>
                        <li>初期設計から型を定義すると堅牢なコードに導かれる</li>
                        <li>コードレビューが効率化される</li>
                        <li>バックエンドと契約駆動開発しやすい</li>
                    </ul>
                </section>

                <!-- AI -->
                <section>
                    <h2>5. AIとコード</h2>
                    <ul>
                        <li><strong>型 = ヒント:</strong> LLMが正確に意図を読み取れる</li>
                        <li><strong>非型言語では:</strong> 推測ベースで不安定な提案が多い</li>
                        <li><strong>型情報の活用:</strong> 設計レベルの支援も可能になる</li>
                    </ul>
                </section>
            </section>

            <!-- How to start -->
            <section>
                <!-- Summary -->
                <section>
                    <h1>TypeScriptのセットアップ</h1>
                    <p>導入方法、コンパイル方法、<code>tsconfig.json</code>の設定、<code>.d.ts</code>ファイル</p>
                </section>

                <section>
                    <h2>TypeScriptの導入方法</h2>
                    <ul>
                        <li>npm でインストール (グローバル or ローカル)</li>
                        <li>最近のエディターには組み込みサポート</li>
                    </ul>
                </section>

                <section>
                    <h2>npmでのインストール</h2>
                    <pre><code># グローバル (どこでもCLI使用可能)
npm install -g typescript

# ローカル (プロジェクト推奨)
npm install --save-dev typescript</code></pre>
                </section>

                <section>
                    <h2>基本的なコンパイル</h2>
                    <pre><code># 全てをコンパイル
>>> tsc

# 型チェックのみ (JSファイル出力なし)
>>> tsc --noEmit

# 監視モード (変更時に自動再コンパイル)
>>> tsc --watch</code></pre>
                </section>

                <section>
                    <h2>tsconfig.json って何？</h2>
                    <ul>
                        <li>TypeScriptにコンパイル方法を指示</li>
                        <li>プロジェクトの境界を定義 (どのファイルを含むか)</li>
                        <li>型チェックルールを設定</li>
                    </ul>
                    <div class="note">
                        <strong>Tip:</strong> <code>tsc --init</code> で基本的なtsconfig.jsonを自動生成できる
                    </div>
                </section>

                <section>
                    <h2>tsconfig.json の基本設定</h2>
                    <pre><code class="code-medium language-json">{
  "compilerOptions": {
    "target": "ES2020",             // 出力されるJavaScriptのバージョン
    "module": "ESNext",             // 使用するモジュール方式
    "outDir": "./dist",             // コンパイル後のJavaScriptファイルの出力先ディレクトリ
    "rootDir": "./src",             // ソースのTypeScriptファイルがあるルートディレクトリ
    "strict": true,                 // 厳格な型チェックをすべて有効にする（推奨設定）
    "esModuleInterop": true         // CommonJSのモジュールをESモジュールのようにimport可能にする
  },
  "include": ["src/**/*"],          // コンパイル対象に含めるファイル
  "exclude": ["node_modules"]       // コンパイルから除外するファイルやフォルダ
}</code></pre>
                </section>

                <section>
                    <h2>d.ts ファイルとは？</h2>
                    <ul>
                        <li>型定義のみを記述するファイル</li>
                        <li>JSライブラリにTypeScriptの型情報を追加</li>
                        <li>実際のコードは含まない</li>
                    </ul>

                    <pre><code data-trim class="code-medium">// example.d.ts - 型定義ファイル
declare function myLibFunction(x: string): number;
declare const VERSION: string;

// モジュールの型定義
declare module "some-js-library" {
  export function doSomething(data: any): Promise<string>;
}</code></pre>

                    <div class="note">
                        <strong>実例:</strong> <code>npm install @types/node</code> でNode.jsのAPI型定義を取得
                    </div>
                </section>
            </section>

            <!-- Basic Types -->
            <section>
                <!-- Summary -->
                <section>
                    <h1>基本の型</h1>
                    <h3>TypeScriptの型システムの基礎</h3>
                    <p>プリミティブ型、配列、オブジェクト、<code>any</code>、<code>unknown</code></p>
                </section>

                <!-- Primitives -->
                <section>
                    <h2>プリミティブ型</h2>
                    <pre><code data-trim class="language-typescript">// 基本的なプリミティブ型
let characterName: string = "古手梨花";
let age: number = 11;
let isAlive: boolean = true;
let deathCount: null = null;
let mysteryStatus: undefined = undefined;

// symbol と bigint (ES2015+)
let fragmentId: symbol = Symbol("fragment");
let loopCount: bigint = 100000000000000000000n;
</code></pre>
                    <div class="note">
                        文字列、数値、真偽値、<code>null</code>、<code>undefined</code>、<code>symbol</code>、<code>bigint</code>
                    </div>
                </section>

                <!-- Arrays -->
                <section>
                    <h2>配列型</h2>
                    <pre><code data-trim class="language-typescript">// 配列の型定義 - 2つの書き方
let clubGrades: number[] = [1, 2, 3, 2, 1];
let clubMembers: Array&lt;string&gt; = ["竜宮レナ", "園崎魅音", "古手梨花", "北条沙都子"];

// 読み取り専用配列
let rules: ReadonlyArray&lt;string&gt; = ["鬼隠し", "綿流し", "祟殺し"];
// rules.push("暇潰し"); // エラー！

// 読み取り専用配列（readonly 修飾子）
let legends: readonly string[] = ["雛見沢症候群", "綿流しの儀式", "祟りの噂"];
// legends.pop(); // エラー！
</code></pre>
                    <div class="note">
                        <code>Type[]</code> vs <code>Array&lt;Type&gt;</code> - どちらでもOK、チーム規約で統一
                    </div>
                </section>

                <section>
                    <h2>配列型</h2>
                    <pre><code data-trim class="language-typescript">// 混合型の配列
let evidence: (string | number)[] = ["鬼隠し", 1983, "綿流し", 1982];

// 多次元配列
let board: string[][] = [
  ["X", "O", "X"],
  [" ", "X", "O"],
  ["O", " ", " "]
];
</code></pre>
                </section>

                <!-- Objects -->
                <section>
                    <h2>オブジェクト型</h2>
                    <pre><code data-trim class="code-medium-small">// オブジェクトの型定義
let clubMember: { name: string; age: number; weapon?: string } = {
    name: "竜宮レナ",
    age: 16
};

// インデックスシグネチャ
let suspicionLevels: { [character: string]: number } = {
    "前原圭一": 3,
    "竜宮レナ": 5,
    "園崎魅音": 2
};</code></pre>
                </section>
                <section>
                    <h2>オブジェクト型</h2>
                    <pre><code data-trim class="code-medium-small">// ネストしたオブジェクト
let village: {
    name: string;
    location: {
        prefecture: string;
        population: number;
    };
} = {
    name: "雛見沢村",
    location: {
        prefecture: "岐阜県",
        population: 2000
    }
};</code></pre>
                </section>
                <section>
                    <h2>オプショナルプロパティ</h2>
                    <p><strong>?マーク</strong>は「省略可能」を意味し。<code>weapon</code>は省略可能。</p>
                    <pre><code data-trim class="code-medium-small">let character: { 
    name: string; 
    weapon?: string; // string | undefined
} = {
    name: "古手梨花"
};

if (character.weapon) { 
    console.log(character.weapon.toUpperCase()); // 安全なアクセス方法：型ガード
}

console.log(character.weapon?.toUpperCase()); // 安全なアクセス方法：オプショナルチェーン</code></pre>
                    <p><code>undefined</code>との違い</p>
                    <pre><code data-trim class="code-medium-small">let explicitUndefined: { name: string; weapon: string | undefined } = {
    name: "前原圭一",
    weapon: undefined  // 明示的にundefinedを設定する必要がある
};</code></pre>
                </section>

                <!-- any type -->
                <section>
                    <h2>any型</h2>
                    <pre><code data-trim class="code-medium language-typescript">// any型 - TypeScriptの型チェックを無効化
let mysteryData: any = "綿流し";
mysteryData = 1983;
mysteryData = true;
mysteryData = { killer: "unknown" };

// なんでもできてしまう（危険）
mysteryData.oyashiro.curse.activate; // エラーにならない
mysteryData(); // エラーにならない
mysteryData[0][1][2]; // エラーにならない

// 型の利益を失う
let result = mysteryData + 5; // resultの型もany
</code></pre>
                    <div class="note">
                        <code>any</code>はTypeScriptの型安全性を完全に無効化する
                    </div>
                </section>

                <!-- Baka any -->
                <section>
                    <h2>any型の問題</h2>
                    <ul>
                        <li>型チェックが無効化される</li>
                        <li>コード補完が効かない</li>
                        <li>ランタイムエラーの原因</li>
                        <li>リファクタリングが困難</li>
                        <li>TypeScriptの恩恵を失う</li>
                    </ul>
                </section>

                <!-- unknown type -->
                <section>
                    <h2>unknown型</h2>
                    <pre><code data-trim class="code-medium-small language-typescript">let secret: unknown = investigate();

// 直接操作はエラー
// villageSecret.toUpperCase(); // エラー！
// villageSecret + 5; // エラー！

// 型ガードが必要
if (typeof secret === "string") {
  console.log(secret.toUpperCase()); // OK
}

if (typeof secret === "number") {
  console.log(secret.toFixed(2)); // OK
}</code></pre>
                    <div class="note">
                        <code>unknown</code>は使用前に型チェックを強制する
                    </div>
                </section>

                <!-- Quiz -->
                <section>
                    <h4>理解度チェック①</h4>
                    <div class="quiz">
                        <h3>どちらがエラーになる？</h3>
                        <pre><code class="language-typescript">let mysteryA: any = "梨花";
let mysteryB: unknown = "梨花";

mysteryA.toUpperCase(); // A
mysteryB.toUpperCase(); // B</code></pre>
                        <div class="quiz-options">
                            <div class="quiz-option">A) mysteryA.toUpperCase()</div>
                            <div class="quiz-option fragment custom correct-answer" data-fragment-index="1">B)
                                mysteryB.toUpperCase()</div>
                            <div class="quiz-option">C) 両方エラー</div>
                            <div class="quiz-option">D) 両方エラーなし</div>
                        </div>
                    </div>
                    <div class="fragment" data-fragment-index="1">
                        <div class="note">
                            <strong>答え:</strong> B) <code>unknown</code>は型ガードが必要。<code>any</code>は何でもOK（危険）
                        </div>
                    </div>
                </section>

                <!-- Quiz -->
                <section>
                    <h4>理解度チェック②</h4>
                    <div class="quiz">
                        <h3>次のコードで型エラーになるのは？</h3>
                        <pre><code class="language-typescript">let clubMembers: string[] = ["圭一", "レナ", "魅音"];
let suspicionLevels: number[] = [3, 5, 2];

clubMembers.push("梨花"); // A
clubMembers.push(4); // B
suspicionLevels[0] = 10; // C
console.log(suspicionLevels.length); // D</code></pre>
                        <div class="quiz-options">
                            <div class="quiz-option">A) clubMembers.push("梨花");</div>
                            <div class="quiz-option fragment custom correct-answer" data-fragment-index="1">B)
                                clubMembers.push(4);</div>
                            <div class="quiz-option">C) suspicionLevels[0] = 10;</div>
                            <div class="quiz-option">D) suspicionLevels.length;</div>
                        </div>
                    </div>
                    <div class="fragment" data-fragment-index="1">
                        <div class="note">
                            <strong>答え:</strong> B) <code>string[]</code>に<code>number</code>は追加できない
                        </div>
                    </div>
                </section>

                <!-- Quiz: objects -->
                <section>
                    <h4>理解度チェック③</h4>
                    <div class="quiz">
                        <h3>どの代入が可能？</h3>
                        <pre><code class="language-typescript code-medium">let villager: { name: string; age: number; occupation: string } = {
  name: "入江京介",
  age: 35,
  occupation: "医師",
};

villager.name = "富竹ジロウ"; // A
villager.email = "irie@clinic.com"; // B
villager.age = "三十五歳"; // C
villager = null; // D</code></pre>
                        <div class="quiz-options">
                            <div class="quiz-option fragment custom correct-answer" data-fragment-index="1">A)
                                villager.name = "富竹ジロウ";</div>
                            <div class="quiz-option">B) villager.email = "irie@clinic.com";</div>
                            <div class="quiz-option">C) villager.age = "三十五歳";</div>
                            <div class="quiz-option">D) villager = null;</div>
                        </div>
                    </div>
                    <div class="fragment" data-fragment-index="1">
                        <div class="note">
                            <strong>答え:</strong> A) のみ。存在する<code>string</code>型プロパティへの代入
                        </div>
                    </div>
                </section>

                <!-- Quiz -->
                <section>
                    <h4>理解度チェック④</h4>
                    <div class="quiz">
                        <h3>どの操作がエラーになる？</h3>
                        <pre><code class="language-typescript">let gameArcs: ReadonlyArray&lt;string&gt; = ["鬼隠し", "綿流し", "祟殺し"];

console.log(gameArcs[0]) // A 
console.log(gameArcs.length) // B 
gameArcs.push("暇潰し") // C 
let copy = [...gameArcs] // D 
</code></pre>
                        <div class="quiz-options">
                            <div class="quiz-option">A) gameArcs[0]</div>
                            <div class="quiz-option">B) gameArcs.length</div>
                            <div class="quiz-option fragment custom correct-answer" data-fragment-index="1">C)
                                gameArcs.push("暇潰し")</div>
                            <div class="quiz-option">D) [...gameArcs]</div>
                        </div>
                    </div>
                    <div class="fragment" data-fragment-index="1">
                        <div class="note">
                            <strong>答え:</strong> C) <code>ReadonlyArray</code>は変更操作が禁止
                        </div>
                    </div>
                </section>
            </section>

            <!-- Type Inference -->
            <section>
                <section>
                    <h1>型推論 「Type Inference」</h1>
                    <pre><code class="language-typescript code-medium-small">// 基本的な型推論
let price = 1000;        // number
let name = "商品A";      // string
let available = true;    // boolean

// 配列推論
let items = [1, 2, 3];   // number[]
let mixed = [1, "text"]; // (number | string)[]</code></pre>
                    <div class="note">
                        <strong>ベストプラクティス:</strong> 明示的な型注釈は避けて推論に任せる
                    </div>
                </section>

                <section>
                    <h2>d.tsファイルでの型情報</h2>
                    <pre><code class="language-typescript code-medium-small">// 元のコード
export function processOrder(id: number) {
    const order = { id, status: "pending", total: 0 };
    return order;
}

// 生成されるd.ts
export declare function processOrder(id: number): {
    id: number;
    status: string;
    total: number;
};</code></pre>
                    <div class="note">
                        <strong>Tip:</strong> 関数の戻り値は基本的に型推論に任せる。パラメータや複雑な型だけ明示する。
                    </div>
                </section>
            </section>

            <!-- Union -->
            <section>
                <section>
                    <h1>Union型</h1>
                    <h3>複数の型を許可する柔軟性</h3>
                    <div class="fragment">
                        <p>「AまたはB」の型を表現</p>
                        <p><code>|</code> (pipe) 演算子で結合</p>
                    </div>
                </section>

                <!-- Basic Union -->
                <section>
                    <h2>基本的なUnion型</h2>
                    <pre><code class="language-typescript">// 数値または文字列
let userId: number | string = 123;
userId = "user_456"; // 再代入OK

// 複数の型を許可
let value: string | number | boolean;
value = "hello";  // ✓
value = 42;       // ✓
value = true;     // ✓
value = null;     // ❌ Error</code></pre>
                    <div class="note">
                        型安全性を保ちながら柔軟性を確保
                    </div>
                </section>

                <!-- Type Guards -->
                <section>
                    <h2>型ガードでの絞り込み</h2>
                    <pre><code class="language-typescript code-medium-small">function formatId(id: number | string): string {
    if (typeof id === "number") {
        // この中ではnumber型として扱われる
        return `ID: ${id.toString().padStart(6, '0')}`;
    } else {
        // この中ではstring型として扱われる
        return `ID: ${id.toUpperCase()}`;
    }
}

formatId(123);        // "ID: 000123"
formatId("abc_456");  // "ID: ABC_456"</code></pre>
                    <div class="note">
                        <strong>型ガード:</strong> 実行時チェックでTypeScriptが型を理解
                    </div>
                </section>

                <!-- Null Union -->
                <section>
                    <h2>null許可型</h2>
                    <pre><code class="language-typescript code-medium-small">// よく使うパターン
let message: string | null = null;
let data: User | undefined;

// null チェック後は型が絞り込まれる
if (message !== null) {
    console.log(message.toUpperCase()); // string確定
}

// Optional chaining と組み合わせ
function processUser(user: User | null) {
    console.log(user?.name?.toUpperCase());
}</code></pre>
                    <div class="note">
                        <code>strictNullChecks</code>が有効なら必須の考慮
                    </div>
                </section>

                <!-- Literal Union -->
                <section>
                    <h2>リテラル型のUnion</h2>
                    <pre><code class="language-typescript code-medium-small">// enum的な使い方
type Status = "pending" | "approved" | "rejected";
type HttpMethod = "GET" | "POST" | "PUT" | "DELETE";

function makeRequest(url: string, method: HttpMethod) {
    // 実装
}

makeRequest("/api/users", "GET");    // ✓ Valid
makeRequest("/api/users", "PATCH");  // ❌ Error

// 数値リテラルも可能
type DiceRoll = 1 | 2 | 3 | 4 | 5 | 6;</code></pre>
                    <div class="note">
                        文字列定数の集合を型として表現
                    </div>
                </section>

                <!-- Discriminated Union -->
                <section>
                    <h2>判別可能なUnion「Discriminated Union」</h2>
                    <pre><code class="language-typescript code-medium-small">// 共通プロパティで判別
type ApiResponse = 
    | { success: true; data: any }
    | { success: false; error: string };

function handleResponse(response: ApiResponse) {
    if (response.success) {
        console.log(response.data);    // dataが存在することを理解
    } else {
        console.log(response.error);   // errorが存在することを理解
    }
}</code></pre>
                    <div class="note">
                        <strong>判別プロパティ:</strong> <code>success</code>で型を特定
                    </div>
                </section>

                <!-- Quiz -->
                <section>
                    <h4>理解度チェック⑤</h4>
                    <div class="quiz">
                        <h3>どの代入がエラーになる？</h3>
                        <pre><code class="language-typescript">type GameResult = "win" | "lose" | "draw";
let result: GameResult;

result = "win";     // A
result = "victory"; // B
result = "draw";    // C
result = null;      // D</code></pre>
                        <div class="quiz-options">
                            <div class="quiz-option">A) result = "win"</div>
                            <div class="quiz-option fragment custom correct-answer" data-fragment-index="1">B) result =
                                "victory"</div>
                            <div class="quiz-option">C) result = "draw"</div>
                            <div class="quiz-option fragment custom correct-answer" data-fragment-index="1">D) result =
                                null</div>
                        </div>
                    </div>
                    <div class="fragment" data-fragment-index="1">
                        <div class="note">
                            <strong>答え:</strong> B, D - 定義された文字列リテラル以外はエラー
                        </div>
                    </div>
                </section>
            </section>

            <!-- Functions -->
            <section>
                <section>
                    <h1>関数の型定義</h1>
                    <pre><code class="code-medium-small fragment">// 基本的な関数
function add(a: number, b: number): number {
    return a + b;
}

// アロー関数
const multiply = (x: number, y: number): number => x * y;
</code></pre>
                    <pre><code class="code-medium-small fragment language-typescript">// コールバック関数の型
function processData(
    data: string[], 
    callback: (item: string) => string
): string[] {
    return data.map(callback);
}</code></pre>
                </section>
                <section>
                    <h2>関数の型定義</h2>
                    <pre><code class="code-medium-small">// オプショナル引数（?を使う）
function greet(name: string, title?: string): string {
    if (title) {
        return `${title} ${name}`;
    }
    return `Hello, ${name}`;
}</code></pre>
                    <pre><code class="code-medium-small fragment">// デフォルト引数
function createUser(name: string, age: number = 18) {
    return { name, age }; // 戻り値の型は推論される
}</code></pre>

                    <pre><code class="code-medium-small fragment">// Rest引数
function sum(...numbers: number[]): number {
    return numbers.reduce((total, num) => total + num, 0);
}</code></pre>
                </section>
                <section>
                    <h2>関数オーバーロード</h2>
                    <pre><code>function convert(input: string): number;
function convert(input: number): string;
function convert(input: string | number): string | number {
    if (typeof input === "string") {
        return parseInt(input, 10);
    } else {
        return input.toString();
    }
}</code></pre>
                    <div class="note">
                        オーバーロードは関数の異なるシグネチャを定義することで、同じ関数名で異なる引数を受け取ることができる
                    </div>
                </section>
            </section>

            <!-- Void and never -->
            <section>
                <section>
                    <h1>void型とnever型</h1>
                    <h3>特殊な戻り値の型</h3>
                    <div class="fragment">
                        <p><strong>void:</strong> 戻り値なし（undefined）</p>
                        <p><strong>never:</strong> 絶対に戻らない</p>
                    </div>
                </section>

                <!-- Void -->
                <section>
                    <h2>void型 - 戻り値なし</h2>
                    <pre><code class="language-typescript code-medium-small">// void型 - undefinedを返す
function logMessage(message: string): void {
    console.log(`[LOG] ${message}`); // 暗黙的にundefinedを返す
}</code></pre>

                    <pre><code class="language-typescript code-medium-small">// voidは通常推論されるので省略可能
function saveToDatabase(data: any) {
    console.log("データを保存しました"); // 戻り値の型は自動的にvoidになる
}</code></pre>

                    <pre><code class="language-typescript code-medium-small">// void関数からundefinedは返せる
function processData(): void {
    console.log("処理完了");
    return; // OK
    // return undefined; // これもOK
    // return null; // ❌ Error
}</code></pre>
                    <div class="note">
                        <strong>用途:</strong> 副作用のある関数（ログ出力、DOM操作など）
                    </div>
                </section>

                <!-- Never -->
                <section>
                    <h2>never型 - 絶対に戻らない</h2>
                    <pre><code class="language-typescript code-medium-small">function throwError(message: string): never { // never型 - 例外を投げる
    throw new Error(message); // この後のコードは実行されない
}

function infiniteLoop(): never { // never型 - 無限ループ
    while (true) {}
}

function processValue(value: unknown): string { // 関数が途中で例外を投げる場合
    if (typeof value === "string") {
        return value.toUpperCase();
    }
    throwError("文字列以外は処理できません"); // ここでnever型を返す
}</code></pre>
                    <div class="note">
                        <strong>用途:</strong> エラーハンドリング、到達不可能コードの表現
                    </div>
                </section>

                <!-- Exhaustive Checking -->
                <section>
                    <h2>never型の実用例</h2>
                    <h3>網羅性チェック　「Exhaustive Checking」</h3>
                    <pre><code class="language-typescript code-medium-small">type Color = "amethyst" | "green";

function getColorHex(color: Color): string {
    switch (color) {
        case "amethyst":
            return "#955CD0";
        case "green":
            return "#8EDF5F";
        default:
            // 新しい色をUnionに追加したらここでエラー
            const exhaustiveCheck: never = color;
            throw new Error(`未処理の色: ${exhaustiveCheck}`);
    }
}</code></pre>
                    <div class="note">
                        <strong>メリット:</strong> Union型に新しい値を追加した時、処理漏れを防げる
                    </div>
                </section>

                <!-- void vs never -->
                <section>
                    <h2>void vs never の違い</h2>
                    <div class="comparison">
                        <div>
                            <h3>void型</h3>
                            <ul>
                                <li>関数は<strong>正常終了</strong>する</li>
                                <li><code>undefined</code>を返す</li>
                                <li>副作用のある処理</li>
                                <li>呼び出し元に制御が戻る</li>
                            </ul>
                        </div>
                        <div>
                            <h3>never型</h3>
                            <ul>
                                <li>関数は<strong>絶対に終了しない</strong></li>
                                <li>何も返さない</li>
                                <li>例外・無限ループ</li>
                                <li>呼び出し元に制御が戻らない</li>
                            </ul>
                        </div>
                    </div>
                </section>

                <!-- Quiz -->
                <section>
                    <h4>理解度チェック⑥</h4>
                    <div class="quiz">
                        <h3>どの関数がnever型を返すべき？</h3>
                        <div class="comparison">
                            <pre><code class="language-typescript code-small">// A
function printHello() {
    console.log("Hello!");
}

// B
function divide(a: number, b: number) {
    if (b === 0) {
        throw new Error("ゼロ除算エラー");
    }
    return a / b;
}</code></pre>

                            <pre><code class="language-typescript code-small">// C
function panic() {
    throw new Error("システムエラー");
}

// D
function getUserName() {
    return null;
}</code></pre>
                        </div>
                        <div class="quiz-options">
                            <div class="quiz-option">A) printHello</div>
                            <div class="quiz-option">B) divide</div>
                            <div class="quiz-option fragment custom correct-answer" data-fragment-index="1">C) panic
                            </div>
                            <div class="quiz-option">D) getUserName</div>
                        </div>
                    </div>
                    <div class="fragment" data-fragment-index="1">
                        <div class="note">
                            <strong>答え:</strong> C) panic - 常に例外を投げて絶対に戻らない
                        </div>
                    </div>
                </section>
            </section>

            <section>
                <!-- Practice -->
                <!-- Title Slide -->
                <section>
                    <h1>TypeScript 実践演習</h1>
                    <h3>3つの課題 (各5-10分)</h3>
                    <p>今日学んだ内容を実際に使ってみよう！</p>
                </section>

                <!-- TypeScript Playground -->
                <section>
                    <h1>TypeScript Playground</h1>

                    <div class="playground-demo">
                        <a href="https://www.typescriptlang.org/play" class="playground-link" target="_blank">
                            https://www.typescriptlang.org/play
                        </a>
                    </div>

                    <h2>Playgroundでできること:</h2>
                    <ul>
                        <li>ブラウザでTypeScriptを実行・テスト</li>
                        <li>コンパイル結果をリアルタイム確認</li>
                        <li>型エラーの詳細表示</li>
                        <li>異なるターゲット（ES5, ES2020等）の比較</li>
                        <li>型定義の探索とテスト</li>
                    </ul>
                </section>


                <!-- Task 1 -->
                <section>
                    <h2><span class="task-number">課題1</span> Union型とtype guard</h2>

                    <p><strong>関数 <code>processId</code> を作成してください</strong></p>
                    <ul>
                        <li>引数 <code>id</code> は <code>number</code> または <code>string</code> のいずれかです</li>
                        <li><code>number</code> の場合は <code>"ID: 123"</code>、<code>string</code> の場合は
                            <code>"CODE: ABC"</code> の形式で返す
                        </li>
                    </ul>

                    <pre><code class="typescript">// テスト
console.log(processId(123));    // "ID: 123"
console.log(processId("ABC"));  // "CODE: ABC"
                </code></pre>
                </section>

                <!-- Task 1 Solution -->
                <section>
                    <h2><span class="task-number">課題1</span> 解答例</h2>
                    <p>型ガード　【type guard】を使うことができます</p>
                    <pre><code class="typescript">function processId(id: number | string): string {
    // typeof演算子を使って型を判定
    if (typeof id === "number") {
        return `ID: ${id}`;
    } else {
        return `CODE: ${id}`;
    }
}</code></pre>
                </section>

                <!-- Task 2 -->
                <section>
                    <h2><span class="task-number">課題2</span> オプション値と配列</h2>

                    <p><strong>関数 <code>createMessage</code> を作成してください</strong></p>
                    <ul>
                        <li>名前と省略可能なタグを受け取ります</li>
                        <li>タグがある場合は <code>"Hello 名前 [tag1, tag2]"</code>、ない場合は <code>"Hello 名前"</code> を返します</li>
                    </ul>

                    <pre><code class="typescript">// テスト
console.log(createMessage("Takano"));                    // "Hello Takano"
console.log(createMessage("Satoko", ["admin", "user"])); // "Hello Satoko [admin, user]"
                </code></pre>
                </section>

                <!-- Task 2 Solution -->
                <section>
                    <h2><span class="task-number">課題2</span> 解答例</h2>
                    <p>オプション引数は <code>undefined</code> かもしれないので存在チェックが必要</p>
                    <pre><code class="typescript">function createMessage(name: string, tags?: string[]): string {
    if (tags) { // tags?.join() でもOK
        return `Hello ${name} [${tags.join(", ")}]`;
    } else {
        return `Hello ${name}`;
    }
}</code></pre>
                </section>

                <!-- Task 3 -->
                <section>
                    <h2><span class="task-number">課題3</span> 型推論</h2>

                    <p><strong>関数 <code>investigateFragment</code> を作成してください</strong></p>
                    <ul>
                        <li>引数: <code>fragments</code> は数値の配列または文字列の配列</li>
                        <li>配列の最初の要素を返す。空配列の場合は <code>"nanodesu"</code> を返す</li>
                        <li>型を判定する処理を書いてください</li>
                    </ul>

                    <pre><code class="typescript">// テスト
console.log(investigateFragment([1983, 1984, 1985]));   // 1983
console.log(investigateFragment(["rena", "mion"]));     // "rena"
console.log(investigateFragment([]));                   // "nanodesu"
    </code></pre>
                </section>

                <!-- Task 3 Solution -->
                <section>
                    <h2><span class="task-number">課題3</span> 解答例</h2>
                    <p>空配列の場合の処理がポイント</p>
                    <pre><code class="typescript code-medium-small">function investigateFragment(fragments: number[] | string[]): number | string | "nanodesu" {
    // 空配列の場合の処理
    if (fragments.length === 0) {
        return "nanodesu";
    }
    
    // 型ガードで配列の型を判定
    if (typeof fragments[0] === "number") {
        return fragments[0]; // number配列の場合
    } else {
        return fragments[0]; // string配列の場合
    }
}</code></pre>
                </section>

                <!-- Task 3 Alternative Solutions -->
                <section>
                    <h2><span class="task-number">課題3</span> 別解</h2>
                    <p>TypeScriptの型推論を活用した書き方</p>
                    <pre><code class="typescript code-medium-small">// 別解1: 型推論を活用
function investigateFragment(fragments: number[] | string[]): number | string | "nanodesu" {
    if (fragments.length === 0) {
        return "nanodesu";
    }
    
    return fragments[0]; // TypeScriptが自動で型を推論
}

// 別解2: より簡潔な書き方
function investigateFragment(fragments: number[] | string[]): number | string | "nanodesu" {
    return fragments[0] ?? "nanodesu";
}</code></pre>
                </section>
            </section>


            <!-- Summary -->
            <section>
                <h1>第1回まとめ</h1>

                <h2>今日学んだこと</h2>
                <ul>
                    <li><strong>TypeScript の基本:</strong> tsc コンパイラーと型システム</li>
                    <li><strong>コマンドライン操作:</strong> プロジェクト設定と tsconfig.json</li>
                    <li><strong>基本型:</strong> primitive types、arrays、objects</li>
                    <li><strong>型推論:</strong> TypeScript の自動型判定システム</li>
                    <li><strong>Union型:</strong> 複数の型を許可する方法</li>
                    <li><strong>関数の型:</strong> 引数、戻り値、オプション、オーバーロード</li>
                    <li><strong>void と never:</strong> 特殊な戻り値型</li>
                </ul>
            </section>

            <!-- Homework -->
            <section>
                <section>
                    <h1>宿題・実践課題</h1>

                    <h3>斬魄刀コレクション管理システム</h3>
                    <div class="note"><a href="homework/README.md" target="_blank">lesson1/homework/README.md</a></div>
                </section>
                <section>
                    <h1>実践での重要ポイント</h1>
                    <ul>
                        <li>型推論を信頼しつつ、関数の戻り値は明示的に書く</li>
                        <li>Union型は実際のデータ構造を反映する（"melee" | "kido" など）</li>
                        <li>Optional型（?）で「あるかもしれない」データを表現</li>
                        <li>Type guardでランタイムの型チェックと型の絞り込みを両立</li>
                        <li>配列操作（filter, map, sort）とTypeScriptの組み合わせに慣れる</li>
                    </ul>
                </section>
            </section>

            <!-- In next episode -->
            <section>
                <h1>次回予告</h1>
                <p><strong>TypeScript入門②:</strong> interface、type aliases、enum、generics、utility types</p>
            </section>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/reveal.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.6.1/plugin/highlight/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/typescript.min.js"></script>

    <script>
        Reveal.initialize({
            hash: true,
            slideNumber: true,
            width: 1800,
            height: 900,
            margin: 0.1,
            transition: 'slide',
            transitionSpeed: 'fast',
            backgroundTransition: 'fade',
            plugins: [RevealHighlight],
            highlight: {
                escapeHTML: true
            }
        });

        // Quiz interaction
        document.querySelectorAll('.quiz-option').forEach(option => {
            option.addEventListener('click', function () {
                // Remove previous selections
                this.parentNode.querySelectorAll('.quiz-option').forEach(opt => {
                    opt.style.background = 'rgba(255,255,255,0.1)';
                });

                // Highlight selected option
                this.style.background = 'rgba(102, 126, 234, 0.5)';
            });
        });
    </script>
</body>

</html>